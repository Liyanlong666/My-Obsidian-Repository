## RLE
RLE (run-length encoding)，游程编码，是一个特别简单的编码算法，原理是使用一个计数来代表连续重复的单元个数。比如一段连续的文本 “AAAABBBBBCCDEEE”，那么使用 RLE 编码后则为 “A4B5C2D1E3”，很明显，编码后的字节数减少了。但是如果文本中重复的字符不多的话，编码后的数据反而会比原始文本大。因此，RLE 适合用于重复单元较多的场景。

## **VInt **
在计算机中 int32 和 int64 分别占用 4 字节和 8 字节，这种固定编码长度的优点是解码快速，但是缺点也很明显，对于小数值，也要占用相同字节数，浪费空间。解决办法就是使用变长编码表示整数，VInt 编码的原理其实很简单，将每个字节的最高位当做标记位，0 表示当前字节是编码后的最后一个字节，1 表示下个字节也属于当前编码数。每个字节的低 7 位存储真实数据，这里贴下 lucene 的实现代码：

```java
public final void writeVInt(int i) throws IOException {
    while ((i & ~0x7F) != 0) {
        writeByte((byte) ((i & 0x7F) | 0x80));
        i >>>= 7;
    }
    writeByte((byte) i);
}
```

:::danger
VInt 采用的是小端编码，即低位数字节放在前面，高位数放在后面。比如，对于 32 位整数 129，编码如下：

:::

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/49518801/1755668329984-b3956e23-9f69-4421-80a7-4b63de334eee.png)

编码后，4 字节整数用 2 字节即可表示，存储开销缩小 1 倍。本质上，VInt 是通过避免存储前导 0 来节约空间，<font style="background-color:#FBDE28;">因此，VInt 非常适合较小数编码，对于大数和负数，可能编码后的字节数会更大。</font>

## **ZigZag **
VInt 主要是通过减少存储前导 0 来节省空间，但是对于负数，永远没有前导 0，VInt 无法压缩。ZigZag 要做的就是将负数变为正数，增加前导 0，在此基础上再通过 VInt 编码，便能达到较好的压缩效果。

我们知道，在计算机系统中，数值使用补码表示和存储，最高位表示符号位，其他位为数值位。负数的符号位为 1，数值位为原码取反加 1，比如 -10 的补码如下：

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/49518801/1755668329926-d6e14eb4-5a2c-43b7-bcbb-885fbbde70ff.png)

看出问题了吗？这种数值较小的负数，前导 1 的数量较多，所以要实现 VInt 编码压缩是不现实的。那么我们想办法把前导 1 干掉不就行了吗，那直接将所有位取反，把前导 1 都变成前导 0，这个方法看似挺好，但是正数怎么办？显然正数不取反，但是解码时也无法区分编码前是负数还是正数。

上面的方法不行，那么我们把符号位右移到最低位，数值位左移一位，如下：

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/49518801/1755668329911-2ed3473f-9ce1-46b5-a8db-627afec0d31f.png)

这么做的好处是既保留了符号位，同时前导 1 依然很多，我们再对数值位取反，如下：

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/49518801/1755668329957-5857ecd8-8fe2-4df4-a1e2-1aa49a0299d0.png)

如此这般，前导 1 都变成前导 0，优秀！对于正数，数值位不变即可，解码时，根据最低位来判断正负并决定是否取反。这样看起来貌似解决问题了，但是解码多了一个判断分支，增加了解码开销，能否做得更极致呢？我们直接来看 lucene 的代码：

```java
public static int zigZagEncode(int i) {
return (i >> 31) ^ (i << 1);
}
```

咋一看，好像不太明白，我们拆开来看：

i >> 31，相当于将符号位右移到最低位，高位用符号位填充，也就是说对于负数右移 31 位则所有位都为 1；正数右移 31 位，所有位都为 0。如下：

```java
-10 >> 31: 11111111 11111111 11111111 11111111
10 >> 31: 00000000 00000000 00000000 00000000
```

i << 1，相当于将数据位左移 1 位，最低位补 0，如下：

```java
-10 << 1: 11111111 11111111 11111111 11101100
10 << 1: 00000000 00000000 00000000 00010100
```

我们可以观察到，将 i >> 31 和 i << 1 做异或，最低位恰好变为符号位的值，对于负数，数值位的前导 1 都变成 0；对于正数，前导 0 不变。通过这样一个位操作，统一了正负数的处理，而且性能极佳，妙哉！

## [Simple8b](https://zhida.zhihu.com/search?content_id=238605729&content_type=Article&match_order=1&q=Simple8b&zhida_source=entity)
Simple8b 的思路是将多个小整数打包到 64-bits 中，其中前 4 个 bits 用来表示选择器，选择器的类型决定每个整数占用的 bit 个数，剩下的 60 bits 为数据位，用来存储整数值，如下：

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/jpeg/49518801/1755668330146-413fbc57-ba5c-4dbb-8d48-7251c05b4c06.jpg.jpeg)

截图来源于 influx 代码注释。第一行代表 Selector，从 0 到 15 一共 16 种选择器。第二行代表整数值占用的 bit 数，每种选择器对应于一个 bits 值。第三行代表 64-bits 能够存储的整数个数，最后一行代表 64-bits 中浪费的 bits（注意，Selector 6 对应的 Wasted Bits 不对，应该为 0）。

这里说明下，前两种 Selector 比较特殊，Selector 0 表示存储有 240 个整数 1，Selector 2 表示存储有 120 个整数 1。但是这两种 Selector 的数据位都不存储实际值，即浪费 bits 数为 60。

Simple8b 往往比 VInt 能取得更好的压缩率，特别适合编码小整数序列。

## [Gorilla 压缩算法](https://zhida.zhihu.com/search?content_id=238605729&content_type=Article&match_order=1&q=Gorilla+%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95&zhida_source=entity)
时间戳一般使用 long 表示，指标值一般使用 double 表示，都占用 8 字节。在时序数据中，时间戳和指标值占了存储的大头，因此，对它们的编码显得极其重要。Gorilla 针对时间戳和指标值使用了不同的压缩算法，时间戳使用的是 [Delta-of-Delta 编码](https://zhida.zhihu.com/search?content_id=238605729&content_type=Article&match_order=1&q=Delta-of-Delta+%E7%BC%96%E7%A0%81&zhida_source=entity)，指标值使用的是 XOR (异或) 编码。

### Delta 
在了解 Delta-of-Delta 编码前，我们先来看看 Delta 编码。Delta 编码主要是针对整数序列的编码方式，除了第一个数之外，其他数都编码成差值，进而降低数值的大小，利于进一步编码压缩。

Delta 编码有两种计算方式： 

1. delta(n)=tn−t0delta(n) = t_n-t_0
2. delta(n)=tn−tn−1delta(n) = t_n-t_{n-1} 。

第一种的优势是还原 tnt_n 时，只需 t0+delta(n)t_0 + delta(n) 即可；第二种的优势是在排序序列场景下，差值更小，存储开销更低。

### Delta-of-Delta 编码
了解完 Delta 编码后，再来看 Delta-of-Delta 编码就更容易了，Delta-of-Delta 其实就是在 Delta 的基础上再做一次 Delta，将数值变得更小。我们来看看 Gorilla 是如何利用 Delta-of-Delta 来对时间戳编码的。

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/jpeg/49518801/1755668330447-491d3cb7-445d-4236-b8be-2e6780c6f9a9.jpg.jpeg)

Gorilla 压缩编码

如上图，Header 占 64 位，保存 Block 的起始时间戳，接下来的 14 位保存第一个时间戳和起始时间戳的差值，意味着一个 Block 的时间窗口为 4 小时，接着对于后面的时间戳则采用 Delta-of-Delta 编码，编码存储方式如下：

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/jpeg/49518801/1755668330296-2a02ff84-bb16-40a8-9f17-88e192629382.jpg.jpeg)

+ 首先通过 Delta-of-Delta 得到差值 DD
+ 如果 DD 为 0，则仅需一个 bit 存储 0 即可
+ 如果 DD 的值域为 [−63,64][-63, 64] ，则存储标记位 10，随后使用 7 位存储数值，共使用 9 位
+ 如果 DD 的值域为 [−255,256][-255, 256] ，则存储标记位 110，随后使用 9 位存储数值，共使用 12 位
+ 如果 DD 的值域为 [−2047,2048][-2047, 2048] ，则存储标记位 1110，随后使用 12 位存储数值，共使用 16 位
+ 如果 DD 的值域为其他，则存储标记位 1111，随后使用 32 位存储数值，共使用 36 位

如果大部分时候，值域都比较小，那么存储成本会极大降低。Gorilla 论文中给出了 440000 个采样数据中 DD 的值域分布：

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/jpeg/49518801/1755668330463-bc7dd3fd-3123-488c-9646-279a5ac2c08e.jpg.jpeg)

可以看到，值域为 0 的情况占了 90% 以上，值域较大的占比微乎其微。也就是说，使用 Delta-of-Delta 可以极大地压缩存储空间。

### XOR
指标值使用双精度浮点数表示，在计算机中浮点数按照 [IEEE 754](https://zhida.zhihu.com/search?content_id=238605729&content_type=Article&match_order=1&q=IEEE+754&zhida_source=entity) 标准编码，如下：

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/49518801/1755668330200-a7b727c9-bcab-429e-ae94-5a635fa69e02.png)

IEEE754-64位浮点数

论文中有这么一句话 :

> "From analyzing our ODS data, we discovered that the value in most time series does not change significantly when compared to its neighboring data points"
>

也就是说，在大部分时候，相邻数据点的指标值变化很小，也就意味着 IEEE 754 标准编码后的二进制中的位大部分相同。<font style="background-color:#FBDE28;">那么经过 XOR 处理后，会出现大量前导 0 和后导 0，存储时只需记录前导 0 数量、有效位数量、有效位值即可。</font>

按照 Gorilla 论文中描述的处理步骤如下：

1. 存储第一个值的原始值
2. 后面的值都和前一个值求异或（XOR），如果结果为 0，用一个位存储 '0' 即可
3. 如果异或的结果不为 0，分两种情况：
    1. a) 如果异或结果和前一个异或结果的前导 0 和后导 0 数量相同，那么存储标记位 10，并存储有效数据
    2. b) 否则存储标记位 11，并用 5 位存储前导 0 的数量，用 6 位存储有效数据的位数，最后存储有效数据

如下：

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/jpeg/49518801/1755668330654-bad3eaaa-6c59-47cc-bcfa-8dc24c5a728d.jpg.jpeg)

指标数值有双精度表示，经过 XOR 处理后，大部分情况下可以共享前导 0 和后导 0（即情形 a），存储空间进一步减少。

## 总结
成本是时序数据库重点考虑的指标，那么根据时序数据的特点选取合适的压缩算法显得极其重要。本文介绍的几种压缩编码算法是时序数据库常用的方法，掌握它们对分析各类时序数据库的存储成本或者自己开发存储引擎有很大的参考价值。

## Reference
[https://www.vldb.org/pvldb/vol8/p1816-teller.pdf](https://www.vldb.org/pvldb/vol8/p1816-teller.pdf)



> 来自: [时序数据常用压缩算法 - 知乎](https://zhuanlan.zhihu.com/p/677140040)
>





