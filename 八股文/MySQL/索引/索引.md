## 索引
### 35.为什么使用索引会加快查询？
数据库文件是存储在磁盘上的，磁盘 I/O 是数据库操作中最耗时的部分之一。没有索引时，数据库会进行全表扫描（Sequential Scan），这意味着它必须读取表中的每一行数据来查找匹配的行（时间效率为 O(n)）。当表的数据量非常大时，就会导致大量的磁盘 I/O 操作。
有了索引，就可以直接跳到索引指示的数据位置，而不必扫描整张表，从而大大减少了磁盘 I/O 操作的次数。
MySQL 的 InnoDB 存储引擎默认使用 B+ 树来作为索引的数据结构，而 B+ 树的查询效率非常高，时间复杂度为 O(logN)。
索引文件相较于数据库文件，体积小得多，查到索引之后再映射到数据库记录，查询效率就会高很多。
索引就好像书的目录，通过目录去查找对应的章节内容会比一页一页的翻书快很多。
![image.png](./索引.assert/1747623656391-47f84c57-3246-468a-a0d1-04834699e992.png)

可通过 `create index` 创建索引，比如：

```sql
create index idx_name on students(name);
```
#### 索引优化举例？
在实际开发中，我们可以通过合理使用单字段索引、复合索引和覆盖索引来优化查询。例如，如果要加速查询 age 字段的条件，我们可以在 age 字段上创建索引。

```sql
CREATE INDEX idx_age ON users(age);
```
如果查询涉及多个字段 age 和 name，可以使用复合索引来提高查询效率。

```sql
CREATE INDEX idx_age_name ON users(age, name);
```
当我们只需要查询部分字段时 `SELECT name FROM users WHERE age = 30;`，覆盖索引可以提升查询效率。

```sql
CREATE INDEX idx_age_name ON users(age, name);
```
由于 age 和 name 字段都在索引中，MySQL 直接从索引中获取结果，无需回表查找。
### 36.能简单说一下索引的分类吗？
MySQL 的索引可以显著提高查询的性能，可以从三个不同的维度对索引进行分类（功能、数据结构、存储位置）：
![image.png](./索引.assert/1747623657934-b7457c69-f8f4-4d7a-adb3-cac2dfa52648.png)

#### 01、说说从功能上的分类？
①、**主键索引**: 表中每行数据唯一标识的索引，强调列值的唯一性和非空性。
当创建表的时候，可以直接指定主键索引：

```sql
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(255) NOT NULL,
    email VARCHAR(255)
);
```
id 列被指定为主键索引，同时，MySQL 会自动为这个列创建一个聚簇索引（主键索引一定是聚簇索引）。
可以通过 `show index from table_name` 查看索引信息，比如前面创建的 users 表：
![image.png](./索引.assert/1747623657842-27cd6055-4537-4566-877d-5e8311ec60f6.png)


- `Non_unique` 如果索引不能包含重复词，则为 0；如果可以，则为 1。这可以帮助我们区分是唯一索引还是普通索引。
- `Key_name` 索引的名称。如果索引是主键，那么这个值是 PRIMARY。
- `Column_name` 索引所包含的字段名。
- `Index_type` 索引的类型，比如 BTREE、HASH 等。②、**唯一索引**: 保证数据列中每行数据的唯一性，但允许有空值。
可以通过下面的语句创建唯一索引：

```sql
CREATE UNIQUE INDEX idx_username ON users(username);
```
同样可以通过 `show index from table_name` 确认索引信息：
![image.png](./索引.assert/1747623657966-ec49f6d5-6378-46c8-9d85-a9be89a3acaa.png)

`Non_unique` 为 0，表示这是一个唯一索引。
③、**普通索引**: 基本的索引类型，用于加速查询。
可以通过下面的语句创建普通索引：

```sql
CREATE INDEX idx_email ON users(email);
```
这次我们通过下面的语句一起把三个索引的关键信息查出来：

```sql
SELECT `TABLE_NAME` AS `Table`, `NON_UNIQUE`, `INDEX_NAME` AS `Key_name`, `COLUMN_NAME` AS `Column_name`, `INDEX_TYPE` AS `Index_type`
FROM information_schema.statistics
WHERE `TABLE_NAME` = 'users' AND `TABLE_SCHEMA` = DATABASE();
```
![image.png](./索引.assert/1747623657880-e2bc1b9b-bd9a-413c-98e5-5d097fb4a49c.png)

可以确定 idx_email 是一个普通索引，因为 `Non_unique` 为 1。
④、**全文索引**：特定于文本数据的索引，用于提高文本搜索的效率。
假设有一个名为 articles 的表，下面这条语句在 content 列上创建了一个全文索引。

```sql
CREATE FULLTEXT INDEX idx_article_content ON articles(content);
```
#### 02、说说从数据结构上分类？
①、B+树索引：最常见的索引类型，一种将索引值按照一定的算法，存入一个树形的数据结构中（二叉树），每次查询都从树的根节点开始，一次遍历叶子节点，找到对应的值。查询效率是 O(logN)。
也是 **InnoDB 存储引擎的默认索引类型**。
B+ 树是 B 树的升级版，B+ 树中的非叶子节点都不存储数据，只存储索引。叶子节点中存储了所有的数据，并且构成了一个从小到大的有序双向链表，使得在完成一次树的遍历定位到范围查询的起点后，可以直接通过叶子节点间的指针顺序访问整个查询范围内的所有记录，而无需对树进行多次遍历。这在处理大范围的查询时特别高效。
![image.png](./索引.assert/1747623657923-93f29315-0935-49bf-8274-7629ef0ca95b.png)

因为 B+ 树是 InnoDB 的默认索引类型，所以创建 B+ 树的时候不需要指定索引类型。

```sql
CREATE TABLE example_btree (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(255),
    INDEX name_index (name)
) ENGINE=InnoDB;
```
②、Hash 索引：基于哈希表的索引，查询效率可以达到 O(1)。
Hash 索引在原理上和 Java 中的 [HashMap](https://javabetter.cn/collection/hashmap.html) 类似，当发生哈希冲突的时候也是通过拉链法来解决。
![image.png](./索引.assert/1747623658420-9e9ef03f-7bb1-4c3e-95f8-4956b137b673.png)

可以通过下面的语句创建哈希索引：

```sql
CREATE TABLE example_hash (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(255),
    UNIQUE HASH (name)
) ENGINE=MEMORY;
```
注意，我们这里创建的是 MEMORY 存储引擎，InnoDB 并不提供直接创建哈希索引的选项，因为 B+ 树索引能够很好地支持范围查询和等值查询，满足了大多数数据库操作的需要。
不过，InnoDB 存储引擎内部使用了一种名为“自适应哈希索引”（Adaptive Hash Index, AHI）的技术。
自适应哈希索引并不是由用户显式创建的，而是 InnoDB 根据数据访问的模式自动建立和管理的。当 InnoDB 发现某个索引被频繁访问时，会在内存中创建一个哈希索引，以加速对这个索引的访问。
可以通过下面的语句查看自适应哈希索引的状态：

```sql
SHOW VARIABLES LIKE 'innodb_adaptive_hash_index';
```
如果返回的值是 ON，说明自适应哈希索引是开启的。
![image.png](./索引.assert/1747623658460-32d14199-6f23-47d5-8e98-5c3ee64bb28e.png)

#### 03、说说从存储位置上分类：
①、聚簇索引：聚簇索引的叶子节点保存了一行记录的所有列信息。也就是说，聚簇索引的叶子节点中，包含了一个完整的记录行。
![image.png](./索引.assert/1747623658441-83518b76-d30d-4b7a-8e26-239bfd36919c.png)

②、非聚簇索引：它的叶子节点只包含一个主键值，通过非聚簇索引查找记录要先找到主键，然后通过主键再到聚簇索引中找到对应的记录行，这个过程被称为回表。
![image.png](./索引.assert/1747623658622-110294fa-4b96-4cf4-8f87-11aa5e89b479.png)

InnoDB 存储引擎的主键使用的是聚簇索引，MyISAM 存储引擎不管是主键索引，还是二级索引使用的都是非聚簇索引。
### 37.创建索引有哪些注意点？
①、选择合适的列作为索引

- 经常作为查询条件（WHERE 子句）、排序条件（ORDER BY 子句）、分组条件（GROUP BY 子句）的列是建立索引的好选项。
- 区分度低的字段，例如性别，不要建索引
- 频繁更新的字段，不要建索引②、避免过多的索引

- 因为每个索引都需要占用额外的磁盘空间。
- 更新表（INSERT、UPDATE、DELETE 操作）的时候，索引都需要被更新。③、利用前缀索引和索引列的顺序

- 对于字符串类型的列，可以考虑使用前缀索引来减少索引大小。
- 在创建联合索引时，应该根据查询条件将最常用的放在前面，遵守最左前缀原则。> ### 38.索引哪些情况下会失效呢？

- **在索引列上使用函数或表达式**：索引可能无法使用，因为 MySQL 无法预先计算出函数或表达式的结果。例如：`SELECT * FROM table WHERE YEAR(date_column) = 2021`。
- 使用不等于（`<>`）或者 NOT 操作符：因为它们会扫描全表。
- **使用 LIKE 语句，但通配符在前面**：以“%”或者“_”开头，索引也无法使用。例如：`SELECT * FROM table WHERE column LIKE '%abc'`。
- 联合索引，但 WHERE 不满足最左前缀原则，索引无法起效。例如：`SELECT * FROM table WHERE column2 = 2`，联合索引为 `(column1, column2)`。
### 39.索引不适合哪些场景呢？

- **数据表较小**：当表中的数据量很小，或者查询需要扫描表中大部分数据时，数据库优化器可能会选择全表扫描而不是使用索引。在这种情况下，维护索引的开销可能大于其带来的性能提升。
- **频繁更新的列**：对于经常进行更新、删除或插入操作的列，使用索引可能会导致性能下降。因为每次数据变更时，索引也需要更新，这会增加额外的写操作负担。#### 性别字段要建立索引吗？
性别字段通常不适合建立索引。因为性别字段的选择性（区分度）较低，独立索引效果有限。
如果性别字段又很少用于查询，表的数据规模较小，那么建立索引反而会增加额外的存储空间和维护成本。
如果性别字段确实经常用于查询条件，数据规模也比较大，可以将性别字段作为复合索引的一部分，与选择性较高的字段一起加索引，会更好一些。
#### 什么是区分度？
区分度（Selectivity）是衡量一个字段在数据库表中唯一值的比例，用来表示该字段在索引优化中的有效性。
区分度 = 字段的唯一值数量 / 字段的总记录数；接近 1，字段值大部分是唯一的。例如，用户的唯一 ID，一般都是主键索引。接近 0，则说明字段值重复度高。
例如，一个表中有 1000 条记录，其中性别字段只有两个值（男、女），那么性别字段的区分度只有 0.002。
高区分度的字段更适合拿来作为索引，因为索引可以更有效地缩小查询范围。
#### MySQL查看字段区分度的命令？
在 MySQL 中，可以通过 `COUNT(DISTINCT column_name)` 和 `COUNT(*)` 的比值来计算字段的区分度。例如：

```sql
SELECT 
    COUNT(DISTINCT gender) / COUNT(*) AS gender_selectivity
FROM 
    users;
```
#### 什么样的字段适合加索引？什么不适合？
适合加索引的字段包括：

- 经常出现在 WHERE 子句中的字段，如 `SELECT * FROM users WHERE age = 30` 中的 age 字段，加上索引后可以快速定位到满足条件的记录。
- 经常用于 JOIN 的字段，如 `SELECT * FROM users u JOIN orders o ON u.id = o.user_id` 中的 user_id 字段，加上索引后可以避免多表扫描。
- 经常出现在 ORDER BY 或 GROUP BY 子句中的字段，如 `SELECT * FROM users ORDER BY age` 中的 age 字段。加上索引后可以避免额外的排序操作。
- 高区分度的字段，查询时可以有效减少返回的数据行，比如用户 ID、邮箱等。对应的，不适合加索引的字段包括：

- 低区分度字段，如性别、状态等。
- 经常更新的字段，如用户的登录时间、登录次数等。
- 不经常出现在查询条件中的字段，如用户的生日、地址等。
- 使用函数、运算符的字段。### 40.索引是不是建的越多越好？
当然不是。

- **索引会占据磁盘空间**
- **索引虽然会提高查询效率，但是会降低更新表的效率**。每次对表进行增删改操作，MySQL 不仅要更新数据，还要更新对应的索引文件。#### 说说索引优化的思路？
①、选择合适的索引类型

- 如果需要等值查询和范围查询，请选择 B+树索引。
- 如果是用于处理文本数据的全文搜索，请选择全文索引。②、创建适当的索引

- 创建组合索引时，应将查询中最常用、区分度高的列放在前面。对于查询条件 `WHERE age = 18 AND gender = '女' AND city = '洛阳'`，如果 age 列的值相对较为分散，可以优先考虑将 age 放在组合索引的第一位。
- 使用 SELECT 语句时，尽量选择覆盖索引来避免不必要的回表操作，也就是说，索引中包含了查询所需的所有列；但要注意，覆盖索引的列数不宜过多，否则会增加索引的存储空间。### 41.为什么 InnoDB 要使用 B+树作为索引？
MySQL 的默认存储引擎是 InnoDB，它采用的是 B+树索引，是 B 树的升级版。
B 树是一种自平衡的多路查找树，和红黑树、二叉平衡树不同，B 树的每个节点可以有 m 个子节点，而红黑树和二叉平衡树都只有 2 个。
换句话说，红黑树、二叉平衡树是细高个，而 B 树是矮胖子。
![image.png](./索引.assert/1747623658521-095fbbfb-9ffc-4189-96c1-52b8479f5718.png)

内存和磁盘在进行 IO 读写的时候，有一个最小的逻辑单元，叫做页（Page），页的大小一般是 4KB。
![image.png](./索引.assert/1747623658871-ce4b3cf2-0cd7-484a-bf03-bff8584840df.png)

那为了提高读写效率，从磁盘往内存中读数据的时候，一次会读取至少一页的数据，比如说读取 2KB 的数据，实际上会读取 4KB 的数据；读取 5KB 的数据，实际上会读取 8KB 的数据。**我们要尽量减少读写的次数**。
因为读的次数越多，效率就越低。就好比我们在工地上搬砖，一次搬 10 块砖肯定比一次搬 1 块砖的效率要高，反正我每次都搬 10 块（😁）。
对于红黑树、二叉平衡树这种细高个来说，每次搬的砖少，因为力气不够嘛，那来回跑的次数就越多。
树越高，意味着查找数据时就需要更多的磁盘 IO，因为每一层都可能需要从磁盘加载新的节点。
![image.png](./索引.assert/1747623659017-e65a4483-f786-42df-8459-c6aa67d30510.png)

B 树的节点大小通常与页的大小对齐，这样每次从磁盘加载一个节点时，可以正好是一个页的大小。因为 B 树的节点可以有多个子节点，可以填充更多的信息以达到一页的大小。
![image.png](./索引.assert/1747623659261-addeec14-d4d5-4e98-b1a8-bac20dfed1d0.png)

B 树的一个节点通常包括三个部分：

- 键值：即表中的主键
- 指针：存储子节点的信息
- 数据：表记录中除主键外的数据不过，正所谓“祸兮福所倚，福兮祸所伏”，正是因为 B 树的每个节点上都存了数据，就导致每个节点能存储的键值和指针变少了，因为每一页的大小是固定的，对吧？
于是 B+树就来了，B+树的非叶子节点只存储键值，不存储数据，而叶子节点存储了所有的数据，并且构成了一个有序链表。
![image.png](./索引.assert/1747623659546-cd6c1f7d-90ae-4f1c-8cb8-3ddd6bf68c80.png)

这样做的好处是，非叶子节点上由于没有存储数据，就可以存储更多的键值对，树就变得更加矮胖了，于是就更有劲了，每次搬的砖也就更多了（😂）。
由此一来，查找数据进行的磁盘 IO 就更少了，查询的效率也就更高了。
再加上叶子节点构成了一个有序链表，范围查询时就可以直接通过叶子节点间的指针顺序访问整个查询范围内的所有记录，而无需对树进行多次遍历。
**注**：在 InnoDB 存储引擎中，默认的页大小是 16KB。可以通过 `show variables like 'innodb_page_size';` 查看。
![image.png](./索引.assert/1747623659066-e06f79c3-f48a-4816-ae5c-aced97a10a35.png)

#### 简版回答：
MySQL 的默认存储引擎是 InnoDB，它采用的是 B+树索引，B+树是一种自平衡的多路查找树，和红黑树、二叉平衡树不同，B+树的每个节点可以有 m 个子节点，而红黑树和二叉平衡树都只有 2 个。
![image.png](./索引.assert/1747623659782-5b8a193a-21df-4192-a4aa-4e2659a7a8fb.png)

和 B 树不同，B+树的非叶子节点只存储键值，不存储数据，而叶子节点存储了所有的数据，并且构成了一个有序链表。
这样做的好处是，非叶子节点上由于没有存储数据，就可以存储更多的键值对，再加上叶子节点构成了一个有序链表，范围查询时就可以直接通过叶子节点间的指针顺序访问整个查询范围内的所有记录，而无需对树进行多次遍历。查询的效率会更高。
#### B+树的页是单向链表还是双向链表？如果从大值向小值检索，如何操作？
B+树的叶子节点是通过双向链表连接的，这样可以方便范围查询和反向遍历。

- 当执行范围查询时，可以从范围的开始点或结束点开始，向前或向后遍历，这使得查询更为灵活。
- 在需要对数据进行逆序处理时，双向链表非常有用。如果需要在 B+树中从大值向小值进行检索，可以按以下步骤操作：

- 定位到最右侧节点：首先，找到包含最大值的叶子节点。这通常通过从根节点开始向右遍历树的方式实现。
- 反向遍历：一旦定位到了最右侧的叶子节点，可以利用叶节点间的双向链表向左遍历。#### 为什么 MongoDB 索引用 B树，而 MySQL 用 B+ 树？
推荐阅读：[为什么 MongoDB 索引用 B树，而 MySQL 用 B+ 树？](https://www.cnblogs.com/rjzheng/p/12316685.html)
B树的特点是每个节点都存储数据，相邻的叶子节点之间没有指针链接。
![image.png](./索引.assert/1747623660064-e59143cf-144d-4ce2-b365-da024736b8e8.png)

B+树的特点是非叶子节点只存储索引，叶子节点存储数据，并且相邻的叶子节点之间有指针链接。
![image.png](./索引.assert/1747623659969-4b9cb240-c27f-4ea1-9346-462639e47f93.png)

那么在查找单条数据时，B 树的查询效率可能会更高，因为每个节点都存储数据，所以最好情况就是 O(1)。
但由于 B 树的节点之间没有指针链接，所以并不适合做范围查询，因为范围查询需要遍历多个节点。
而 B+ 树的叶子节点之间有指针链接，所以适合做范围查询，因为可以直接通过叶子节点间的指针顺序访问整个查询范围内的所有记录，而无需对树进行多次遍历。
MySQL 属于关系型数据库，所以范围查询会比较多，所以采用了 B+树；但 MongoDB 属于非关系型数据库，在大多数情况下，只需要查询单条数据，所以 MongoDB 选择了 B 树。
### 42.一棵 B+树能存储多少条数据呢？
推荐阅读：[清幽之地：InnoDB 一棵 B+树可以存放多少行数据？](https://juejin.cn/post/6904293886626103309)
![image.png](./索引.assert/1747623659780-a4aca327-f3e2-4cb1-bae2-c8be9b3fb75d.png)

假如我们的主键 ID 是 bigint 类型，长度为 8 个字节。指针大小在 InnoDB 源码中设置为 6 字节，这样一共 14 字节。所以非叶子节点(一页16k)可以存储 16384/14=1170 个这样的单元(键值+指针)。
一个指针指向一个存放记录的页，一页可以放 16 条数据，树深度为 2 的时候，可以存放 1170*16=**18720** 条数据。
同理，树深度为 3 的时候，可以存储的数据为 1170*1170*16=**21902400**条记录。
理论上，在 InnoDB 存储引擎中，B+树的高度一般为 2-4 层，就可以满足千万级数据的存储。查找数据的时候，一次页的查找代表一次 IO，当我们通过主键索引查询的时候，最多只需要 2-4 次 IO 就可以了。
#### innodb 使用数据页存储数据？默认数据页大小 16K，我现在有一张表，有 2kw 数据，我这个 b+树的高度有几层？
推荐阅读：[Innodb 引擎中 B+树一般有几层？能容纳多少数据量？](https://www.cnblogs.com/yifanSJ/p/17662132.html)
在 MySQL 中，InnoDB 存储引擎的最小存储单元是页，默认大小是 16k。页可以用来存储 B+树叶子节点上的数据，也可以存放非叶子节点上的键值对。
在查找数据时，一次页的查找代表一次 IO，一般 B+树的高度为 2-4 层，所以通过主键索引查询时，最多只需要 2-4 次 IO 就可以了。
已知非叶子节点可以存储 1170 个键值对。
> 主键 ID 是 bigint 类型，长度为 8 个字节。指针大小在 InnoDB 源码中设置为 6 字节，这样一共是 14 字节。所以非叶子节点（一页）可以存储 16384/14=1170 个这样的单元(键值+指针)。

假设一行数据的大小为 1KB，那么一页的叶子节点就可以存储 16 条数据。对于 3 层的 B+树，第一层叶子节点数*第二层叶子节点数*一页能够存储的数据量 = 1170*1170*16 = 21902400 条数据。
![image.png](./索引.assert/1747623660085-9106d972-ec88-4368-8e87-70888d2e85c8.png)

如果有 2KW 条数据，那么这颗 B+树的高度为 3 层。
#### 每个叶子节点能存放多少条数据？
B+ 树索引的每个叶子节点对应一个数据页，默认大小为 16KB。假设一条数据的大小为 1k，那么每个叶子节点可以存放 16 条数据。
### 43.为什么不用普通二叉树？
普通二叉树存在退化的情况，如果它退化成链表，就相当于全表扫描。
![image.png](./索引.assert/1747623660301-3f3322ac-fc88-4fbe-a9ec-17b43c0a76a3.png)

#### 为什么不用平衡二叉树呢？
虽然 AVL 树是平衡二叉树，但因为只有 2 叉，高度会比较高，磁盘 I/O 次数就会非常多。
![image.png](./索引.assert/1747623660215-ed89019b-011a-4fff-af30-a6ddb0df059f.png)

而 B+ 树是 N 叉，每一层可以存储更多的节点数据，树的高度就会降低，因此读取磁盘的次数就会下降，查询效率就快。
> 
1. [Java 面试指南（付费）](https://javabetter.cn/zhishixingqiu/mianshi.html)收录的百度面经同学 1 文心一言 25 实习 Java 后端面试原题：MySQL 索引为什么使用 B+树而不是用别的数据结构？
2. [Java 面试指南（付费）](https://javabetter.cn/zhishixingqiu/mianshi.html)收录的腾讯面经同学 27 云后台技术一面面试原题：为什么不用二叉树？为什么不用AVL树？
### 44.为什么用 B+ 树而不用 B 树呢？
B+ 树相比 B 树有 2 个显著优势：
首先，B+ 树的非叶子节点不存储数据，能包含更多的键值指针，因此在相同节点容量下，B+ 树的层级更少，树的高度更低。较少的树层级意味着查找路径更短，磁盘 I/O 次数更少。
![image.png](./索引.assert/1747623660654-9857679f-2be3-46f5-a832-2fda5121351b.png)

其次，B+ 树的叶子节点通过链表相连，非常适合范围查询，如 ORDER BY 和 BETWEEN。
![image.png](./索引.assert/1747623661143-a68296f1-acff-4135-8ff7-de4df8c416df.png)

只需要找到符合条件的第一个叶子节点，顺序扫描后续的叶子节点就可以了。相比之下，B 树的每次范围查询都需要回溯到父节点，查询效率较低。
#### B+树的时间复杂度是多少？
树的高度 h 为：
h = \lceil \log_m N \rceil
![数学公式](./索引.assert/6e53597785443a7d99b734108555dcae.svg)

其中 N 是数据总量，m 是阶数。每层需要做一次二分查找，复杂度为 O(\log m)
![数学公式](./索引.assert/6278ca63addd291c69774d99c6a834a0.svg)
。
总复杂度为：
O(\log_m N \cdot \log m) = O(\log N)
![数学公式](./索引.assert/e4b3aac4f2269e94bd1809193e287ad3.svg)

#### 了解快排吗？
推荐链接：[快速排序](https://oi-wiki.org/basic/quick-sort/)
快速排序是一种基于分治法的高效排序算法。其核心思想是：

1. 选择一个基准值。
2. 将数组分为两部分，左边小于基准值，右边大于或等于基准值。
3. 对左右两部分递归排序，最终合并。#### 为什么用 B+树不用跳表呢？

- 跳表基于链表，节点分布不连续，会频繁触发随机磁盘访问，性能较差。
- 跳表需要逐节点遍历链表，范围查询性能不如 B+ 树。> #### B+树的范围查找怎么做的？
B+ 树索引的范围查找主要依赖叶子节点之间的双向链表来完成。
第一步，从 B+ 树的根节点开始，通过索引键值逐层向下，找到第一个满足条件的叶子节点。
第二步，利用叶子节点之间的双向链表，从起始节点开始，依次向后遍历每个节点。当索引值超过查询范围，或者遍历到链表末尾时，终止查询。
比如说在下面这棵 B+ 树上查找 45。

![image.png](./索引.assert/1747623660990-f75cc59b-b0b3-4c43-a254-1539a8c2562c.png)

第一步，从根节点开始，因为比 25 大，所以从右子树开始。因为 45 比 35大，所以和右边的索引比较，右侧的索引也是 45，所以继续往右子树查找。
![image.png](./索引.assert/1747623661062-8275adb0-f5e8-4cd2-83ab-bdfd9d11f2d9.png)

第二步，从叶子节点 45 开始，依次遍历，找到 45。
![image.png](./索引.assert/1747623661007-7cd10fc7-1f0e-4333-b124-4d135ec7c2cd.png)

### 45.Hash 索引和 B+ 树索引区别是什么？

- B+ 树索引可以进行范围查询，Hash 索引不能。
- B+ 树索引支持联合索引的最左侧原则，Hash 索引不支持。
- B+ 树索引支持 order by 排序，Hash 索引不支持。
- Hash 索引在等值查询上比 B+ 树索引效率更高。
- B+ 树使用 like 进行模糊查询的时候，`LIKE 'abc%'` 的话可以起到索引优化的作用，Hash 索引无法进行模糊查询。#### MySQL 模糊查询怎么查，什么情况下模糊查询不走索引？
MySQL 中进行模糊查询主要使用 LIKE 语句，结合通配符 %（代表任意多个字符）和 _（代表单个字符）来实现。

```sql
SELECT * FROM table WHERE column LIKE '%xxx%';
```
这个查询会返回所有 column 列中包含 xxx 的记录。
但是，如果模糊查询的通配符 % 出现在搜索字符串的开始位置，如 `LIKE '%xxx'`，MySQL 将无法使用索引，因为数据库必须扫描全表以匹配任意位置的字符串。
### 46.聚簇索引与非聚簇索引的区别？
MySQL 默认的存储引擎是 InnoDB，InnoDB 的索引是按照 B+ 树结构存储的，不同类型的索引有不同的存储方式。
主键索引是按照聚簇索引的方式存储的，也就是说，主键索引的叶子节点存储的是整行数据，数据和索引在同一个 B+ 树中。
普通索引、唯一索引是按照非聚簇索引的方式存储的，每个辅助索引都是独立的 B+ 树，叶子节点存储的是主键值，通过主键值回到主键索引中查找完整的数据，俗称回表。
![image.png](./索引.assert/1747623661083-651deb42-88a1-4ffb-9e92-f27b190791f0.png)

每个表只能有一个聚簇索引；但可以有多个非聚簇索引。
举例来说：

- InnoDB 采用的是聚簇索引，如果没有显式定义主键，InnoDB 会选择一个唯一的非空列作为隐式的聚簇索引；如果这样的列也不存在，InnoDB 会自动生成一个隐藏的行 ID 作为聚簇索引。这意味着数据与主键是紧密绑定的，行数据直接存储在索引的叶子节点上。
- MyISAM 采用的是非聚簇索引，表数据存储在一个地方，而索引存储在另一个地方，索引指向数据行的物理位置。### 47.回表了解吗？
回表是指在数据库查询过程中，通过非聚簇索引（secondary index）查找到记录的主键值后，再根据这个主键值到聚簇索引（clustered index）中查找完整记录的过程。
回表操作通常发生在使用非聚簇索引进行查询，但查询的字段不全在该索引中，必须通过主键进行再次查询以获取完整数据。
换句话说，数据库需要先查找索引，然后再根据索引回到数据表中去查找实际的数据。
因此，使用非聚簇索引查找数据通常比使用聚簇索引要慢，因为需要进行两次磁盘访问。当然，如果索引所在的数据页已经被加载到内存中，那么非聚簇索引的查找速度也可以非常快。
例如：`select * from user where name = '张三';`，会先从辅助索引中找到 name='张三' 的主键 ID，然后再根据主键 ID 从主键索引中找到对应的数据行。
![image.png](./索引.assert/1747623661528-623ec082-ece2-4b2b-a295-ff962c830be0.png)

假设现在有一张用户表 users：

```sql
CREATE TABLE users (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    age INT,
    email VARCHAR(50),
    INDEX (name)
);
```
执行查询：

```sql
SELECT * FROM users WHERE name = '张三';
```
查询过程如下：

- MySQL 使用 name 列上的非聚簇索引查找到所有 `name = '张三'` 的记录，得到对应的主键 id。
- 使用主键 id 到聚簇索引中查找完整记录。#### 回表记录越多好吗？
回表记录越多并不是一件好事。事实上，回表的代价是很高的，尤其在记录较多时，回表操作会显著影响查询性能。
因为每次回表操作都需要进行一次磁盘 I/O 读取操作。如果回表记录很多，会导致大量的磁盘 I/O。
索引覆盖（Covering Index）可以减少回表操作，将查询的字段都放在索引中，这样不需要回表就可以获取到查询结果了。
### 48.联合索引了解吗？（补充）
> 2024 年 11 月 22 日增补

联合索引指的是一个索引包含多个列。联合索引的创建语法如下：

```sql
CREATE INDEX index_name ON table_name (column1, column2, ...);
```
#### 联合索引底层的存储结构是怎样的？
在 MySQL 中，联合索引的底层存储结构是 B+ 树。B+ 树是一种多路搜索树，它的每个节点最多包含 M 个子节点，其中 M 是一个正整数。
![image.png](./索引.assert/1747623661737-81e3dd13-1aa4-41c7-b4b1-43f5f4dbb0a9.png)

#### 联合索引的叶子节点存的什么内容?
比如说有这样一个联合索引 idx_c2_c3（c2 和 c3 列，主键是 c1），那么叶子节点存储的是 c2、c3 索引列的值和c1 主键列的值。这样，当查询时，可以先通过联合索引找到对应的主键值，然后再通过主键值找到完整的数据行。
![image.png](./索引.assert/1747623661931-60d89bd0-3e98-4cc7-b8a5-01ca426bc10c.png)

> 
1. [Java 面试指南（付费）](https://javabetter.cn/zhishixingqiu/mianshi.html)收录的百度同学 4 面试原题：联合索引底层存储结构(和其他种类的索引存储结构有什么区别?)联合索引的叶子节点存的什么内容?
### 49.覆盖索引了解吗？
覆盖索引（Covering Index）指的是一种索引能够“覆盖”查询中所涉及的所有列，换句话说，查询所需的数据全部都可以从索引中直接获取，而无需访问数据表的行数据（也就是无需回表）。
通常情况下，索引中只包含表的某些字段，数据库在通过索引查找到满足条件的记录后，还需要回到表中获取其它字段的数据，这个过程叫做“回表”。
假设有一张用户表 users，包含以下字段：id、name、email、age。执行下面的查询：

```sql
SELECT age, email FROM users WHERE name = "张三";
```
如果在 name 列上创建了索引，但没有在 age 和 email 列上创建索引，那么数据库引擎会：

1. 使用 name 列的索引查找到满足条件的记录的 id。
2. 根据 id 回表查询 age 和 email 字段的数据。如果创建了一个覆盖索引 idx_users_name_email_age 包含 name、email、age 列：

```sql
CREATE INDEX idx_users_name_email_age ON users (age, name, email);
```
那么执行：

```sql
SELECT age, email FROM users WHERE name = "张三";
```
查询时可以直接从索引中获取 age 和 email 的值，而不需要回表。这是因为索引已经覆盖了查询所需的所有字段。
![image.png](./索引.assert/1747623661600-de569c35-0a5c-45e5-93de-f0e05459e14b.png)

> 
1. [Java 面试指南（付费）](https://javabetter.cn/zhishixingqiu/mianshi.html)收录的作业帮面经同学 1 Java 后端一面面试原题：了解覆盖索引吗
2. [Java 面试指南（付费）](https://javabetter.cn/zhishixingqiu/mianshi.html)收录的美团同学 9 一面面试原题：索引覆盖，回表？
### 50.什么是最左前缀原则？
在使用联合索引时，应当遵守最左前缀原则，或者叫最左匹配原则（最左前缀匹配原则）。
它指的是在使用联合索引时，查询条件从索引的最左列开始并且不跳过中间的列。
如果一个复合索引包含`(col1, col2, col3)`，那么它可以支持 `col1`、`col1,col2` 和 `col1, col2, col3` 的查询优化，但不支持只有 col2 或 col3 的查询。
也就说，在进行查询时，如果没有遵循最左前缀，那么联合索引可能不会被利用，导致查询效率降低。
#### 为什么不从最左开始查，就无法匹配呢？
比如有一个 user 表，我们给 name 和 age 建立了一个联合索引 `(name, age)`。

```sql
ALTER TABLE user add INDEX comidx_name_phone (name,age);
```
联合索引在 B+ 树中是复合的数据结构，按照从左到右的顺序依次建立搜索树 (name 在左边，age 在右边)。
![image.png](./索引.assert/1747623661635-598958b6-fd59-4da8-8e3a-482a1668b1c7.png)

注意，name 是有序的，age 是无序的。当 name 相等的时候，age 才有序。
当我们使用 `where name= '张三' and age = '20'` 去查询的时候， B+ 树会优先比较 name 来确定下一步应该搜索的方向，往左还是往右。
如果 name 相同的时候再比较 age。
但如果查询条件没有 name，就不知道应该怎么查了，因为 name 是 B+树中的前置条件，没有 name，索引就派不上用场了。
#### 联合索引 (a, b)，where a = 1 和 where b = 1，效果是一样的吗
不一样。
`WHERE a = 1` 能有效利用联合索引，因为 a 是联合索引的第一个字段，符合最左前缀匹配原则。而 `WHERE b = 1` 无法利用该联合索引，因为缺少 a 的匹配条件，MySQL 会选择全表扫描。
我们来验证一下，假设有一个 ab 表，建立了联合索引 `(a, b)`：

```sql
CREATE TABLE ab (
    a INT,
    b INT,
    INDEX ab_index (a, b)
);
```
插入数据：

```sql
INSERT INTO ab (a, b) VALUES (1, 2), (1, 3), (2, 1), (3, 3), (2, 2);
```
执行查询：
![image.png](./索引.assert/1747623662227-2457f8b9-5228-4ca4-9754-8fee3269fe35.png)

通过 explain 可以看到，`WHERE a = 1` 使用了联合索引，而 `WHERE b = 1` 需要全表扫描，依次检查每一行。
#### （联合索引）下面怎么走的索引？

```sql
select * from t where a = 2 and b = 2;
select * from t where b = 2 and c = 2;
select * from t where a > 2 and b = 2;
```
联合索引在 MySQL 中的行为受最左前缀原则的影响。假设 t 表上有一个联合索引 (a, b, c)，我们来分析一下：
第一条 SQL 语句包含条件 a = 2 和 b = 2，刚好符合联合索引的前两列。
![image.png](./索引.assert/1747623662224-5310dc2a-69a1-42aa-a82c-a539b7cc7cfe.png)

第二条 SQL 语句由于未使用最左前缀中的 a，可能会触发全表扫描。
![image.png](./索引.assert/1747623662214-553b48e4-f4ed-465a-a82f-2dcf3053853f.png)

第三条 SQL 语句在范围条件 a > 2 之后，索引后会停止匹配，b = 2 的条件需要额外过滤。
![image.png](./索引.assert/1747623662209-9659aa8f-7996-4c2c-9595-16788e6ff1c2.png)

#### 联合索引 (a, b, c)，where b = 1，能走吗，where a = 1，能走吗
`WHERE b = 1` 无法利用联合索引，因为缺少 a 的匹配条件，MySQL 会选择全表扫描。
`WHERE a = 1` 能有效利用联合索引，因为 a 是联合索引的第一个字段，符合最左前缀匹配原则。
### 51.什么是索引下推优化？
索引下推`（Index Condition Pushdown (ICP) ）`是 MySQL 5.6 时添加的，它允许在访问索引时对数据进行过滤，从而减少回表的次数。
例如有一张 user 表，建了一个联合索引（name, age），查询语句：`select * from user where name like '张%' and age=10;`，没有索引下推优化的情况下：
MySQL 会先根据 `name like '张%'` 查找条件匹配的数据，对于符合索引条件的每一条记录，都会去访问对应的数据行，并在 Server 层过滤 `age=10` 这个条件。
这样就等于说及时 age 不等于 10，MySQL 也会执行回表操作。
![image.png](./索引.assert/1747623662504-101c48bb-e515-4576-8a59-1b94a593939a.png)

有索引下推的情况下，MySQL 可以在存储引擎层检查 `name like '张%' and age=10` 的条件，而不仅仅是 `name like '张%'`。
![image.png](./索引.assert/1747623662897-e6e2d5e2-51f0-42f3-9719-7e9dc465cde6.png)

这就意味着不符合 age = 10 条件的记录将会在索引扫描时被过滤掉，从而减少了回表的次数。
> 
1. [Java 面试指南（付费）](https://javabetter.cn/zhishixingqiu/mianshi.html)收录的美团同学 9 一面面试原题：索引下推
### 52.如何查看是否用到了索引？（补充）
> 2024 年 03 月 15 日增补。

可以通过 `EXPLAIN` 关键字来查看是否使用了索引。

```sql
EXPLAIN SELECT * FROM table WHERE column = 'value';
```
其结果中的 `key` 值显示了查询是否使用索引，如果使用了索引，会显示索引的名称。比如下面这个截图就表明该查询语句使用了主键索引。
![image.png](./索引.assert/1747623662916-cd90a4b1-af87-4c9b-9551-4db3737b40e2.png)

#### (A,B,C) 联合索引 `select * from tbn where a=? and b in (?,?) and c>?` 会走索引吗？
> 2024 年 03 月 15 日增补。

这个查询会使用到联合索引 `(A,B,C)`，因为条件是按照索引列 `A`、`B`、`C` 的顺序来的，这是理想的使用场景。

1. 对于 `A=?`：这个条件是一个精确匹配，MySQL 会使用索引来定位到满足条件 `A=?` 的记录。
2. 对于 `B IN (?, ?)`：这个条件指定了 `B` 列可以取两个可能的值。MySQL 会利用索引来查找所有匹配 `A=?` 且 `B` 列为这两个值中任意一个的记录。
3. 对于 `C>?`：这个条件是一个范围查询。在已经根据 `A` 和 `B` 筛选的基础上，MySQL 会继续利用索引来查找 `C` 列值大于指定值的记录。来验证一下。
第一步，建表。

```sql
CREATE TABLE tbn (A INT, B INT, C INT, D TEXT);
```
第二步，创建索引。

```sql
CREATE INDEX idx_abc ON tbn (A, B, C);
```
第三步，插入数据。

```sql
INSERT INTO tbn VALUES (1, 2, 3, 'First');
INSERT INTO tbn VALUES (1, 2, 4, 'Second');
INSERT INTO tbn VALUES (1, 3, 5, 'Third');
INSERT INTO tbn VALUES (2, 2, 3, 'Fourth');
INSERT INTO tbn VALUES (2, 3, 4, 'Fifth');
```
第四步，执行查询。

```sql
EXPLAIN SELECT * FROM tbn WHERE A=1 AND B IN (2, 3) AND C>3\G
```
![image.png](./索引.assert/1747623662978-2be9dbfd-ff6c-46b1-a0d1-f3541003ad82.png)

从 `EXPLAIN` 输出结果来看，我们可以得到 MySQL 是如何执行查询的一些关键信息：

- **id**: 查询标识符，这里是 `1`。
- **select_type**: 查询的类型，这里是 `SIMPLE`，表示这是一个简单的查询，没有使用子查询或复杂的联合查询。
- **table**: 正在查询的表名，这里是 `tbn`。
- **type**: 查询类型，这里是 `range`，表示 MySQL 使用了范围查找。这是因为查询条件包含了 `>` 操作符，使得 MySQL 需要在索引中查找满足范围条件的记录。
- **possible_keys**: 可能被用来执行查询的索引，这里是 `idx_abc`，表示 MySQL 认为 `idx_abc` 索引可能会用于优化查询。
- **key**: 实际用来执行查询的索引，也是 `idx_abc`，这意味着 MySQL 实际上使用了 `idx_abc` 联合索引来优化查询。
- **key_len**: 使用索引的长度，这里是 `15` 字节，这提供了关于索引使用情况的一些信息，比如哪些列被用在了索引中。
- **ref**: 显示哪些列或常量被用作索引查找的参考。
- **rows**: MySQL 估计为了找到结果需要检查的行数，这里是 `2`。
- **filtered**: 表示根据表的条件过滤后，剩余多少百分比的结果，这里是 `100.00`%，意味着所有扫描的行都会被返回。
- **Extra**: 提供了关于查询执行的额外信息。`Using index condition` 表示 MySQL 使用了索引条件推送（Index Condition Pushdown，ICP），这是 MySQL 的一个优化方式，它允许在索引层面过滤数据，减少访问表数据的需要。#### 联合索引 abc，a=1,c=1/b=1,c=1/a=1,c=1,b=1 走不走索引？
> 2024 年 03 月 19 日增补

我们通过实际的 SQL 来验证一下。
示例 1（a=1,c=1）：

```sql
EXPLAIN SELECT * FROM tbn WHERE A=1 AND C=1\G
```
![image.png](./索引.assert/1747623662991-d6b153b9-cbaf-4833-ac1d-40a7cd0de2a5.png)

key 是 idx_abc，表明 a=1,c=1 会使用联合索引。但因为缺少了 B 字段的条件，所以 MySQL 可能无法利用索引来直接定位到精确的行，而是使用索引来缩小搜索范围。
最终，MySQL 需要检查更多的行（rows: 3）来找到满足所有条件的结果集，但总体来说，使用索引明显比全表扫描要高效得多。
示例 2（b=1,c=1）：

```sql
EXPLAIN SELECT * FROM tbn WHERE B=1 AND C=1\G
```
![image.png](./索引.assert/1747623662940-bfd02d17-72f9-4643-8402-22ca8d9c6c36.png)

key 是 NULL，表明 b=1,c=1 不会使用联合索引。这是因为查询条件中涉及的字段 B 和 C 没有遵循之前定义的联合索引 idx_abc（A、B、C 顺序）的最左前缀原则。
在 idx_abc 索引中，A 是最左边的列，但是查询没有包含 A，因此 MySQL 无法利用这个索引。
示例 3（a=1,c=1,b=1）：

```sql
EXPLAIN SELECT * FROM tbn WHERE A=1 AND C=1 AND B=1\G
```
![image.png](./索引.assert/1747623663312-2919cee7-f206-4a8b-b9d1-bd5dd0805077.png)

key 是 idx_abc，表明 a=1,c=1,b=1 会使用联合索引。
并且 rows=1，因为查询条件包含了联合索引 idx_abc 中所有列的等值条件，并且条件的顺序与索引列的顺序相匹配，使得查询能够准确、快速地定位到目标数据。
#### 联合索引的一个场景题：(a,b,c)联合索引，(b,c)是否会走索引吗？
> 2024 年 04 月 06 日增补

根据最左前缀原则，(b,c) 查询不会走索引。
因为联合索引 (a,b,c) 中，a 是最左边的列，联合索引在创建索引树的时候需要先有 a，然后才会有 b 和 c。而查询条件中没有包含 a，所以 MySQL 无法利用这个索引。

```sql
EXPLAIN SELECT * FROM tbn WHERE B=1 AND C=1\G
```
![image.png](./索引.assert/1747623663702-fc885afb-40d1-40df-81a1-73976bab67c2.png)

#### 建立联合索引(a,b,c)，where c = 5 是否会用到索引？为什么？
> 2024 年 04 月 08 日增补

在这个查询中，只有索引的第三列 c 被用作查询条件，而前两列 a 和 b 没有被使用。这不符合最左前缀原则，因此 MySQL 不会使用联合索引 (a,b,c)。

```sql
EXPLAIN SELECT * FROM tbn WHERE C=5\G
```
![image.png](./索引.assert/1747623663653-d1ed7934-af5f-468d-ac0d-a24f71360861.png)

#### sql中使用like，如果遵循最左前缀匹配，查询是不是一定会用到索引？
> 2024 年 11 月 04 日增补

既然遵循最左前缀匹配，说明一定是联合索引，那么查询是一定会用到索引的。
但如果查询条件中的 like 通配符 % 出现在搜索字符串的开始位置，如 `age = 18 and name LIKE '%xxx'`，MySQL 会先使用联合索引 age_name 找到 age 符合条件的所有行，然后再进行 name 字段的过滤。
![image.png](./索引.assert/1747623663837-63927b9f-94b1-430c-a752-f8892039eb8f.png)

`type: ref` 表示使用索引查找匹配某个值的所有行。
![image.png](./索引.assert/1747623663775-70738cf1-0833-4ed0-868c-3ba1a6fa60b1.png)

`rows: 3` 表示预计扫描 3 行。`filtered: 16.67` 表示在前面的 rows 中，大约有 16.67% 的行满足 WHERE 条件。
如果是后缀通配符，如 `age = 18 and name LIKE 'xxx%'`，MySQL 会直接使用联合索引 age_name 找到所有符合条件的行。
![image.png](./索引.assert/1747623663839-f12ca3c6-becd-4bc8-be41-7a25817061c1.png)

type 为 range，表示 MySQL 使用了索引范围扫描，`filtered 为 100.00%`，表示在扫描的行中，所有的行都满足 WHERE 条件。

> 
1. [Java 面试指南（付费）](https://javabetter.cn/zhishixingqiu/mianshi.html)收录的字节跳动商业化一面的原题：(A,B,C) 联合索引 `select * from tbn where a=? and b in (?,?) and c>?` 会走索引吗？
2. [Java 面试指南（付费）](https://javabetter.cn/zhishixingqiu/mianshi.html)收录的京东同学 10 后端实习一面的原题：联合索引 abc，a=1,c=1/b=1,c=1/a=1,c=1,b=1 走不走索引
3. [Java 面试指南（付费）](https://javabetter.cn/zhishixingqiu/mianshi.html)收录的快手面经同学 7 Java 后端技术一面面试原题：联合索引的一个场景题：(a,b,c)联合索引，(b,c)是否会走索引
4. [Java 面试指南（付费）](https://javabetter.cn/zhishixingqiu/mianshi.html)收录的字节跳动面经同学 1 Java 后端技术一面面试原题：建立联合索引(a,b,c)，where c = 5 是否会用到索引？为什么？
5. [Java 面试指南（付费）](https://javabetter.cn/zhishixingqiu/mianshi.html)收录的美团面经同学 15 点评后端技术面试原题：sql中使用like，如果遵循最左前缀匹配，查询是不是一定会用到索引
