## å‰è¨€
> å¤šå­¦ä¸€åˆ†é’Ÿï¼Œå¥³å‹éƒ½ä¸åŒï¼ŒæŠŠéšœç¢å˜æˆæœºä¼šï¼ŒæŠŠé—®é¢˜å˜æˆå¯èƒ½ã€‚

å­¦ä¹ æ–°çŸ¥è¯†çš„æ ¸å¿ƒå°±åœ¨äº **é‡å¤ + é‡å¤ + é‡å¤**
æœ¬äººä¹Ÿæ˜¯ä»ä¸€æ— æ‰€çŸ¥å¼€å§‹å°è¯•åˆ·ç®—æ³•ï¼Œä¸­é—´æ–­æ–­ç»­ç»­ç—›è‹¦/çº ç»“/æ— èƒ½ç‹‚æ€’ã€‚ç¬¬1æ¬¡çš„æ—¶å€™ï¼Œæ•´äººæ˜¯è’™åœˆçš„ï¼Œçœ‹ç€åˆ«äººçš„æ ‡å‡†ç­”æ¡ˆæ…¢æ…¢çš„æ‘¸ç´¢ç®—æ³•çš„å«ä¹‰ï¼Œé‚£çœŸæ˜¯ä¸€æ”¯ç¬”ä¸€æ¯èŒ¶ï¼Œä¸€é“åŠ›æ‰£åˆ·ä¸€å¤©ã€‚å½“é‡å¤åˆ°ç¬¬5æ¬¡çš„æ—¶å€™ï¼Œå¼€å§‹æœ‰äº›æ„Ÿè§‰äº†ï¼Œçœ‹åˆ°é¢˜ç›®çš„æ ‡é¢˜ï¼Œå°±å¯ä»¥ç«‹åˆ»å›æƒ³åˆ°é¢˜ç›®çš„å¤§æ¦‚çš„è§£é¢˜æ–¹å‘ï¼Œä½†æ˜¯å¾ˆå¤šç»†èŠ‚è¿˜æ˜¯è„‘è¢‹ä¸€å›¢æµ†ç³Šï¼Œé‚£å°±ç»§ç»­é‡å¤ï¼Œå½“åˆ°äº†ç¬¬8æ¬¡çš„æ—¶å€™ï¼Œçªç„¶å°±è§‰å¾—å°±æ˜¯è¿™æ ·çš„ï¼Œå¾ˆå®¹æ˜“è®°ä½å‘€ï¼Œä¸è¿‡å¦‚æ­¤å‘€ã€‚
åˆ·é¢˜ï¼ˆæœ¬è´¨å°±æ˜¯èƒŒè¯µï¼‰æˆ‘ä»¬çš„ç›®çš„å°±æ˜¯è¦å»é¢è¯•ï¼Œæ‰€ä»¥é¢˜ç›®å°½å¯èƒ½çš„è¦é€‰æ‹©å‘½ä¸­ç‡é«˜çš„é¢˜åº“å»åˆ·ï¼Œè€Œä¸æ˜¯åŠ›æ‰£çš„é¢˜ç›®ä»ç¬¬ä¸€é¢˜å¼€å§‹ï¼Œæ„ä¹‰ä¸å¤§ã€‚å½“èƒŒè¯µäº†300é“é¢˜ç›®ä»¥åï¼Œå»é¢è¯•çš„æ—¶å€™ï¼Œåªè¦è€ƒç®—æ³•é¢˜ç›®ï¼Œæˆ‘å…¶å®å¾ˆå…´å¥‹çš„ï¼ˆå› ä¸ºèƒŒçš„å¾ˆç†Ÿæ‚‰ï¼‰ï¼Œåˆ·è¿‡çš„é¢˜ç›®çš„å‘½ä¸­ç‡è¿˜æŒºé«˜çš„ã€‚
å¤§å®¶ä¸è¦æŠŠç®—æ³•é¢˜æƒ³è±¡çš„è¿‡äºé«˜å¤§ä¸Šï¼Œæ—¢ç„¶æ˜¯é¢˜ç›®ï¼Œé‚£å°±æ˜¯æœ‰ç­”æ¡ˆå’Œè§£é¢˜å¥—è·¯çš„ã€‚èƒŒè¯µç­”æ¡ˆ + æ€»ç»“è§£é¢˜å¥—è·¯ï¼ŒåŒç±»å‹çš„é¢˜ç›®å³ä½¿ä½ é¢˜ç›®éƒ½çœ‹çš„æ‡µæ‡µæ‡‚æ‡‚ï¼Œéƒ½æœ‰å¯èƒ½è’™å‡ºæ¥ã€‚
æœ¬æ–‡ç« é¢˜ç›®éƒ½æ˜¯æ¥æºäº [https://codetop.cc/home](https://codetop.cc/home) é‡Œé¢è€ƒå¯Ÿé¢‘åº¦é«˜çš„é¢˜ç›®ï¼Œéƒ½æ˜¯é¢è¯•åäººå·¥æ ‡è®°å‡ºæ¥çš„ï¼ˆé¢è¯•å‘½ä¸­ç‡é«˜ï¼‰ã€‚æˆ‘å†™è¿™ä¸ªæ–‡ç« çš„ç›®çš„ï¼Œå°±æ˜¯æä¾›ä¸€ä»½å‚è€ƒç­”æ¡ˆï¼ŒåŒ…æ‹¬ä»£ç æ¯è¡Œçš„å«ä¹‰ï¼Œä»¥åŠé€šç”¨çš„å¥—è·¯ã€‚å› ä¸ºä¸€æ—¦ç†è§£äº†ï¼ŒæŒ‰ç…§è‡ªå·±çš„æ–¹å¼å»è®°å¿†ä¼šå®¹æ˜“å¾ˆå¤šã€‚ åªéœ€è¦ç”¨è¿™ä¸ªç½‘ç«™ä½œä¸ºé¢˜ç›®**æ˜¯å¦åšè¿‡**çš„æ ‡è®°å³å¯ï¼ˆå› ä¸ºç¬”è®°åŠŸèƒ½è¦æ”¶è´¹ï¼‰ï¼Œè‡ªå·±çš„ç­”æ¡ˆç›´æ¥ä¿å­˜åœ¨åŠ›æ‰£å®˜æ–¹åˆ·é¢˜ç½‘ç«™ä¸Š
![d092ee9d-9e6f-4d23-810f-b41db013c5ef.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411700500-d092ee9d-9e6f-4d23-810f-b41db013c5ef.png)

è¿™é‡Œè¿˜æœ‰ä¸€ä»½é€‚åˆå°ç™½çš„ç®—æ³•ä¹¦ [https://www.hello-algo.com/](https://www.hello-algo.com/) åœ¨Githubä¸Šè¿˜æŒºç«çš„ã€‚æˆ‘ä¸ªäººè§‰å¾—ä¹Ÿå¯æ‹¿æ¥æ‰«ä¸‹ç›²ï¼Œæˆ–è€…åˆ·é¢˜é‡åˆ°ç†è§£ä¸Šçš„å›°éš¾å¯ä»¥æ‹¿æ¥çœ‹çœ‹ã€‚
![6bc8b8e3-5597-497a-918b-f15978b86df6.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411701207-6bc8b8e3-5597-497a-918b-f15978b86df6.png)

## è§£é¢˜å¥—è·¯
è§£é¢˜å¥—è·¯å¯ä»¥å…ˆç®€å•çœ‹ä¸‹ï¼Œå½“é‡åˆ°ç›¸å…³çš„é¢˜ç›®ï¼Œå¯ä»¥å›æ¥å†ç»†ç»†å“å‘³ã€‚å»ºè®®è¿˜æ˜¯å…ˆç›´æ¥åˆ·é¢˜ã€‚
## äºŒåˆ†æœç´¢ç®—æ³•
åœ¨æœ‰åºæ•°ç»„`nuns`ä¸­æœç´¢ `target` å¹¶è¿”å›ç´¢å¼•ï¼Œå¦‚æœæ²¡æœ‰æœç´¢åˆ°è¿”å›`-1`ã€‚
![25e45c7a-50a5-48de-9431-44116fc6f33b.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411700313-25e45c7a-50a5-48de-9431-44116fc6f33b.png)

æ¯”å¦‚æˆ‘ä»¬è¦æœç´¢ `target = 4`æ­¤æ—¶`left = 0 right = 5` è®¡ç®—å¾—åˆ°çš„`mid = 2`
ç”±å›¾å¯çŸ¥ï¼Œ`target > nums[2]`ä½äºç´¢å¼•`mid=2`çš„å³ä¾§ä½ç½®ï¼Œè¯´æ˜`[1,2,3]`æ•°æ®æ²¡æœ‰å†æœç´¢çš„å¿…è¦ï¼ˆç›¸å½“äºåˆ‡æ‰äº†ä¸€åŠçš„æœç´¢æ•°æ®é‡ï¼‰ï¼Œåªéœ€è¦ç»§ç»­æœç´¢ `[mid+1:right]`èŒƒå›´å†…çš„æ•°æ®å³å¯ã€‚ä¹Ÿå°±æ˜¯è®© `left = mid+1`å³ `left= 3 right = 5`ï¼Œç»§ç»­è¿›è¡Œæœç´¢çš„è¿‡ç¨‹ï¼Œç›´åˆ°æ‰¾åˆ°æ•°æ®æˆ–è¶Šç•Œã€‚
äºŒåˆ†æœç´¢ç®—æ³•çš„å¥½å¤„ï¼Œåœ¨äºæ¯ä¸€æ¬¡`for`å¾ªç¯æœç´¢ï¼Œå¯ä»¥å‰”é™¤ä¸€åŠçš„æ•°æ®é‡ï¼Œè®©ç®—æ³•æ›´å¿«çš„è¶‹è¿‘äºç›®æ ‡å€¼ã€‚
ä¸€èˆ¬é¢˜ç›®è¦æ±‚ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦`O(log2)`å°±è¦æƒ³åˆ°äºŒåˆ†æœç´¢ç®—æ³•

```go
func search(nums []int,target int) int{

    left,right := 0,len(nums)-1

    for left <= right {

        mid := left +(right-left)/2
        if nums[mid] == target{ // æ‰¾ target ï¼Œè¿”å›ç´¢å¼•mid
            return mid
        } else if target < nums[mid] { // è¯´æ˜ targetä½äº ç´¢å¼•midçš„å·¦ä¾§ï¼Œæ”¶ç¼© right
            right = mid -1
        } else { // è¯´æ˜ targetä½äº ç´¢å¼•midçš„å³ä¾§ï¼Œæ”¶ç¼© left
            left = mid + 1
        }
    }
    // æ²¡æ‰¾åˆ°
    return -1
}
```
## äºŒå‰æ ‘éå†å¥—è·¯

```go
// å‰åºéå†å¥—è·¯
func preOrder(root *TreeNode){
  if root == nil {
    return
  }
  
  fmt.Println(root.Val)
  
  preOrder(root.Left)
  preOrder(root.Right)
} 

// ä¸­åºéå†å¥—è·¯
func preOrder(root *TreeNode){
  if root == nil {
    return
  }
 
  preOrder(root.Left)
  fmt.Println(root.Val)
  preOrder(root.Right)
}

// ååºéå†å¥—è·¯
func preOrder(root *TreeNode){
  if root == nil {
    return
  }
  
  preOrder(root.Left)
  preOrder(root.Right)
  fmt.Println(root.Val)
  
}
```
## æ»‘åŠ¨çª—å£è§£é¢˜å¥—è·¯

- å®šä¹‰ `left right := 0,0` æŒ‡å‘èµ·å§‹ä½ç½® `0`
- è®© `right`ä¸æ–­çš„å³ç§»ï¼Œå½“é‡åˆ°ä¸ç¬¦åˆé¢˜æ„çš„æ¡ä»¶`condition`ï¼Œåœæ­¢ç§»åŠ¨ `right`
- ç„¶åå¼€å§‹è®©`left`ä¸æ–­å³ç§»ï¼Œç›´åˆ°æ¡ä»¶`condition`å¾—åˆ°æ»¡è¶³ï¼Œç»§ç»­é‡å¤ğŸ‘†çš„æ­¥éª¤ï¼Œå³ç§»`right`
- å½“ `right`è¶Šç•Œï¼Œå…¨éƒ¨ç»“æŸåŠ¨æ€è§„åˆ’å¥—è·¯ä¼ªä»£ç 

```go
nums := []int{1,2,3,4,5,6}
func main() {
  
  //1. å®šä¹‰ `left right := 0,0` æŒ‡å‘èµ·å§‹ä½ç½® `0`
  left, right := 0,0
  
  // right è¶Šç•Œç»“æŸ
  for right < len(nums) {
    
    // 2.ä¸æ–­ç§»åŠ¨ right
    val := nums[right]
    right++ 
    
    // do something.....
    
    // 3.å½“ condition ä¸ç¬¦åˆé¢˜æ„çš„æ—¶å€™ï¼Œç§»åŠ¨ leftï¼Œç›´åˆ°æ»¡è¶³é¢˜æ„ï¼Œè·³å‡º condition
    for  condition {
      val := nums[left]
      left++
    }
    
    //.......
  }
}
```
æ»‘åŠ¨çª—å£è§£é¢˜å¥—è·¯ä¸»è¦æµç¨‹æ˜¯åŒ…æ‹¬

- `left right`çš„å®šä¹‰
- `condition`æ¡ä»¶çš„é€‰å–ï¼ˆè¿™ä¸ªè¦ç»“åˆé¢˜æ„ï¼‰
- ä»¥åŠä¸¤ä¸ª`for`å¾ªç¯## åŠ¨æ€è§„åˆ’è§£é¢˜å¥—è·¯
åŠ¨æ€è§„åˆ’éš¾ç‚¹å°±æ˜¯åœ¨äºé€’æ¨å…³ç³»çš„å‘ç°ï¼Œè¿™ä¸ªåªèƒ½ä»å…·ä½“çš„é¢˜ç›®ä¸­æ¥æ„Ÿå—ã€‚å¦‚æœè¯´ç†è§£+ èƒŒè¯µé¢˜ç›®çš„è¯ï¼Œå…¶å®åŠ¨æ€è§„åˆ’çš„é¢˜ç›®åˆæ˜¯æœ€å®¹æ˜“è®°å¿†å’Œç†è§£çš„

- æ˜ç¡®`dp`æ•°ç»„çš„å®šä¹‰
- æ˜ç¡® `dp[i]`å’Œ `dp[i-1]`ä¹‹é—´é€’æ¨å…³ç³»çš„å®šä¹‰(è¿™ä¸ªæ˜¯åŠ¨æ€è§„åˆ’çš„éš¾ç‚¹ï¼Œå…¶å®è¯´ç™½äº†ï¼Œå°±æ˜¯è¦æ ¹æ®é¢˜æ„ï¼Œæ‰¾`dp[i]`å’Œ `dp[i-1]`çš„å…³ç³» )ï¼Œå½¢å¼ä¸Šçœ‹èµ·æ¥å’Œé«˜ä¸­å­¦è¿‡çš„å‡½æ•°æ¨åˆ°å…³ç³»æ˜¯ä¸€æ‘¸ä¸€æ ·çš„ï¼Œæ¯”å¦‚ `f(x) = f(x-1) + f(x-2)`åœ¨å®ç°ä»£ç çš„æ—¶å€™åŒ…æ‹¬ä¸‰ä¸ªæ–¹é¢ï¼š

- åˆ›å»º`dp`æ•°ç»„
- åˆå§‹åŒ–`dp`æ•°ç»„ï¼ˆéœ€è¦ç‰¹æ®Šå¤„ç†çš„å€¼ï¼‰
- éå† `nums`æ•°ç»„ï¼Œå®ç°ä¸€èˆ¬æ€§çš„é€’æ¨å…³ç³»ä¼ªä»£ç 

```go
func main() {
  nums := []int{1,2,3,4}
  
  //1.å®šä¹‰ dp æ•°ç»„
  
  dp := make([]int,len(nums))
  
  //2. åˆå§‹åŒ– dp æ•°ç»„ï¼ˆæ ¹æ®é¢˜ç›®è¦æ±‚ä¹Ÿå¯èƒ½ä¸éœ€è¦è¿™ä¸€æ­¥éª¤ï¼‰
  
  for k := range dp {
    dp[k] = 1
  }
  
  //3. éå† `nums`æ•°ç»„ï¼Œå®ç°ä¸€èˆ¬æ€§çš„é€’æ¨å…³ç³»
  
  for i := 0;i < len(nums);i++ {
    dp[i] = dp[i-1] + 1 // æ¯”å¦‚ï¼šè¿™é‡Œçš„é€’æ¨å…³ç³»ä¸ºï¼šå‰ä¸€ä¸ªçš„ dp[i-1]çš„åŸºç¡€ä¸Šï¼ŒåŠ 1
  }
  
  //......
}
```
æœ‰ä¸€é“åŠ¨æ€è§„åˆ’æœ€ç®€å•çš„å…¥é—¨é¢˜ç›® æ–æ³¢é‚£å¥‘æ•° [https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/](https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/) å¯ä»¥æ¥ä½“ä¼šä¸‹ä¸Šé¢è¯´çš„å¥—è·¯
LCR 126. æ–æ³¢é‚£å¥‘æ•°
**æ–æ³¢é‚£å¥‘æ•°** ï¼ˆé€šå¸¸ç”¨ `F(n)` è¡¨ç¤ºï¼‰å½¢æˆçš„åºåˆ—ç§°ä¸º **æ–æ³¢é‚£å¥‘æ•°åˆ—** ã€‚è¯¥æ•°åˆ—ç”± **0** å’Œ **1** å¼€å§‹ï¼Œåé¢çš„æ¯ä¸€é¡¹æ•°å­—éƒ½æ˜¯å‰é¢ä¸¤é¡¹æ•°å­—çš„å’Œã€‚ä¹Ÿå°±æ˜¯ï¼š
> F(0) = 0
F(1) = 1
F(n) = F(n - 1) + F(n - 2)ï¼Œå…¶ä¸­ n > 1

ç»™å®š `n` ï¼Œè¯·è®¡ç®— `F(n)` ã€‚ç­”æ¡ˆéœ€è¦å–æ¨¡ 1e9+7(1000000007) ï¼Œå¦‚è®¡ç®—åˆå§‹ç»“æœä¸ºï¼š1000000008ï¼Œè¯·è¿”å› 1ã€‚
æ€è·¯ï¼š

- `dp`å®šä¹‰ï¼š åœ¨ `i`ä½ç½®çš„æ•°å­—å’Œ `dp[i]`
- `dp`é€’æ¨å…³ç³»ï¼šæ¯ä¸€é¡¹æ•°å­—éƒ½æ˜¯å‰é¢ä¸¤é¡¹æ•°å­—çš„å’Œï¼Œæ‰€ä»¥æœ‰ `dp[i] = dp[i-1] + dp[i-2]`å…¶å®ï¼Œé¢˜ç›®å·²ç»ç›´æ¥ç»™å‡ºäº† é€’æ¨å…³ç³» `F(n) = F(n-1)+F(n-2)`ï¼Œä½†æ˜¯å¤§éƒ¨åˆ†çš„é¢˜ç›®æ˜¯ä¸ä¼šç»™å‡ºï¼Œéœ€è¦æˆ‘ä»¬ç»“åˆé¢˜ç›®è‡ªå·±æ˜¯æ€è€ƒè¿™ä¸ªé€’æ¨å…³ç³»ã€‚

```go
func fib(n int) int {
    
  	//1. å®šä¹‰ dp æ•°ç»„
    dp := make([]int,n+1)
  	
    for i := 0; i <= n;i++ {
      	// 2. åˆå§‹åŒ– ï¼ˆéœ€è¦ç‰¹æ®Šå¤„ç†çš„å€¼ï¼‰
        if i == 0 {
            dp[i] = 0
        } else if i == 1 { // 2. åˆå§‹åŒ– ï¼ˆéœ€è¦ç‰¹æ®Šå¤„ç†çš„å€¼ï¼‰
            dp[i] = 1
        } else{
          	// 3. é€’æ¨å…³ç³» å®ç°
             dp[i] = (dp[i-1] + dp[i-2]) % 1000000007 // è¿™ä¸ªæ˜¯é¢˜ç›®è¦æ±‚ã€å–æ¨¡ã€‘
        }
    }
  	// 4. è¿”å› F(n) çš„ç»“æœï¼Œå³ dp[n]
    return dp[n]    
}
```
## å›æº¯ç®—æ³•ä»£ç å¥—è·¯

- å›æº¯ç®—æ³•ï¼šæ¯ä¸€å±‚é€‰æ‹©ä¸€ä¸ªå…ƒç´ ï¼Œå‰©ä¸‹çš„å…ƒç´ ç•™ç»™ä¸‹ä¸€å±‚é€‰æ‹©ï¼Œä¸€å±‚ä¸€å±‚çš„è¿›è¡Œé€‰æ‹©ï¼Œç›´åˆ°å°†æ‰€æœ‰çš„æƒ…å†µéå†å®Œæˆæ‰“ä¸ªæ¯”æ–¹ï¼š
æœ‰ A B C ä¸‰ä¸ªè‹¹æœï¼Œæœ‰å°æ˜å’Œå°ç‹ 2ä¸ªåŒå­¦ï¼Œå„é€‰æ‹©ä¸€ä¸ªè‹¹æœã€‚
å¦‚æœå°æ˜å…ˆé€‰æ‹© A è‹¹æœï¼Œé‚£ä¹ˆå°ç‹åªèƒ½é€‰æ‹©B æˆ–è€… C è‹¹æœï¼›
å¦‚æœå°æ˜é€‰æ‹© B è‹¹æœï¼Œé‚£ä¹ˆå°ç‹åªèƒ½é€‰æ‹© A æˆ–è€… C è‹¹æœï¼›
å¦‚æœå°æ˜é€‰æ‹© C è‹¹æœï¼Œé‚£ä¹ˆå°ç‹åªèƒ½é€‰æ‹© A æˆ–è€… B è‹¹æœã€‚
å¯ä»¥çœ‹åˆ°ï¼Œå°æ˜åœ¨é€‰ä¸­ä¸€ä¸ªè‹¹æœåï¼Œå°ç‹åªèƒ½åœ¨å‰©ä¸‹çš„è‹¹æœä¸­é€‰æ‹©ä¸€ä¸ªç•™ç»™è‡ªå·±ï¼ˆå› ä¸ºå¦ä¸€ä¸ªå·²ç»è¢«å°æ˜å ç”¨äº†ï¼‰
å›æº¯ç®—æ³•ï¼Œå°±æ˜¯åœ¨ç©·å°½æ‰€æœ‰çš„æƒ…å†µï¼Œåœ¨ `backtrack`çš„ `for`å¾ªç¯ä¸­é€‰ä¸­ä¸€ä¸ªå…ƒç´ ï¼Œå‰©ä¸‹çš„çš„å…ƒç´ ï¼ˆé€šè¿‡ `start`æ¥åœˆå®šï¼‰å°±ç•™ç»™ ä¸‹ä¸€ä¸ª `backtrack`å‡½æ•°è¿›è¡Œé€‰æ‹©ã€‚
`start`ä¸æ˜¯å¿…é¡»çš„ï¼Œæœ‰äº›é¢˜ç›®å¯èƒ½éœ€è¦åœ¨å…¨éƒ¨é‡Œé¢é€‰æ‹©ï¼ˆæ¯”å¦‚ï¼Œå°æ˜å…ˆé€‰æ‹© A è‹¹æœï¼Œé‚£ä¹ˆå°ç‹å¯ä»¥ é€‰æ‹©A æˆ–è€… B æˆ–è€… C è‹¹æœï¼‰ï¼Œæœ‰äº›éœ€è¦åœ¨ `start`åœˆå®šçš„èŒƒå›´å†…é€‰æ‹©ï¼ˆå°æ˜å…ˆé€‰æ‹© A è‹¹æœï¼Œé‚£ä¹ˆå°ç‹åªèƒ½é€‰æ‹©B æˆ–è€… C è‹¹æœï¼‰
ä¼ªä»£ç 

```go
/*
nums  æ•°ç»„
start éå†æ•°ç»„çš„èµ·å§‹ä½ç½®ï¼ˆè¿™ä¸ªè¦æ ¹æ®é¢˜æ„ï¼Œæœ‰æ—¶ä¸éœ€è¦ï¼‰
trace è®°å½•å›æº¯çš„ç»“æœ
*/
func backtrack(nums []int , start int, trace []int) {
  
  // ç»“æŸæ¡ä»¶
  if condition {
    return
  }
  
  for i := start;i < len(nums);i++ {
    
    // å½“å‰é€‰æ‹©
    trace = append(trace,nums[i])
    
    // ç»§ç»­ä¸‹ä¸€è½®çš„å›æº¯
    backtrack(nums,i+1,trace)
    
    // æ’¤é”€å½“å‰é€‰æ‹©
    trace = trace[:len(trace)-1]
  }
}
```
`start`ç”¨æ¥é™å®šæ¯æ¬¡ `backtrace`å‡½æ•°ï¼Œèƒ½é€‰æ‹©çš„å…ƒç´ èŒƒå›´
`trace = append(trace,nums[i])`åœ¨å½“å‰å±‚é€‰ä¸­å…ƒç´ `nums[i]`ï¼Œå‰©ä¸‹çš„å…ƒç´ ç•™ç»™ä¸‹å±‚çš„å›æº¯`backtrack`é€‰æ‹©
![1dd4619c-0395-4c0f-a8e0-6f1b8eada002.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411700383-1dd4619c-0395-4c0f-a8e0-6f1b8eada002.png)

è¿™é‡Œä¸¾ä¾‹ä¸€ä¸ªé¢˜ç›®ï¼š
åœ¨æ•°ç»„`nums=[1,2]`ä¸­æ‰¾å‡ºæ»¡è¶³å…ƒç´ ä¹‹å’Œä¸º`target=3`çš„ã€æ’åˆ—ã€‘ï¼Œå…ƒç´ ä¸èƒ½é‡å¤ä½¿ç”¨ã€‚
ç›´æ¥è‚‰çœ¼çœ‹ï¼Œå¯çŸ¥ï¼šåŒ…æ‹¬ `[1,2] [2,1]` ä¸¤ä¸ªç»“æœ
é€šç”¨çš„ä»£ç æ¨¡æ¿å¦‚ä¸‹ï¼š

```go
// åˆ¤æ–­å…ƒç´ æ˜¯å¦é‡å¤ä½¿ç”¨
var used []int = make([]int,len(nums))

func backtrack(nums []int, target int, trace []int){
    
    for i := 0; i < len(nums);i++ {

        // åˆ¤æ–­å½“å‰nums[i]æ˜¯å¦å¯ä»¥é€‰æ‹©ï¼ˆå› ä¸ºå…ƒç´ ä¸èƒ½é‡å¤ä½¿ç”¨ï¼‰
        if userd[i] {
            continue
        }        

        // é€‰æ‹©
        trace = append(trace,nums[i])
        used[i] = true

        // è¡¨ç¤ºå½“å‰å…ƒç´ nums[i]é€‰æ‹©ä»¥åï¼Œä¸‹ä¸€å±‚è°ƒç”¨ backtrackæ—¶ï¼Œforå¾ªç¯é€‰æ‹©çš„èŒƒå›´ä¾ç„¶æ˜¯[0:len(nums)-1]
        backtrack(nums,target,trace)


        //æ’¤é”€
        trace = trace[:len(trace)-1]
        used[i] = false
    }
}
```
åœ¨æ•°ç»„`nums=[1,2]`ä¸­æ‰¾å‡ºæ»¡è¶³å…ƒç´ ä¹‹å’Œä¸º`target=3`çš„ã€ç»„åˆã€‘ï¼Œå…ƒç´ ä¸èƒ½é‡å¤ä½¿ç”¨ã€‚
ç›´æ¥è‚‰çœ¼çœ‹ï¼Œå¯çŸ¥ï¼šåŒ…æ‹¬ `[1,2]` ä¸€ä¸ªç»“æœ
é€šç”¨çš„ä»£ç æ¨¡æ¿å¦‚ä¸‹ï¼š

```go
func backtrack(nums []int,start, target int, trace []int){
    
    for i := start; i < len(nums);i++ {

        // é€‰æ‹©
        trace = append(trace,nums[i])
        
        // è¡¨ç¤ºå½“å‰å…ƒç´ nums[i]é€‰æ‹©ä»¥åï¼Œä¸‹ä¸€å±‚è°ƒç”¨ backtrackæ—¶ï¼Œforå¾ªç¯é€‰æ‹©çš„èŒƒå›´å˜æˆäº†[i+1:len(nums)-1]
        backtrack(nums,i+1,target,trace)


        //æ’¤é”€
        trace = trace[:len(trace)-1]
    }
}
```
ä½“ä¼šä¸‹å¸¦ `start`å’Œä¸å¸¦ `start`çš„åŒºåˆ«ï¼›åœ¨ä½“ä¼šä¸‹å…ƒç´ ä¸èƒ½é‡å¤çš„æ—¶å€™åŒºåˆ«ã€‚
## CodeTopå‚è€ƒç­”æ¡ˆ
## 3.æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­—ä¸² ï¼ˆæ»‘åŠ¨çª—å£ï¼‰
ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² `s` ï¼Œè¯·ä½ æ‰¾å‡ºå…¶ä¸­ä¸å«æœ‰é‡å¤å­—ç¬¦çš„ **æœ€é•¿ å­ä¸²** çš„é•¿åº¦

```go
ç¤ºä¾‹1
è¾“å…¥: s = "abcabcbb"
è¾“å‡º: 3 
è§£é‡Š: å› ä¸ºæ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²æ˜¯ "abc"ï¼Œæ‰€ä»¥å…¶é•¿åº¦ä¸º 3ã€‚
```
æ€è·¯ï¼š

- ç†è§£**å­ä¸²**çš„å«ä¹‰ï¼š**å­å­—ç¬¦ä¸²****æ˜¯å­—ç¬¦ä¸²ä¸­è¿ç»­çš„****éç©º****å­—ç¬¦åºåˆ—ã€‚** æ¯”å¦‚ï¼š`abc`çš„å­—ä¸² `abc ab bc`ç­‰ï¼Œä½†æ˜¯ `ac`å°±ä¸æ˜¯å­—ä¸²ï¼Œå› ä¸º`a`å’Œ`c`å¹¶ä¸è¿ç»­ï¼Œä¸­é—´é—´éš”äº†`b`
- æ»‘åŠ¨çª—å£ï¼šä¿è¯ `left right`ä¹‹é—´çš„å­—ç¬¦æ²¡æœ‰é‡å¤å‡ºç°ã€‚ç”¨`win`è®°å½•å­—ç¬¦å‡ºç°çš„æ¬¡æ•°ï¼Œå½“`conditon`ä¸º `win`ä¸­å½“æŸä¸ªå­—ç¬¦å‡ºç°æ¬¡æ•° `>1`ï¼Œä¿æŒ `right`ä¸å˜ï¼Œç§»åŠ¨ `left`ç›´è‡³æ¡ä»¶é‡æ–°æˆç«‹ã€‚
```go
func lengthOfLongestSubstring(s string) int {
    //æ»‘åŠ¨çª—å£ã€å·¦å³è¾¹ç•Œã€‘
    left,right := 0,0

    // è®°å½•çª—å£ä¸­å­—ç¬¦å‡ºç°çš„æ¬¡æ•°
    win := make(map[byte]int)

    result := 0
		
  	// åŒ¿åå‡½æ•°ï¼Œæ±‚æœ€å¤§å€¼
    max := func (a ,b int) int {
        if a > b {
            return a
        }
        return b
    }
  
  	
    for right < len(s) {
				// ç§»åŠ¨å³è¾¹ç•Œ+1
        ch := s[right] 
        right++ 
      	// çª—å£ä¸­å­—ç¬¦å‡ºç°çš„æ¬¡æ•°+1
        win[ch]++
      	
	
        for win[ch] > 1 { //å½“å­—ç¬¦å‡ºç°çš„æ¬¡æ•°å¤šäº1æ¬¡ï¼Œè¯´æ˜æ»‘åŠ¨çª—å£ä¸­å­˜åœ¨é‡å¤å­—ç¬¦ï¼Œä¸ç¬¦åˆé¢˜æ„ï¼›éœ€è¦ç§»åŠ¨å·¦è¾¹ç•Œï¼ŒæŠŠé‡å¤å­—ç¬¦åˆ æ‰ï¼Œä¿è¯æ»‘åŠ¨çª—å£çš„å­—ç¬¦æ•°é‡éƒ½æ˜¯1ä¸ªï¼Œæ»¡è¶³é¢˜æ„
            d := s[left]
            left++
            win[d]--
        }

        // å½“å‰çª—å£ä¸­çš„å­—ç¬¦æ•°é‡
        result = max(result,right-left)
    }
    return result
}
```
## 146. LRUç¼“å­˜
è¯·ä½ è®¾è®¡å¹¶å®ç°ä¸€ä¸ªæ»¡è¶³ [LRU (æœ€è¿‘æœ€å°‘ä½¿ç”¨) ç¼“å­˜](https://baike.baidu.com/item/LRU) çº¦æŸçš„æ•°æ®ç»“æ„ã€‚
å®ç° `LRUCache` ç±»ï¼š

- `LRUCache(int capacity)` ä»¥ **æ­£æ•´æ•°** ä½œä¸ºå®¹é‡ `capacity` åˆå§‹åŒ– LRU ç¼“å­˜
- `int get(int key)` å¦‚æœå…³é”®å­— `key` å­˜åœ¨äºç¼“å­˜ä¸­ï¼Œåˆ™è¿”å›å…³é”®å­—çš„å€¼ï¼Œå¦åˆ™è¿”å› `-1` ã€‚
- `void put(int key, int value)` å¦‚æœå…³é”®å­— `key` å·²ç»å­˜åœ¨ï¼Œåˆ™å˜æ›´å…¶æ•°æ®å€¼ `value` ï¼›å¦‚æœä¸å­˜åœ¨ï¼Œåˆ™å‘ç¼“å­˜ä¸­æ’å…¥è¯¥ç»„ `key-value` ã€‚å¦‚æœæ’å…¥æ“ä½œå¯¼è‡´å…³é”®å­—æ•°é‡è¶…è¿‡ `capacity` ï¼Œåˆ™åº”è¯¥ **é€å‡º** æœ€ä¹…æœªä½¿ç”¨çš„å…³é”®å­—ã€‚å‡½æ•° `get` å’Œ `put` å¿…é¡»ä»¥ `O(1)` çš„å¹³å‡æ—¶é—´å¤æ‚åº¦è¿è¡Œã€‚
æ€è·¯ï¼š

- LRUæ˜¯Least Recently Usedçš„ç¼©å†™ï¼Œå³æœ€è¿‘æœ€å°‘ä½¿ç”¨ï¼Œæ˜¯ä¸€ç§å¸¸ç”¨çš„[é¡µé¢ç½®æ¢ç®—æ³•](https://baike.baidu.com/item/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/7626091?fromModule=lemma_inlink)ï¼Œé€‰æ‹©æœ€è¿‘æœ€ä¹…æœªä½¿ç”¨çš„é¡µé¢äºˆä»¥æ·˜æ±°ã€‚è¯¥ç®—æ³•èµ‹äºˆæ¯ä¸ª[é¡µé¢](https://baike.baidu.com/item/%E9%A1%B5%E9%9D%A2/5544813?fromModule=lemma_inlink)ä¸€ä¸ªè®¿é—®å­—æ®µï¼Œç”¨æ¥è®°å½•ä¸€ä¸ªé¡µé¢è‡ªä¸Šæ¬¡è¢«è®¿é—®ä»¥æ¥æ‰€ç»å†çš„æ—¶é—´ tï¼Œå½“é¡»æ·˜æ±°ä¸€ä¸ªé¡µé¢æ—¶ï¼Œé€‰æ‹©ç°æœ‰é¡µé¢ä¸­å…¶ t å€¼æœ€å¤§çš„ï¼Œå³æœ€è¿‘æœ€å°‘ä½¿ç”¨çš„é¡µé¢äºˆä»¥æ·˜æ±°ã€‚ï¼ˆä¹Ÿå°±æ˜¯å½“éœ€è¦æ·˜æ±°æ•°æ®çš„æ—¶å€™ï¼Œé€‰æ‹©æœ€ä¹…æ²¡æœ‰è¢«ä½¿ç”¨çš„æ•°æ®æ·˜æ±°ï¼Œåˆšåˆšä½¿ç”¨çš„æ•°æ®ä¸è¦æ·˜æ±°ï¼‰
- è®°å¿†ç‚¹ï¼šä¸¤ä¸ªæ•°æ®ç»“æ„ `map + list `ï¼Œ `map`ç”¨äºå¿«é€Ÿçš„åˆ¤æ–­`key`æ˜¯å¦å­˜åœ¨å¹¶è·å–åˆ°å€¼ï¼Œ`list`ç”¨äºè®°å½•ã€åˆšè¢«è®¿é—®ã€‘å’Œã€å¾ˆä¹…æ²¡è®¿é—®ã€‘çš„æ•°ç»„ï¼Œå½“éœ€è¦æ·˜æ±°æ•°æ®çš„æ—¶å€™ï¼Œç›´æ¥ä»é“¾è¡¨å°¾éƒ¨æ·˜æ±°å³å¯ã€‚
```go
type LRUCache struct {
  	m map[int]*list.Element // ä¸ºäº†æ»¡è¶³ï¼Œé¢˜ç›®è¦æ±‚çš„ o(1)çš„å¹³å‡æ—¶é—´å¤æ‚åº¦
    l *list.List // é“¾è¡¨ï¼šã€åˆšè¢«è®¿é—®ã€‘æ•°æ®åœ¨é“¾è¡¨å¤´éƒ¨ï¼Œã€å¾ˆä¹…æ²¡è®¿é—®ã€‘æ•°æ®åœ¨é“¾è¡¨å°¾éƒ¨ï¼ˆå½“éœ€è¦æ·˜æ±°æ—¶ï¼Œå°¾éƒ¨çš„æ•°æ®ç›´æ¥åˆ é™¤ï¼‰
    cap int // å®¹é‡
}


type Data struct {
    Key int
    Value int
}

// æ„é€  LRUCache å¯¹è±¡
func Constructor(capacity int) LRUCache {
    cache := LRUCache{}
    cache.m = make(map[int]*list.Element,capacity)
    cache.l = list.New()
    cache.cap = capacity
    return cache
}

// Get è·å–
func (this *LRUCache) Get(key int) int {
  	// å­˜åœ¨
    if v,ok := this.m[key];ok { 
      	//ç§»åŠ¨åˆ°å¤´éƒ¨ï¼ˆå› ä¸ºåˆšè¢«è®¿é—®äº†ï¼‰
        this.l.MoveToFront(v)
      	//è¿”å›å½“å‰å€¼
        return v.Value.(Data).Value
    }
  	// ä¸å­˜åœ¨ç›´æ¥è¿”å› -1
    return -1
}


// Put ä¿®æ”¹
func (this *LRUCache) Put(key int, value int)  {
  	// ä¸å­˜åœ¨
    if v,ok := this.m[key];!ok {
      	// å®¹é‡å·²ç»æ»¡äº†ï½ï½
        if this.cap == this.l.Len() { 
          	// åˆ é™¤æœ€ä¹…æ²¡è®¿é—®çš„ï¼ˆä¹Ÿå°±æ˜¯é“¾è¡¨å°¾éƒ¨å…ƒç´ ï¼‰
            data := this.l.Remove(this.l.Back())
          	// åŒæ—¶ map ä¸­ä¹Ÿè¦åˆ é™¤
            delete(this.m,data.(Data).Key) 
        }
        //æ–°å¢ï¼ˆåˆšè¢«è®¿é—®è¿‡ï¼‰
        e := this.l.PushFront(Data{key,value})
        this.m[key] = e

    }else { // å­˜åœ¨
      	// ä¿®æ”¹æ•°å€¼
        v.Value = Data{key,value} 
      	// åŒæ—¶ç§»åŠ¨åˆ°å¤´éƒ¨ï¼ˆåˆšè¢«è®¿é—®è¿‡ï¼‰
        this.l.MoveToFront(v)
    }
}
```
## 206. åè½¬é“¾è¡¨
ç»™ä½ å•é“¾è¡¨çš„å¤´èŠ‚ç‚¹ `head` ï¼Œè¯·ä½ åè½¬é“¾è¡¨ï¼Œå¹¶è¿”å›åè½¬åçš„é“¾è¡¨ã€‚
![6f0974e1-2140-48ac-99da-eccd0d61a734.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411700354-6f0974e1-2140-48ac-99da-eccd0d61a734.png)

æ€è·¯ï¼š

- **å¯¹äºé€’å½’ç®—æ³•ï¼Œæœ€é‡è¦çš„å°±æ˜¯æ˜ç¡®é€’å½’å‡½æ•°çš„å®šä¹‰**ã€‚å…·ä½“æ¥è¯´ï¼Œæˆ‘ä»¬çš„ `reverseList` å‡½æ•°å®šä¹‰æ˜¯è¿™æ ·çš„ï¼š**è¾“å…¥ä¸€ä¸ªèŠ‚ç‚¹ **`**head**`**ï¼Œå°†ã€Œä»¥ **`**head**`** ä¸ºèµ·ç‚¹ã€çš„é“¾è¡¨åè½¬ï¼Œå¹¶è¿”å›åè½¬ä¹‹åçš„ã€å¤´ç»“ç‚¹ã€‘**ã€‚
```go
// é€’å½’ç®—æ³• reverseList å‡½æ•°çš„å®šä¹‰ï¼šå°†ã€Œä»¥ head ä¸ºèµ·ç‚¹ã€çš„é“¾è¡¨åè½¬ï¼Œå¹¶è¿”å›åè½¬ä¹‹åçš„ã€å¤´ç»“ç‚¹ã€‘
func reverseList(head *ListNode) *ListNode {
  	// å½“æ²¡æœ‰èŠ‚ç‚¹ or åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹çš„æ—¶å€™ï¼Œç›´æ¥è¿”å›head
    if head == nil || head.Next == nil {
        return head
    }
		
  	// è¿™é‡Œè¡¨ç¤ºï¼šå°†ã€Œä»¥ head.Next ä¸ºèµ·ç‚¹ã€çš„é“¾è¡¨åè½¬ï¼Œå¹¶è¿”å›åè½¬ä¹‹åçš„ã€å¤´ç»“ç‚¹ã€‘
    last := reverseList(head.Next)
    head.Next.Next = head
    head.Next = nil
    return res
}
```
![46ccc2d1-4172-458e-b6e2-0135db7f39da.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411700948-46ccc2d1-4172-458e-b6e2-0135db7f39da.png)


- å¯¹äº**è¿­ä»£ç®—æ³•**ï¼Œæˆ‘ä»¬åªéœ€è¦å®šä¹‰ä¸€ä¸ªå‰é©±èŠ‚ç‚¹ `pre`ï¼Œæ¯æ¬¡ç”¨å½“å‰èŠ‚ç‚¹`cur`æ›¿æ¢ å‰é©±èŠ‚ç‚¹`pre`
```go
func reverseList(head *ListNode) *ListNode {
  	// å‰é©±èŠ‚ç‚¹ pre
    var pre *ListNode = nil
    
    for head != nil {

        temp := head.Next // ä¸´æ—¶ä¿å­˜åç¼€èŠ‚ç‚¹

        head.Next = pre //å°†head.Next æŒ‡å‘pre
        pre = head //  head å˜æˆæ–°çš„å‰é©±èŠ‚ç‚¹pre

        head = temp // ç»§ç»­ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
    }
    return pre
}
```
## 215. æ•°ç»„ä¸­çš„ç¬¬Kä¸ªæœ€å¤§å…ƒç´ 
ç»™å®šæ•´æ•°æ•°ç»„ `nums` å’Œæ•´æ•° `k`ï¼Œè¯·è¿”å›æ•°ç»„ä¸­ç¬¬ `k` ä¸ªæœ€å¤§çš„å…ƒç´ ã€‚è¯·æ³¨æ„ï¼Œä½ éœ€è¦æ‰¾çš„æ˜¯æ•°ç»„æ’åºåçš„ç¬¬ `k` ä¸ªæœ€å¤§çš„å…ƒç´ ï¼Œè€Œä¸æ˜¯ç¬¬ `k` ä¸ªä¸åŒçš„å…ƒç´ ã€‚ä½ å¿…é¡»è®¾è®¡å¹¶å®ç°æ—¶é—´å¤æ‚åº¦ä¸º `O(n)` çš„ç®—æ³•è§£å†³æ­¤é—®é¢˜ã€‚

```go
ç¤ºä¾‹ 1:

è¾“å…¥: [3,2,1,5,6,4], k = 2
è¾“å‡º: 5
```
æ€è·¯:

- ç¬¬ä¸€ç§è§£æ³•ï¼šåˆ©ç”¨**å¿«é€Ÿæ’åº**ç®—æ³•ï¼Œæ‰¾åˆ°ç¬¬ `k`ä¸ªæœ€å¤§çš„å…ƒç´ 
```go
func findKthLargest(nums []int, k int) int {

    //æ±‚ç¬¬kå¤§çš„å…ƒç´ ï¼Œå‡å¦‚æ•°ç»„æŒ‰ç…§æ­£åºå·²ç»æ’åˆ—å¥½äº†ï¼Œé‚£ä¹ˆç¬¬kå¤§å…ƒç´ çš„ç´¢å¼•ä½ç½®ä¸ºï¼šlen(nums)-k

    targetIndex := len(nums) - k

    lo,hi := 0,len(nums)-1

    for {
      	// å…ˆç¡®å®šæŸä¸€ä¸ªå…ƒç´ çš„ç´¢å¼•ä½ç½®
        idx := quickSort(nums,lo,hi) 
      	// å¦‚æœç´¢å¼•ä½ç½®å’Œ é¢„æœŸçš„targetIndexç›¸åŒï¼Œè¯´æ˜æ‰¾åˆ°äº†è¯¥å…ƒç´ 
        if targetIndex == idx {
            return nums[idx]
        } else if targetIndex < idx { // æƒ³æ‰¾çš„å…ƒç´ ç´¢å¼•ä½äºå·¦è¾¹ï¼Œæ”¶ç¼© hi
            hi = idx-1
        } else { // æƒ³æ‰¾çš„å…ƒç´ ç´¢å¼•ä½äºå³è¾¹ï¼Œæ”¶ç¼© lo
            lo = idx+1
        }
    }

    return 0
}

// quickSort å¿«é€Ÿæ’åºï¼Œæ‰¾ä¸€ä¸ªå‚ç…§å…ƒç´ vï¼Œä½¿å·¦è¾¹çš„å…ƒç´ éƒ½å°äºvï¼Œå³è¾¹çš„å…ƒç´ éƒ½å¤§äºç­‰äºvï¼Œä»è€Œç¡®å®švåœ¨æ•°ç»„ä¸­çš„å­˜å‚¨ç´¢å¼•ä½ç½®
func quickSort(nums []int ,lo,hi int) int {
    
    v := nums[lo] // å‚ç…§å…ƒç´ å€¼

    left := lo+1
    right := hi
  	
  	// ä¿è¯ left <= right çš„å‰æä¸‹
    for left <= right {
      	
      	// è®©leftæŒ‡å‘çš„å…ƒç´ éƒ½è¦æ¯”vå°
        for left <= right && v > nums[left] { 
            left++
        }
				// è®©rightæŒ‡å‘çš„å…ƒç´ éƒ½è¦æ¯”vå¤§orç›¸ç­‰
        for left <= right && v <= nums[right] { 
            right--
        }
      	
        if left > right {
            break
        }

        // æ‰§è¡Œåˆ°è¿™é‡Œï¼Œè¯´æ˜leftå’Œrightçš„å…ƒç´ ä¸æ»¡è¶³ nums[left] < v <= nums[right] å³leftå°rightå¤§çš„è§„åˆ™ï¼Œäº¤æ¢leftå’Œrightï¼Œé‡æ–°æ»¡è¶³æ¡ä»¶
        nums[left],nums[right] = nums[right],nums[left]
    }

    // æœ€åäº¤æ¢ loå’Œright ä¾‹å¦‚ 2 13ï¼Œæ‰§è¡Œåˆ°è¿™é‡Œï¼ŒleftæŒ‡å‘ 3 rightæŒ‡å‘ 1ï¼Œæœ€åéœ€è¦äº¤æ¢1å’Œ2çš„ä½ç½®
    nums[lo],nums[right] = nums[right],nums[lo]
    return right
}
```
![0b105efe-39de-4fe4-8289-d7aeb7db0537.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411701515-0b105efe-39de-4fe4-8289-d7aeb7db0537.png)


- ç¬¬äºŒä¸ªç§è§£æ³•ï¼šåˆ©ç”¨**å°æ ¹å †**ï¼Œä¿æŒå †ä¸­å…ƒç´ çš„æ•°é‡æœ€å¤š K ä¸ªã€‚å½“è¶…è¿‡ K ä¸ªå…ƒç´ ï¼Œå¼¹å‡ºå †é¡¶å…ƒç´ ï¼Œéå†æ•°ç»„ä¸­çš„æ‰€æœ‰å…ƒç´ ï¼Œå¹¶ç»è¿‡ å°æ ¹å †çš„è¿‡æ»¤ã€‚å½“æ‰€æœ‰å…ƒç´ éå†å®Œæˆåï¼Œå †é¡¶å…ƒç´ å°±æ˜¯ç¬¬Kå¤§çš„å…ƒç´ 
```go
// åˆ©ç”¨å°æ ¹å †ï¼Œå †å¤§å°è®¾å®šä¸ºkã€‚éå†æ•°ç»„ï¼Œå°†å…ƒç´ ç›´æ¥ä¿å­˜åˆ°å †ä¸­ï¼›ä¿è¯çš„å †å¤§å°ç»´æŒåœ¨ <=k
// å½“æ‰€æœ‰çš„å…ƒç´ ç»è¿‡å †ä»¥åï¼Œæœ€åå †å †é¡¶å…ƒç´ å°±æ˜¯ç»“æœ
type MinHeap struct {
    data []int
}

func (m *MinHeap)Swap(i,j int) {
    m.data[i],m.data[j] = m.data[j],m.data[i]
}

func(m *MinHeap)Len() int {
    return len(m.data)
}

func (m *MinHeap)Less(i,j int) bool {
    return m.data[i] < m.data[j]
}

func (m *MinHeap)Push(x any) {
    m.data = append(m.data,x.(int))
}

func (m *MinHeap)Pop() any {
    x := m.data[len(m.data)-1]
    m.data = m.data[:len(m.data)-1]
    return x
}

func (m *MinHeap)Top() int {
    return m.data[0]
}

func findKthLargest(nums []int, k int) int {
    minH := &MinHeap{}
    heap.Init(minH)
  	// éå†æ•°ç»„
    for _ , num := range nums {
      	// ä¿å­˜åˆ°å°æ ¹å †ä¸­
        heap.Push(minH,num)
      	// å½“å…ƒç´ ä¸ªæ•°è¶…è¿‡ k
        for minH.Len() > k {
            heap.Pop(minH) // åˆ é™¤å †é¡¶å…ƒç´ 
        }
    }
    return minH.Top() // æœ€ç»ˆç»“æœï¼Œå°±æ˜¯å°æ ¹å †çš„å †é¡¶å…ƒç´ å€¼
}
```
ä¸‹å›¾è¡¨ç¤ºæ¼”ç¤ºäº†ï¼Œ æ•°ç»„ `2 1 3` æ±‚ç¬¬ 1 å¤§å…ƒç´ çš„è¿‡ç¨‹
![a78cdbed-7c73-4500-91b4-9f7be11d7fa4.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411701254-a78cdbed-7c73-4500-91b4-9f7be11d7fa4.png)

## 25. Kä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨
ç»™ä½ é“¾è¡¨çš„å¤´èŠ‚ç‚¹ `head` ï¼Œæ¯ `k` ä¸ªèŠ‚ç‚¹ä¸€ç»„è¿›è¡Œç¿»è½¬ï¼Œè¯·ä½ è¿”å›ä¿®æ”¹åçš„é“¾è¡¨ã€‚`k` æ˜¯ä¸€ä¸ªæ­£æ•´æ•°ï¼Œå®ƒçš„å€¼å°äºæˆ–ç­‰äºé“¾è¡¨çš„é•¿åº¦ã€‚å¦‚æœèŠ‚ç‚¹æ€»æ•°ä¸æ˜¯ `k` çš„æ•´æ•°å€ï¼Œé‚£ä¹ˆè¯·å°†æœ€åå‰©ä½™çš„èŠ‚ç‚¹ä¿æŒåŸæœ‰é¡ºåºã€‚ä½ ä¸èƒ½åªæ˜¯å•çº¯çš„æ”¹å˜èŠ‚ç‚¹å†…éƒ¨çš„å€¼ï¼Œè€Œæ˜¯éœ€è¦å®é™…è¿›è¡ŒèŠ‚ç‚¹äº¤æ¢ã€‚
æ€è·¯ï¼š

- æŒ‰ç…§ é•¿åº¦kæˆªå–ä¸€æ®µé“¾è¡¨ï¼Œç„¶åå°†è¿™æ®µé“¾è¡¨è¿›è¡Œåè½¬ã€‚ã€åè½¬å‰çš„é“¾è¡¨çš„å¤´èŠ‚ç‚¹ï¼Œå˜æˆäº†åè½¬åçš„é“¾è¡¨çš„å°¾éƒ¨èŠ‚ç‚¹ã€‘
- ç»§ç»­å¯¹åç»­çš„é“¾è¡¨é€’å½’è°ƒç”¨ `reverseKGroup(head *ListNode, k int) *ListNode`ï¼Œå¹¶ä¸”è¿›è¡Œæ‹¼æ¥![981182ad-6ddb-4ecb-95df-9d61e324a3ae.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411701486-981182ad-6ddb-4ecb-95df-9d61e324a3ae.png)


```go
// reverseKGroup å‡½æ•°å®šä¹‰ï¼š æŒ‰ç…§kä¸ªä¸€ç»„ï¼Œåè½¬ä» head å¼€å§‹çš„é“¾è¡¨ï¼Œå¹¶è¿”å›åè½¬åçš„é“¾è¡¨çš„å¤´èŠ‚ç‚¹
func reverseKGroup(head *ListNode, k int) *ListNode {
    a,b := head,head
    //æˆªå–ä¸€ä¸ªé•¿åº¦ä¸ºkçš„é“¾è¡¨
    for i :=0;i < k;i++{
      	// è¯´æ˜ä¸å¤Ÿkä¸ªä¸€ç»„ï¼Œé‚£å°±ä¸éœ€è¦åè½¬
        if b == nil { 
            return head
        }
        b = b.Next
    }
  
  	//ç¿»è½¬é“¾è¡¨ [a,b) æ³¨æ„ä¸åŒ…æ‹¬èŠ‚ç‚¹b
    last := reverse(a,b)
  	// å¯¹ [a,b) è¿›è¡Œåè½¬ä»¥åï¼Œæ­¤æ—¶çš„èŠ‚ç‚¹ aï¼Œå°±æ˜¯åè½¬åçš„é“¾è¡¨çš„æœ€åä¸€ä¸ªå°¾éƒ¨èŠ‚ç‚¹ï¼ˆå› ä¸ºï¼šä¸€å¼€å§‹aæ˜¯ç¬¬ä¸€ä¸ªå¤´èŠ‚ç‚¹ï¼‰
    a.Next = reverseKGroup(b,k)
    return last
}

//ç¿»è½¬æŒ‡å®šèŒƒå›´ [a,b)é“¾è¡¨,è¿”å›å¤´èŠ‚ç‚¹
func reverse(a,b *ListNode) *ListNode {
    var pre *ListNode = nil
    for a != b {
        temp := a.Next

        a.Next = pre
        pre = a
        a = temp
    }
    return pre
}
```
## 15. ä¸‰æ•°ä¹‹å’Œ
ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums` ï¼Œåˆ¤æ–­æ˜¯å¦å­˜åœ¨ä¸‰å…ƒç»„ `[nums[i], nums[j], nums[k]]` æ»¡è¶³ `i != j`ã€`i != k` ä¸” `j != k` ï¼ŒåŒæ—¶è¿˜æ»¡è¶³ `nums[i] + nums[j] + nums[k] == 0` ã€‚è¯·ä½ è¿”å›æ‰€æœ‰å’Œä¸º `0` ä¸”ä¸é‡å¤çš„ä¸‰å…ƒç»„ã€‚
**æ³¨æ„ï¼š**ç­”æ¡ˆä¸­ä¸å¯ä»¥åŒ…å«é‡å¤çš„ä¸‰å…ƒç»„ã€‚
æ€è·¯ï¼š

- å…ˆç»™æ•°ç»„ä»å°åˆ°å¤§æ’åºï¼Œç„¶ååŒæŒ‡é’ˆ `left` å’Œ `right` åˆ†åˆ«åœ¨æ•°ç»„å¼€å¤´å’Œç»“å°¾ï¼Œè¿™æ ·å°±å¯ä»¥æ§åˆ¶ `nums[left]` å’Œ `nums[right]` è¿™ä¸¤æ•°ä¹‹å’Œçš„å¤§å°ï¼š
- å¦‚æœä½ æƒ³è®©å®ƒä¿©çš„å’Œå¤§ä¸€äº›ï¼Œå°±è®© `left++`ï¼Œå¦‚æœä½ æƒ³è®©å®ƒä¿©çš„å’Œå°ä¸€äº›ï¼Œå°±è®© `right--`
- åŸºäºä¸¤æ•°ä¹‹å’Œå¯ä»¥å¾—åˆ°ä¸€ä¸ªä¸‡èƒ½å‡½æ•° `nSumTarget`ï¼Œæ‰©å±•å‡º n æ•°ä¹‹å’Œçš„ä¸€èˆ¬è§£æ³•![b660c8f9-9250-42fb-8430-e934268d56ab.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411701347-b660c8f9-9250-42fb-8430-e934268d56ab.png)


```go
func threeSum(nums []int) [][]int {
  	//1. å¯¹æ•°ç»„è¿›è¡Œæ’åº
    sort.Ints(nums)
    return nSumTarget(nums,3,0,0)
}

// nums: æ•°ç»„
// nï¼š næ•°ä¹‹å’Œ
// startï¼š æ•°ç»„éå†çš„è¾¹ç•Œ
// targetï¼šç›®æ ‡å’Œ
func nSumTarget(nums []int, n int ,start int, target int) [][]int{
    size := len(nums)
    var result [][]int
    if n < 2 || size < n { // æœ€ä½æ±‚ä¸¤æ•°ä¹‹å’Œ or æ•°ç»„ä¸­æ•°æ®ä¸ªæ•°ä¸èƒ½å°äºn
        return result
    } else if n == 2 {//æ±‚ä¸¤æ•°å’Œ
      	// left å·¦è¾¹ç•Œ right å³è¾¹ç•Œ
        left,right := start,size-1
        for left < right {

            leftValue := nums[left]
            rightValue := nums[right]
          	//å·¦å³ä½ç½®çš„ä¸¤æ•°å’Œ
            sum := leftValue + rightValue

            if sum < target { // æ±‚çš„sumå€¼ï¼Œæ¯”ç›®æ ‡å’Œåå°ï¼Œå¢å¤§left
                for left <right && nums[left] == leftValue {
                    left++
                }
            } else if sum > target { // æ±‚çš„sumå€¼ï¼Œæ¯”ç›®æ ‡å’Œåå¤§ï¼Œå‡å°right
                for left < right && nums[right] == rightValue {
                    right--
                }
            } else {
              	// æ‰¾åˆ°ä¸€ç»„ leftValue å’Œ rightValue
                result = append(result,[]int{leftValue,rightValue})
              	// é¢˜ç›®è¦æ±‚ä¸èƒ½é‡å¤
                for left <right && nums[left] == leftValue {
                    left++
                }
                for left < right && nums[right] == rightValue {
                    right--
                }
            }
        }
    }else {
        for i := start;i<size;i++{ //å›ºå®šä¸€ä¸ªæ•°å€¼ï¼Œæ±‚å‰©ä¸‹çš„ä¸¤ä¸ªæ•°å€¼
            sub := nSumTarget(nums,n-1,i+1,target-nums[i])
            //å¯¹ç»“æœæ•´åˆ
            for _,v := range sub {
                v = append(v,nums[i])//è¿½åŠ å½“å‰æ•°å€¼ï¼Œç»„æˆnæ•°ä¹‹å’Œ
                result = append(result,v)
            }
            //åˆ¤æ–­ä¸‹ä¸€ä¸ªæ•°å€¼æ˜¯å¦å’Œå½“å‰å€¼é‡å¤ï¼ˆä¸€æ ·ï¼‰
            for i+1 < size && nums[i] == nums[i+1]{
                i++
            }
        }
    }

    return result
}
```
## 53. æœ€å¤§å­æ•°ç»„å’Œ
ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums` ï¼Œè¯·ä½ æ‰¾å‡ºä¸€ä¸ªå…·æœ‰æœ€å¤§å’Œçš„è¿ç»­å­æ•°ç»„ï¼ˆå­æ•°ç»„æœ€å°‘åŒ…å«ä¸€ä¸ªå…ƒç´ ï¼‰ï¼Œè¿”å›å…¶æœ€å¤§å’Œã€‚
**å­æ•°ç»„**ï¼šæ˜¯æ•°ç»„ä¸­çš„ä¸€ä¸ªè¿ç»­éƒ¨åˆ†ã€‚
æ€è·¯ï¼š

- `dp` æ•°ç»„çš„å®šä¹‰ï¼š**ä»¥ **`**nums[i]**`** ä¸ºç»“å°¾çš„ã€Œæœ€å¤§å­æ•°ç»„å’Œã€ä¸º **`**dp[i]**`**ã€‚**
- `dp`æ•°ç»„é€’æ¨å…³ç³»ä¸ºï¼š `dp[i] = max(0,dp[i-1]) + num[i]``dp[i]` æœ‰ä¸¤ç§ã€Œé€‰æ‹©ã€ï¼Œè¦ä¹ˆä¸å‰é¢çš„ç›¸é‚»å­æ•°ç»„`dp[i-1]`è¿æ¥ï¼Œå½¢æˆä¸€ä¸ªå’Œæ›´å¤§çš„å­æ•°ç»„ï¼›è¦ä¹ˆä¸ä¸å‰é¢çš„å­æ•°ç»„è¿æ¥ï¼Œè‡ªå·±å•ç‹¬ä¸€ä¸ªå…ƒç´ ï¼Œä½œä¸ºä¸€ä¸ªå­æ•°ç»„ã€‚

```go
func maxSubArray(nums []int) int {
	
  // 1. æ„å»ºdpæ•°ç»„
	dp := make([]int, len(nums))
  // 2.åˆå§‹åŒ–ï¼šæ ¹æ®å®šä¹‰ï¼Œç¬¬ä¸€ä¸ªå…ƒç´ çš„æœ€å¤§å­æ•°ç»„å’Œï¼Œå°±æ˜¯ç¬¬ä¸€ä¸ªå…ƒç´ å€¼
	dp[0] = nums[0]
  
  // result è®°å½•æœ€å¤§å­æ•°ç»„å’Œ
  result := nums[0] 

	// 3.åº”ç”¨é€’æ¨å…³ç³»ï¼šé’ˆå¯¹æ¯ä¸ªå…ƒç´ iä½œä¸ºç»“å°¾ï¼Œæ±‚ä»¥å…ƒç´ iç»“å°¾çš„æœ€å¤§å­æ•°ç»„å’Œ
	for i := 1; i < len(nums); i++ {
    // å¦‚æœdp[i-1]ä¸ºè´Ÿæ•°ï¼Œå½“å‰å…ƒç´ æœ¬èº«å°±æ˜¯æœ€å¤§å’Œï¼ˆä¹Ÿå°±æ˜¯ä¸éœ€è¦å’Œå‰é¢å…¶ä»–å…ƒç´ è¿›è¡Œè¿æ¥ï¼‰ï¼›
    dp[i] = max(dp[i-1],0) + nums[i] 
		result = max( result , dp[i] )
	}
	return result
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```
## 912. æ’åºæ•°ç»„
ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums`ï¼Œè¯·ä½ å°†è¯¥æ•°ç»„å‡åºæ’åˆ—ã€‚ä½ å¿…é¡»åœ¨ **ä¸ä½¿ç”¨ä»»ä½•å†…ç½®å‡½æ•°** çš„æƒ…å†µä¸‹è§£å†³é—®é¢˜ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º `O(nlog(n))`ï¼Œå¹¶ä¸”ç©ºé—´å¤æ‚åº¦å°½å¯èƒ½å°ã€‚
æ€è·¯ï¼š
è¿™é‡Œæä¾›å¿…è€ƒçš„**3ç§æ’åºç®—æ³•**
> å¿«é€Ÿæ’åº

**å¿«é€Ÿæ’åºæ˜¯å…ˆå°†ä¸€ä¸ªå…ƒç´ æ’å¥½åºï¼Œç„¶åå†å°†å‰©ä¸‹çš„å…ƒç´ æ’å¥½åº**ã€‚

```go
func sortArray(nums []int) []int {
    //å¿«é€Ÿæ’åº
    quickSort(nums,0,len(nums)-1)
    return nums
}

func quickSort(nums []int, lo ,hi int) {
    if lo >= hi { //ç›¸å½“äºåªæœ‰ä¸€ä¸ªæ•°ï¼Œæˆ–è€…è¶Šç•Œï¼Œå°±ä¸ç”¨æ¯”è¾ƒäº†
        return
    }

    //1.é€‰æ‹©ä¸€ä¸ªæ•°ï¼Œä½œä¸ºå‚è€ƒå…ƒç´ 
    val := nums[lo]

    //2.å·¦å³èµ·å§‹ç´¢å¼•
    left := lo + 1
    right := hi

    //3.ä½¿å·¦è¾¹nums[left]æ¯”valå°   å³è¾¹nums[right]æ¯”valå¤§
    for left <= right {
        for left <= right && nums[left] < val { //ums[left]è®°å½•æ¯”valå°çš„æ•°æ®ç´¢å¼•
            left++
        }

        for left <= right && nums[right] >= val {//nums[right]è®°å½•æ¯”valå¤§çš„æ•°æ®ç´¢å¼•
            right--
        }
        if left > right {
            break
        }
        // æ‰§è¡Œåˆ°è¿™é‡Œï¼Œè¯´æ˜ nums[left]æ¯” val å¤§ï¼Œ nums[right] æ¯”val å°ï¼ˆä¹Ÿå°±æ˜¯ä¸æ»¡è¶³ä¸Šé¢çš„æ¡ä»¶ï¼‰
        // äº¤æ¢ left å’Œ rightï¼Œè®© left right æŒ‡å‘çš„å…ƒç´ ç»§ç»­æ»¡è¶³æ¡ä»¶
        nums[left],nums[right] = nums[right],nums[left]
    }
    //äº¤æ¢ lo å’Œrightï¼Œè¿™æ ·nums[lo]è¿™ä¸ªå…ƒç´ å·²ç»æ’åºå®Œæˆï¼Œä¿å­˜åœ¨äº† right ç´¢å¼•ä½ç½®
    nums[lo],nums[right] = nums[right],nums[lo]

  	// é€’å½’è°ƒç”¨ quickSortï¼Œè®©[lo,right-1] [right+1,hi] ä¸¤ä¸ªå­æ•°ç»„ä¹Ÿéƒ½æœ‰åºã€‚
    //å·¦è¾¹æ•°ç»„
    quickSort(nums,lo,right-1)
    //å³è¾¹æ•°ç»„
    quickSort(nums,right+1,hi)
    return 
}
```
![8f029f81-ca0f-4d68-b7e2-435866cc2ddd.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411702307-8f029f81-ca0f-4d68-b7e2-435866cc2ddd.png)

> å½’å¹¶æ’åº

![c3e07695-c76a-4850-b827-18ff0038f3ab.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411702081-c3e07695-c76a-4850-b827-18ff0038f3ab.png)


```go
var temp []int = nil
func sortArray(nums []int) []int {

    //å½’å¹¶æ’åº
    temp = make([]int,len(nums)) //ä¸´æ—¶æ•°ç»„ï¼Œç”¨æ¥ä¸´æ—¶å­˜å‚¨mergeåçš„æœ‰åºç»“æœ
    sort(nums,0,len(nums)-1)
    return nums
}

// sort å‡½æ•°å®šä¹‰ï¼šå¯¹æ•°ç»„numsèŒƒå›´[lo,hi]æ’åºï¼Œå¹¶ä½¿ä¹‹æœ‰åº
func sort(nums []int ,lo int,hi int) {
    if lo == hi { //å•ä¸ªå…ƒç´ å°±ä¸ç”¨æ’åºäº†
        return
    }
    mid := lo + (hi-lo)/2//å°†æ•°ç»„ä¸€åˆ†ä¸ºäºŒ
    sort(nums,lo,mid)//å¯¹å·¦è¾¹æ’åº
    sort(nums,mid+1,hi)//å¯¹å³è¾¹æ’åº
    merge(nums,lo,mid,hi) //åˆå¹¶å·¦å³ æœ‰åºæ•°ç»„
}

//åˆå¹¶æœ‰åºæ•°ç»„
func merge(nums []int,lo int ,mid int,hi int) {

    left := lo //å·¦è¾¹æœ‰åºæ•°ç»„èµ·å§‹ç‚¹
    right := mid+1//å³è¾¹æœ‰åºæ•°ç»„èµ·å§‹ç‚¹

    for i := lo;i <= hi;i++ { //æ€»å…±[lo,hi]ä¸ªå…ƒç´ 
        if left == mid+1 { //å·¦è¾¹å…¨éƒ¨éå†å®Œ
            temp[i] = nums[right]
            right++
        } else if right == hi+1 { //å³è¾¹å…¨éƒ¨éå†å®Œ
            temp[i] = nums[left]
            left++
        } else if nums[left] > nums[right]{ // ä¼˜å…ˆåˆå¹¶å°çš„å…ƒç´ 
            temp[i] = nums[right]
            right++
        } else {
            temp[i] = nums[left]
            left++
        }
    }
    //å°†ä¸´æ—¶æ•°ç»„ä¸­çš„æ•°ç»„tempï¼Œå¤åˆ¶åˆ° numsä¸­
    for i:= lo;i<=hi;i++{
        nums[i] = temp[i]
    }
}
```
> å †æ’åº

åˆ©ç”¨çš„ä¸‹æ²‰æ“ä½œsinkï¼Œå°†æ•°ç»„æœ€å¤§å…ƒç´ ç§»åŠ¨åˆ°æ•°ç»„é¦–éƒ¨ï¼Œç„¶åå’Œå°¾éƒ¨å…ƒç´ äº¤æ¢ï¼ˆå°¾éƒ¨å…ƒç´ å°±ä¸ç”¨å†ç®¡äº†ï¼Œå› ä¸ºå·²ç»æœ‰åºäº†ï¼‰æ­¤æ—¶å°¾éƒ¨å°±æ˜¯æœ€å¤§çš„å€¼ï¼›ç„¶åå¯¹å‰©ä¸‹çš„æ•°ç»„å…ƒç´ è¿›è¡Œä¸‹æ²‰æ“ä½œï¼›ä¿è¯æ¬¡å¤§çš„å…ƒç´ ï¼Œæˆä¸ºæ–°çš„é¦–éƒ¨å…ƒç´ ï¼›ç»§ç»­å’Œå°¾éƒ¨äº¤æ¢ï¼ˆæ³¨æ„è¿™é‡Œçš„å°¾éƒ¨ä¸æ˜¯æœ€åä¸€ä¸ªï¼Œæ˜¯å€’æ•°ç¬¬äºŒä¸ªäº†ï¼‰
![22909eaf-13a6-4cef-8203-80c6ab39010c.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411702057-22909eaf-13a6-4cef-8203-80c6ab39010c.png)


```go
func sortArray(nums []int) []int {
   
    length := len(nums)
  	// 1.ä¸€å¼€å§‹éœ€è¦é’ˆå¯¹æ•°ç»„ï¼Œè¿›è¡Œåˆå§‹åŒ–æ“ä½œ,ä»ç¬¬ä¸€ä¸ªéå¶å­èŠ‚ç‚¹å¼€å§‹
    for i := length/2-1;i >= 0;i-- {  // å€’ç€éå†
        sink(nums,i,length) 
    }
  	// 2.ä¸Šé¢åˆå§‹åŒ–å®Œæˆåï¼Œä¿è¯äº†æ•°ç»„ä¸­çš„æœ€å¤§å€¼ï¼Œå·²ç»æˆä¸ºæ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ 

    for i := length-1;i >= 0;i-- {
        // äº¤æ¢é¦–éƒ¨å’Œå°¾éƒ¨å…ƒç´ 
        nums[0],nums[i] = nums[i],nums[0]
        length-- // ä¸Šé¢äº¤æ¢ä»¥åï¼Œå°¾éƒ¨å…ƒç´ å°±æ˜¯æœ€å¤§çš„æœ‰åºå…ƒç´ äº†ï¼›åªéœ€è¦å¯¹å‰é¢å‰©ä½™çš„length-1é•¿åº¦çš„å…ƒç´ è¿›è¡Œæ’åºï¼Œéœ€è¦æ’åºçš„é•¿åº¦å˜çŸ­äº†ï¼Œè¿™ä¹Ÿå°±æ˜¯ä¸ºä»€ä¹ˆå€’åºéå†çš„åŸå› ï¼ˆå› ä¸ºæœ€åä¸€ä¸ªå…ƒç´ å·²ç»å¤„ç†å¥½äº†ï¼‰
        // å¯¹é¦–éƒ¨å…ƒç´ è¿›è¡Œä¸‹æ²‰æ“ä½œï¼ˆå› ä¸ºé¦–éƒ¨å…ƒç´ ç»è¿‡ä¸Šé¢çš„äº¤äº’ï¼Œå·²ç»å˜æˆäº†ä¸€ä¸ªæ–°å…ƒç´ ï¼Œä¸ä¸€å®šæ˜¯æ¬¡å¤§çš„å…ƒç´ ï¼‰
        sink(nums,0,length)
    }

    return nums
}


// ä¸‹æ²‰æ“ä½œï¼Œå°±æ˜¯æ¯”è¾ƒèŠ‚ç‚¹çš„å’Œå·¦å³èŠ‚ç‚¹çš„å¤§å°å…³ç³»ï¼›æ‰¾å‡ºä¸‰ä¸ªèŠ‚ç‚¹ä¸­çš„æœ€å¤§çš„ç´¢å¼•å€¼
func sink(nums []int ,idx ,len int) {
    for leftIdx(idx) < len { // ç›®çš„ï¼šå¦‚æœå·¦è¾¹çš„ç´¢å¼•éƒ½è¶Šç•Œäº†ï¼Œå³è¾¹çš„ç´¢å¼•è‚¯å®šä¹Ÿè¶Šç•Œäº†
        maxIdx := idx

        // æ³¨æ„ï¼šè¿™é‡Œçš„ç”¨çš„æ˜¯ nums[maxIdx]
        if leftIdx(idx) < len && nums[maxIdx] < nums[leftIdx(idx)] { // å·¦è¾¹çš„å…ƒç´ æ¯”è¾ƒå¤§
            maxIdx = leftIdx(idx)
        }   

        if rightIdx(idx) < len && nums[maxIdx] < nums[rightIdx(idx)] {
            maxIdx = rightIdx(idx)
        }

        // maxIdxçš„ç›®çš„ï¼šä¸ºäº†è®°å½•æœ€å¤§çš„ç´¢å¼•æ˜¯å“ªä¸ª
        if maxIdx == idx { // è¯´æ˜è‡ªå·±å°±æ˜¯æœ€å¤§çš„é‚£ä¸ªï¼Œä¸éœ€è¦ä¸‹æ²‰äº†(maxIdxåœ¨è¿™é‡Œæœ‰ç§æŒ‡é’ˆçš„æ„Ÿè§‰)
            break
        }

        // äº¤æ¢æ•°å€¼
        nums[maxIdx],nums[idx] = nums[idx],nums[maxIdx]
      	// ç»§ç»­è¿›è¡Œä¸‹æ²‰æ“ä½œ
        idx = maxIdx 
    }
}

func leftIdx(idx int) int {
    return idx *2 +1
}

func rightIdx(idx int) int {
    return idx*2+2
}
```
![eaa43067-0f75-4ad9-b885-8a19664b1d5e.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411702427-eaa43067-0f75-4ad9-b885-8a19664b1d5e.png)

## 21.åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨
å°†ä¸¤ä¸ªå‡åºé“¾è¡¨åˆå¹¶ä¸ºä¸€ä¸ªæ–°çš„ **å‡åº** é“¾è¡¨å¹¶è¿”å›ã€‚æ–°é“¾è¡¨æ˜¯é€šè¿‡æ‹¼æ¥ç»™å®šçš„ä¸¤ä¸ªé“¾è¡¨çš„æ‰€æœ‰èŠ‚ç‚¹ç»„æˆçš„ã€‚
![422d212d-a94d-423d-ac9b-16b3ea2583ce.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411702376-422d212d-a94d-423d-ac9b-16b3ea2583ce.png)

æ€è·¯ï¼š
è¿™ä¸ªç®—æ³•çš„é€»è¾‘ç±»ä¼¼äºã€Œæ‹‰æ‹‰é“¾ã€ï¼Œ`list1, list1` ç±»ä¼¼äºæ‹‰é“¾ä¸¤ä¾§çš„é”¯é½¿ï¼ŒæŒ‡é’ˆ `cur` å°±å¥½åƒæ‹‰é“¾çš„æ‹‰ç´¢ï¼Œå°†ä¸¤ä¸ªæœ‰åºé“¾è¡¨åˆå¹¶ã€‚
**ä»£ç ä¸­è¿˜ç”¨åˆ°ä¸€ä¸ªé“¾è¡¨çš„ç®—æ³•é¢˜ä¸­æ˜¯å¾ˆå¸¸è§çš„ã€Œè™šæ‹Ÿå¤´èŠ‚ç‚¹ã€æŠ€å·§ï¼Œä¹Ÿå°±æ˜¯ **`**dummy**`** èŠ‚ç‚¹**ï¼Œå®ƒç›¸å½“äºæ˜¯ä¸ªå ä½ç¬¦ï¼Œå¯ä»¥é¿å…å¤„ç†ç©ºæŒ‡é’ˆçš„æƒ…å†µï¼Œé™ä½ä»£ç çš„å¤æ‚æ€§ã€‚

```go
func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {
  	// 1.å®šä¹‰è™šæ‹Ÿå¤´ç»“ç‚¹
    var dummy *ListNode = &ListNode{Val : 0,Next:nil}
    cur := dummy
		
  	//2. å°†ä¸¤ä¸ªé“¾è¡¨ä¸­ï¼Œå€¼å°çš„ä¸€ä¸ªèŠ‚ç‚¹æ‹¼æ¥åˆ° cur åé¢
    for list1 != nil && list2 != nil {
        if list1.Val <= list2.Val {
            cur.Next = list1
            list1 = list1.Next
        } else {
            cur.Next = list2
            list2 = list2.Next
        }
         cur = cur.Next
    }
		//3. å‡å¦‚ä¸¤ä¸ªé“¾è¡¨ä¸€ä¸ªé•¿ or ä¸€ä¸ªçŸ­ï¼Œä¼šå¯¼è‡´å…¶ä¸­ä¸€ä¸ªé“¾è¡¨è¿˜æœ‰å‰©ä½™èŠ‚ç‚¹ï¼Œç›´æ¥æ‹¼æ¥åˆ°curåé¢å³å¯
    if list1 != nil {
        cur.Next = list1
    }

    if list2 != nil {
        cur.Next = list2
    }
		//4. è¿”å›dummyèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼Œæ‰æ˜¯è¦æ±‚çš„ç»“æœ
    return dummy.Next
}
```
## 5. æœ€é•¿å›æ–‡å­ä¸²
ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² `s`ï¼Œæ‰¾åˆ° `s` ä¸­æœ€é•¿çš„ å›æ–‡ å­ä¸²ã€‚
æ€è·¯ï¼š
**å¯»æ‰¾å›æ–‡ä¸²çš„é—®é¢˜æ ¸å¿ƒæ€æƒ³æ˜¯ï¼šä»ä¸­é—´å¼€å§‹å‘ä¸¤è¾¹æ‰©æ•£æ¥åˆ¤æ–­å›æ–‡ä¸²**

```go
for 0 <= i < len(s):
    æ‰¾åˆ°ä»¥ s[i] ä¸ºä¸­å¿ƒçš„å›æ–‡ä¸²
    æ›´æ–°ç­”æ¡ˆ
```
æ‰¾å›æ–‡ä¸²çš„å…³é”®æŠ€å·§æ˜¯ä¼ å…¥ä¸¤ä¸ªæŒ‡é’ˆ `l` å’Œ `r` å‘ä¸¤è¾¹æ‰©æ•£ï¼Œå› ä¸ºè¿™æ ·å®ç°å¯ä»¥åŒæ—¶å¤„ç†å›æ–‡ä¸²é•¿åº¦ä¸ºå¥‡æ•°å’Œå¶æ•°çš„æƒ…å†µã€‚

```go
for 0 <= i < len(s):
    // æ‰¾åˆ°ä»¥ s[i] ä¸ºä¸­å¿ƒçš„å›æ–‡ä¸²
    palindrome(s, i, i)
    // æ‰¾åˆ°ä»¥ s[i] å’Œ s[i+1] ä¸ºä¸­å¿ƒçš„å›æ–‡ä¸²
    palindrome(s, i, i + 1)
    æ›´æ–°ç­”æ¡ˆ
```
æ¯”å¦‚ `abba`çš„æœ€é•¿å›æ–‡å­ä¸²æ˜¯ `abba` å¦‚æœåªæ˜¯ä»¥ä¸€ä¸ªå­—ç¬¦`s[i]`ä½œä¸ºä¸­å¿ƒæŸ¥æ‰¾ï¼Œè¯¥å­—ç¬¦ä¸²æ˜¯æŸ¥ä¸åˆ°å›æ–‡ä¸²çš„ã€‚

```go
func longestPalindrome(s string) string {

	var result string

	for i := 0; i < len(s); i++ {

		s1 := isPalidrome(s, i, i)
		if len(s1) > len(result) {
			result = s1
		}

		s2 := isPalidrome(s, i, i+1)
		if len(s2) > len(result) {
			result = s2
		}
	}

	return result
}

func isPalidrome(s string, left, right int) string {

	for left >= 0 && right <= len(s)-1  && s[left] == s[right] {
			left--
			right++
	}
	return string(s[left+1 : right])
}
```
## 102. äºŒå‰æ ‘çš„å±‚åºéå†
ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„ **å±‚åºéå†** ã€‚ ï¼ˆå³é€å±‚åœ°ï¼Œä»å·¦åˆ°å³è®¿é—®æ‰€æœ‰èŠ‚ç‚¹ï¼‰ã€‚
![65619728-d2a7-4dce-8dfc-9ca5b04a048f.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411702630-65619728-d2a7-4dce-8dfc-9ca5b04a048f.png)

æ€è·¯ï¼š
è¿™é¢˜å°±æ˜¯å›ºå®šçš„è§£æ³•å¥—è·¯ï¼Œæ²¡æœ‰æŠ€å·§ï¼Œå…¨é è®°å¿†

```go
func levelOrder(root *TreeNode) [][]int {
    
    result := [][]int{}
  	//1. åˆ¤æ–­æ˜¯å¦ä¸ºç©ºæ ‘
    if root == nil {
        return result
    }
  	//2. å®šä¹‰æ•°ç»„ï¼Œä¿å­˜æ ¹èŠ‚ç‚¹
    saveKey := []*TreeNode{}
    saveKey = append(saveKey,root) 
		//3. åˆ¤æ–­æ˜¯å¦ä¸ºç©º
    for len(saveKey) != 0 { 
      	//4. ç¡®å®šæœ¬æ¬¡çš„è¾¹ç•Œ
        count := len(saveKey) 
        temp := []int{}
        for i := 0;i< count;i++ { 
          	//5.æŠŠè¾¹ç•Œå†…çš„æ•°å€¼å–å‡ºï¼Œå¹¶ä¿å­˜ä¸‹æ¥ã€‚
            temp = append(temp,saveKey[i].Val)
          	//6.æ³¨æ„è¿™é‡Œï¼Œä¸ä¸ºnilæ‰ä¿å­˜åˆ° saveKeyä¸­
            if saveKey[i].Left != nil {
                saveKey = append(saveKey,saveKey[i].Left)
            }
            if saveKey[i].Right != nil {
                saveKey = append(saveKey,saveKey[i].Right)
            }
        }
        result = append(result,temp)
      	//7.ä» countæˆªæ–­ saveKeyï¼Œå‰©ä¸‹çš„å°±æ˜¯ä¸‹å±‚çš„èŠ‚ç‚¹
        saveKey = saveKey[count:]
    }
    return result
}
```
## 1.ä¸¤æ•°ä¹‹å’Œ
ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums` å’Œä¸€ä¸ªæ•´æ•°ç›®æ ‡å€¼ `target`ï¼Œè¯·ä½ åœ¨è¯¥æ•°ç»„ä¸­æ‰¾å‡º **å’Œä¸ºç›®æ ‡å€¼**`*target*` çš„é‚£ **ä¸¤ä¸ª** æ•´æ•°ï¼Œå¹¶è¿”å›å®ƒä»¬çš„æ•°ç»„ä¸‹æ ‡ã€‚ä½ å¯ä»¥å‡è®¾æ¯ç§è¾“å…¥åªä¼šå¯¹åº”ä¸€ä¸ªç­”æ¡ˆï¼Œå¹¶ä¸”ä½ ä¸èƒ½ä½¿ç”¨ä¸¤æ¬¡ç›¸åŒçš„å…ƒç´ ã€‚ä½ å¯ä»¥æŒ‰ä»»æ„é¡ºåºè¿”å›ç­”æ¡ˆã€‚
æ€è·¯ï¼š

- ç®€å•è¯´ï¼Œæ•°ç»„å…¶å®å¯ä»¥ç†è§£ä¸ºä¸€ä¸ªã€Œç´¢å¼• -> å€¼ã€çš„å“ˆå¸Œè¡¨æ˜ å°„ï¼Œè€Œæˆ‘ä»¬åˆå»ºç«‹ä¸€ä¸ªã€Œå€¼ -> ç´¢å¼•ã€çš„æ˜ å°„å³å¯å®Œæˆæ­¤é¢˜ã€‚
```go
func twoSum(nums []int, target int) []int {
    //åˆ©ç”¨mapå®ç°
    m := make(map[int]int) //keyè¡¨ç¤ºæ•°å€¼ valueè¡¨ç¤ºç´¢å¼•å€¼
    
    for k,v := range nums {
      	// target-væŸ¥æ‰¾å“ˆå¸Œè¡¨ï¼Œåˆ¤æ–­æ˜¯å¦å·²ç»å­˜åœ¨è¯¥å€¼
        if index ,ok := m[target-v];ok {
            return []int{k,index}
        }
      	// ä¿å­˜ å€¼->ç´¢å¼•
        m[v] = k
    }
    return nil
}
```
## 33.æœç´¢æ—‹è½¬æ’åºæ•°ç»„
æ•´æ•°æ•°ç»„ `nums` æŒ‰å‡åºæ’åˆ—ï¼Œæ•°ç»„ä¸­çš„å€¼ **äº’ä¸ç›¸åŒ** ã€‚
åœ¨ä¼ é€’ç»™å‡½æ•°ä¹‹å‰ï¼Œ`nums` åœ¨é¢„å…ˆæœªçŸ¥çš„æŸä¸ªä¸‹æ ‡ `k`ï¼ˆ`0 <= k < nums.length`ï¼‰ä¸Šè¿›è¡Œäº† **æ—‹è½¬**ï¼Œä½¿æ•°ç»„å˜ä¸º `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`ï¼ˆä¸‹æ ‡ **ä» 0 å¼€å§‹** è®¡æ•°ï¼‰ã€‚ä¾‹å¦‚ï¼Œ `[0,1,2,4,5,6,7]` åœ¨ä¸‹æ ‡ `3` å¤„ç»æ—‹è½¬åå¯èƒ½å˜ä¸º `[4,5,6,7,0,1,2]` ã€‚
ç»™ä½  **æ—‹è½¬å** çš„æ•°ç»„ `nums` å’Œä¸€ä¸ªæ•´æ•° `target` ï¼Œå¦‚æœ `nums` ä¸­å­˜åœ¨è¿™ä¸ªç›®æ ‡å€¼ `target` ï¼Œåˆ™è¿”å›å®ƒçš„ä¸‹æ ‡ï¼Œå¦åˆ™è¿”å› `-1` ã€‚
ä½ å¿…é¡»è®¾è®¡ä¸€ä¸ªæ—¶é—´å¤æ‚åº¦ä¸º `O(log n)` çš„ç®—æ³•è§£å†³æ­¤é—®é¢˜ã€‚
æ€è·¯ï¼š

- é¢˜ç›®è¦æ±‚æ—¶é—´å¤æ‚åº¦`O(log n)` é‚£å°±è¦æƒ³åˆ°äºŒåˆ†æ³•![4108d890-54e7-4c17-8d49-b59527b96f10.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411702801-4108d890-54e7-4c17-8d49-b59527b96f10.png)


```go
func search(nums []int, target int) int {
    //ï¼ï¼ï¼ äºŒåˆ†æ³•æŸ¥æ‰¾ï¼›éœ€è¦ç”»å›¾ç†è§£
    left , right := 0,len(nums)-1
    for left <= right {
        mid := left + (right-left)/2

        if nums[mid] == target { // æ‰¾åˆ° target
            return mid
        } else if nums[left] <= nums[mid] { // è¯´æ˜ [left,mid] æ˜¯æœ‰åºé€’å¢çš„å­æ•°ç»„
            if nums[left] <= target && target < nums[mid]  {//2. target ä½äº [left,mid]æœ‰åºé€’å¢æ•°ç»„ä¸­
                right = mid-1 // æ”¶ç¼©å³è¾¹ç•Œï¼ˆå…¶å®å°±æ˜¯ä¸¢å¼ƒå³è¾¹çš„å­æ•°ç»„ï¼‰
            }else {
                left = mid+1
            }
        }else { //è¯´æ˜ [mid,right] æ˜¯æœ‰åºé€’å¢çš„å­æ•°ç»„
            if nums[mid] < target && target <= nums[right] { // targetä½äº [mid,right]æœ‰åºé€’å¢æ•°ç»„ä¸­
                left = mid+1  // æ”¶ç¼©å·¦è¾¹ç•Œï¼ˆå…¶å®å°±æ˜¯ä¸¢å¼ƒå·¦è¾¹çš„å­æ•°ç»„ï¼‰
            }else {
                right = mid-1
            }
        }
    }
    return -1
}
```
## 200.å²›å±¿æ•°é‡
ç»™ä½ ä¸€ä¸ªç”± `'1'`ï¼ˆé™†åœ°ï¼‰å’Œ `'0'`ï¼ˆæ°´ï¼‰ç»„æˆçš„çš„äºŒç»´ç½‘æ ¼ï¼Œè¯·ä½ è®¡ç®—ç½‘æ ¼ä¸­å²›å±¿çš„æ•°é‡ã€‚å²›å±¿æ€»æ˜¯è¢«æ°´åŒ…å›´ï¼Œå¹¶ä¸”æ¯åº§å²›å±¿åªèƒ½ç”±æ°´å¹³æ–¹å‘å’Œ/æˆ–ç«–ç›´æ–¹å‘ä¸Šç›¸é‚»çš„é™†åœ°è¿æ¥å½¢æˆã€‚æ­¤å¤–ï¼Œä½ å¯ä»¥å‡è®¾è¯¥ç½‘æ ¼çš„å››æ¡è¾¹å‡è¢«æ°´åŒ…å›´ã€‚
æ€è·¯ï¼š

- ç”¨ DFS ç®—æ³•è§£å†³å²›å±¿é¢˜ç›®æ˜¯æœ€å¸¸è§çš„ï¼Œæ¯æ¬¡é‡åˆ°ä¸€ä¸ªå²›å±¿ä¸­çš„é™†åœ°ï¼Œå°±ç”¨ DFS ç®—æ³•å§è¿™ä¸ªå²›å±¿ã€Œæ·¹æ‰ã€ã€‚
```go
func numIslands(grid [][]byte) int {
    m := len(grid)
    n := len(grid[0])
    result := 0
  	// å¯¹äºŒç»´æ•°ç»„è¿›è¡Œéå†
    for i := 0;i < m;i++ {
        for j := 0;j < n ;j++ {
          	// ä¸€æ—¦å‘ç°ä¸€ä¸ªé™†åœ°
            if grid[i][j] == '1' { 
                result++
              	// å°±å°†å’Œè¯¥ grid[i][j] é™†åœ°ç›¸è¿æ¥çš„é™†åœ°ï¼Œå…¨éƒ¨æ·¹æ²¡æ‰
                dfs(grid,i,j)
            }
        }
    }

    return result
}

// æ·±åº¦ä¼˜å…ˆç®—æ³•ï¼Œ
func dfs(grid [][]byte,i,j int) {
    m := len(grid)
    n := len(grid[0])
    if i < 0 || j < 0 || i >= m || j >= n { //è¶Šç•Œæ£€æµ‹
        return
    }
		// è¯´æ˜å½“å‰æ˜¯æ°´
    if grid[i][j] == '0' {
        return
    }
  	// æ‰§è¡Œåˆ°è¿™é‡Œï¼Œè¯´æ˜ä½ æ˜¯é™†åœ°
    grid[i][j] = '0' //æ·¹æ²¡æ‰é™†åœ°
    dfs(grid,i-1,j) //ä¸Š
    dfs(grid,i+1,j) //ä¸‹ 
    dfs(grid,i,j+1) //å³
    dfs(grid,i,j-1) //å·¦
}
```
## 121.ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº
ç»™å®šä¸€ä¸ªæ•°ç»„ `prices` ï¼Œå®ƒçš„ç¬¬ `i` ä¸ªå…ƒç´  `prices[i]` è¡¨ç¤ºä¸€æ”¯ç»™å®šè‚¡ç¥¨ç¬¬ `i` å¤©çš„ä»·æ ¼ã€‚ä½ åªèƒ½é€‰æ‹© **æŸä¸€å¤©** ä¹°å…¥è¿™åªè‚¡ç¥¨ï¼Œå¹¶é€‰æ‹©åœ¨ **æœªæ¥çš„æŸä¸€ä¸ªä¸åŒçš„æ—¥å­** å–å‡ºè¯¥è‚¡ç¥¨ã€‚è®¾è®¡ä¸€ä¸ªç®—æ³•æ¥è®¡ç®—ä½ æ‰€èƒ½è·å–çš„æœ€å¤§åˆ©æ¶¦ã€‚
è¿”å›ä½ å¯ä»¥ä»è¿™ç¬”äº¤æ˜“ä¸­è·å–çš„æœ€å¤§åˆ©æ¶¦ã€‚å¦‚æœä½ ä¸èƒ½è·å–ä»»ä½•åˆ©æ¶¦ï¼Œè¿”å› `0` ã€‚
æ€è·¯ï¼š
ä¹°å–è‚¡ç¥¨ç±»çš„é¢˜ç›®æœ‰ä¸€å¥—**é€šç”¨çš„è§£é¢˜æ–¹æ¡ˆ**ï¼š

- `dp`æ•°ç»„å®šä¹‰ï¼š> `dp[i][k][0 or 1]`
`0 <= i <= n - 1, 1 <= k <= K`
n ä¸ºå¤©æ•°ï¼Œå¤§ K ä¸ºå®Œæˆäº¤æ˜“æ•°çš„ä¸Šé™ï¼Œ0 å’Œ 1 ä»£è¡¨æ˜¯å¦æŒæœ‰è‚¡ç¥¨

æ‰€ä»¥ï¼Œ`dp[i][k][0 or 1]` çš„å«ä¹‰å°±æ˜¯ï¼šåœ¨ä» `0`åˆ° `i`å¤©ï¼Œå®Œæˆäº†`k`ç¬”äº¤æ˜“ï¼Œä¸æŒæœ‰`0` or æŒæœ‰ `1`è‚¡ç¥¨ï¼Œèƒ½è·å–çš„æœ€å¤§åˆ©æ¶¦

- `dp`çš„é€’æ¨å…³ç³»å®šä¹‰ï¼š
```go
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
//dp[i][k][0] è¡¨ç¤º ä» 0 åˆ° ç¬¬iå¤©ï¼Œå®Œæˆkç¬”äº¤æ˜“ï¼Œä¸æŒæœ‰è‚¡ç¥¨ï¼Œèƒ½è·å–çš„æœ€å¤§åˆ©æ¶¦
åˆ†æˆä¸¤ç§æƒ…å†µï¼š
// dp[i-1][k][0] 								è¡¨ç¤º ä» 0 åˆ°i-1å¤©ï¼ˆä¹Ÿå°±æ˜¯å‰ä¸€å¤©ï¼‰ï¼Œä¹Ÿæ²¡æœ‰æŒæœ‰è‚¡ç¥¨
// dp[i-1][k][1] + prices[i]  	è¡¨ç¤º ä» 0 åˆ°i-1å¤©ï¼ˆä¹Ÿå°±æ˜¯å‰ä¸€å¤©ï¼‰ï¼ŒæŒæœ‰äº†è‚¡ç¥¨ï¼Œä½†æ˜¯ä»Šå¤©é€‰æ‹©å–å‡ºï¼Œé‚£ä¹ˆä»Šå¤©ä¸å°±ä¸æŒæœ‰è‚¡ç¥¨äº†


dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
// dp[i][k][1]  è¡¨ç¤ºä» 0 åˆ°ç¬¬iå¤©ï¼Œå®Œæˆkç¬”äº¤æ˜“ï¼ŒæŒæœ‰è‚¡ç¥¨ï¼Œèƒ½è·å–çš„æœ€å¤§åˆ©æ¶¦
åˆ†æˆä¸¤ç§æƒ…å†µï¼š
// dp[i-1][k][1] 							 	è¡¨ç¤ºä» 0 åˆ° i-1å¤©ï¼ˆä¹Ÿå°±æ˜¯å‰ä¸€å¤©ï¼‰ï¼Œä¹ŸæŒæœ‰è‚¡ç¥¨
// dp[i-1][k-1][0] - prices[i] 	è¡¨ç¤ºä» 0 åˆ° i-1å¤©ï¼ˆä¹Ÿå°±æ˜¯å‰ä¸€å¤©ï¼‰ï¼ŒæœªæŒæœ‰äº†è‚¡ç¥¨ï¼Œä½†æ˜¯ä»Šå¤©é€‰æ‹©ä¹°å…¥ï¼Œé‚£ä¹ˆä¸å°±æŒæœ‰è‚¡ç¥¨äº†ã€‚å› ä¸ºæ˜¯ä»Šå¤©ä¹°å…¥è‚¡ç¥¨ï¼Œå®Œæˆäº†ä¸€ç¬”äº¤æ˜“ï¼Œä»Šå¤©çš„äº¤æ˜“æ¬¡æ•°æ˜¯kçš„å‰æä¸‹ï¼Œé‚£ä¹ˆå‰ä¸€å¤©çš„äº¤æ˜“æ¬¡æ•°å°±æ˜¯ k-1


æœ€ç»ˆç­”æ¡ˆï¼šå› ä¸ºè¦æ±‚æœ€å¤§åˆ©æ¶¦ï¼Œé‚£åªæœ‰ä¸æŒæœ‰è‚¡ç¥¨çš„åˆ©æ¶¦æœ€å¤§ dp[n-1][k][0] ï¼ˆä» 0åˆ° n-1ï¼Œå®Œæˆäº†kç¬”äº¤æ˜“åï¼Œä¸æŒæœ‰è‚¡ç¥¨ï¼‰
```
æœ¬é¢˜ç­”æ¡ˆï¼š
æ³¨æ„ç†è§£è¿™å¥è¯çš„å«ä¹‰ï¼šã€ä½ åªèƒ½é€‰æ‹© **æŸä¸€å¤©** ä¹°å…¥è¿™åªè‚¡ç¥¨ï¼Œå¹¶é€‰æ‹©åœ¨ **æœªæ¥çš„æŸä¸€ä¸ªä¸åŒçš„æ—¥å­** å–å‡ºè¯¥è‚¡ç¥¨ã€‘ï¼Œæ„æ€å°±æ˜¯åªè¿›è¡Œä¸€æ¬¡äº¤æ˜“ï¼Œèƒ½è·å–çš„æœ€å¤§åˆ©æ¶¦æ˜¯å¤šå°‘ã€‚ï¼ˆä¸éœ€è¦è€ƒè™‘ä¹‹å‰çš„å†å²äº¤æ˜“è¡Œä¸ºï¼Œå› ä¸ºåªæœ‰ä¸€æ¬¡äº¤æ˜“ï¼Œé‚£ä¹Ÿå°±æ˜¯æ²¡æœ‰å…¶ä»–çš„å†å²äº¤æ˜“è¡Œä¸ºï¼‰

- å¯¹äºä¸Šé¢çš„`dp`é€’æ¨æ¨¡æ¿ï¼Œå¯ä»¥çœç•¥ `k`ï¼Œå› ä¸ºåªæœ‰ä¸€æ¬¡äº¤æ˜“
- `dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])`å¯¹äºè¿™ä¸ªé€’æ¨å…³ç³»ï¼Œæˆ‘ä»¬éœ€è¦å»æ‰`dp[i-1][k-1][0]`ï¼Œå°†é€’æ¨å…³ç³»å˜ä¸ºï¼š`dp[i][k][1] = max(dp[i-1][k][1], - prices[i])`ï¼Œå› ä¸ºå¸¦ä¸Š`dp[i-1][k-1][0]`å°±è¡¨ç¤ºè¦è€ƒè™‘ä¹‹å‰çš„å†å²äº¤æ˜“è¡Œä¸ºã€‚å¦‚æœæƒ³ä¸æ˜ç™½ä¸ºä»€ä¹ˆï¼Œå…ˆç†è§£ä¸‹`dp`çš„å®šä¹‰ï¼šè¡¨ç¤ºä» 0 åˆ° i-1å¤©ï¼ˆä¹Ÿå°±æ˜¯å‰ä¸€å¤©ï¼‰ï¼ŒæœªæŒæœ‰äº†è‚¡ç¥¨ï¼ˆä¸ºå•¥æ²¡æœ‰æŒæœ‰è‚¡ç¥¨ï¼Ÿå¯èƒ½æ˜¯å› ä¸ºæœ¬æ¥å°±æ²¡æœ‰æŒæœ‰è¿‡ï¼Œä¹Ÿå¯èƒ½æ˜¯ä¹‹å‰æŒæœ‰äº†ï¼Œåˆ°äº†ç¬¬`i-1`å¤©å–æ‰äº†ï¼Œç­‰ä»·äºæ²¡æœ‰æŒæœ‰äº†ï¼‰ï¼Œå¦‚æœæ˜¯ç¬¬äºŒç§å–æ‰äº†ï¼Œå¯¼è‡´çš„æ²¡æœ‰æŒæœ‰ï¼Œè¯´æ˜ä¹‹å‰æœ‰è¿‡å†å²çš„äº¤æ˜“è¡Œä¸ºã€‚é‚£å°±ä¸èƒ½ç®—æ˜¯é¢˜ç›®é™å®šçš„ï¼Œåªèƒ½æœ‰ä¸€æ¬¡äº¤æ˜“è¡Œä¸ºäº†ã€‚
```go
func maxProfit(prices []int) int {
  	// 1. æ„å»ºäºŒç»´ dpæ•°ç»„
    n := len(prices) //nå¤©
    dp := make([][]int,n)
    for k,_ := range dp {
        // æ¯å¤©åªæœ‰ä¸¤ç§é€‰æ‹© ã€0ä¸æŒæœ‰ 1æŒæœ‰ã€‘
        dp[k] = make([]int,2)
    }

    //çŠ¶æ€è½¬ç§»æ–¹ç¨‹
    /*
        dp[i][0 or 1] è¡¨ç¤ºåˆ°ç¬¬iå¤©æ—¶å€™ï¼Œé€‰æ‹©ï¼ˆæŒæœ‰æˆ–ä¸æŒæœ‰è‚¡ç¥¨ï¼‰èƒ½è·å–åˆ°çš„æœ€å¤§åˆ©æ¶¦ï¼›
        dp[i][0] = max(dp[i-1][0], dp[i-1][1] + price[i]) // å–å‡º
        dp[i][1] = max(dp[i-1][1], -price[i]) //ä¹°å…¥
    */

    for i := 0;i < n; i++ {
      	//2. ç‰¹æ®Šå¤„ç†
        if i - 1 == -1 {
            dp[i][0] = 0
            dp[i][1] = -prices[i]
        } else {
            dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
            // æ ¸å¿ƒåœ¨äºï¼šåªèƒ½æœ‰ä¸€æ¬¡ä¹°å–è¡Œä¸ºï¼›åœ¨ç¬¬iå¤©æŒæœ‰è‚¡ç¥¨ï¼Œé‚£è¯´æ˜ä¹‹å‰å°±ä¸€ç›´æŒæœ‰ dp[i-1][1]
            // æˆ–è€…ï¼Œä¹‹å‰ä¸€ç›´éƒ½æ²¡æœ‰æŒæœ‰ï¼Œä»Šå¤©ç¬¬iå¤©æ˜¯ã€ç¬¬ä¸€æ¬¡ã€‘äº¤æ˜“è¡Œä¸ºï¼›
            // å¦‚æœå¸¦ä¸Š dp[i-1][0] è¡¨ç¤ºï¼šæœ‰è€ƒè™‘ä¹‹å‰çš„å†å²äº¤æ˜“è¡Œä¸ºï¼ˆé¢˜ç›®é™å®šåªæœ‰ä¸€æ¬¡äº¤æ˜“è¡Œä¸ºï¼‰
            dp[i][1] = max(dp[i-1][1], -prices[i]) 
        }
    }
		//å› ä¸ºè¦æ±‚æœ€å¤§åˆ©æ¶¦ï¼Œé‚£è‚¯å®šæ˜¯ä¸æŒæœ‰æœ€å¤§åˆ©æ¶¦æœ€å¤§
    return dp[n-1][0] 
}

func max( a,b int) int {
    if a > b {
        return a
    }
    return b
}
```
## 46.å…¨æ’åˆ—
ç»™å®šä¸€ä¸ªä¸å«é‡å¤æ•°å­—çš„æ•°ç»„ `nums` ï¼Œè¿”å›å…¶ *æ‰€æœ‰å¯èƒ½çš„å…¨æ’åˆ—* ã€‚ä½ å¯ä»¥ **æŒ‰ä»»æ„é¡ºåº** è¿”å›ç­”æ¡ˆã€‚

```go
ç¤ºä¾‹1:
è¾“å…¥ï¼šnums = [1,2,3]
è¾“å‡ºï¼š[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```
æ€è·¯ï¼š

- å¯ä»¥å‚è€ƒä¸‹ğŸ‘†å›æº¯ç®—æ³•è§£é¢˜æ¨¡æ¿å› ä¸ºæ˜¯æ±‚æ’åˆ—ï¼Œæ¯é€‰æ‹©ä¸€ä¸ªå…ƒç´ åï¼Œä¸‹ä¸€ä¸ª `backtrack`ä»**æ‰€æœ‰çš„å…ƒç´ **ä¸­ï¼ˆæ‰€ä»¥ä¸éœ€è¦ `start`æ¥åœˆå®šé€‰æ‹©èŒƒå›´ï¼‰å†é€‰æ‹©ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œä¸ºäº†é¿å…åŒä¸€ä¸ªå…ƒç´ é‡å¤è¢«é€‰ä¸­ï¼Œç”¨`used`è®°å½•å…ƒç´ æ˜¯å¦å·²ç»è¢«é€‰è¿‡ã€‚

```go
var result [][]int
func permute(nums []int) [][]int {
    result = [][]int{} //æ¸…ç©ºç»“æœ
  	// è®°å½•æ˜¯å¦å·²ç»ä½¿ç”¨è¿‡
    used := make([]bool,len(nums))
    trace := make([]int,0)
  	//å›æº¯ç®—æ³•
    backtrack(nums,trace,used)
    return result
}

//å›æº¯ç®—æ³•
func backtrack (nums []int,trace []int , used []bool)  {

    if len(trace) == len(nums) { //traceè®°å½•è·¯å¾„
        temp := make([]int,len(trace)) //golang è¿™ä¸ªè¦æ³¨æ„ï¼Œåˆ‡ç‰‡éœ€è¦å¤åˆ¶ä¸€ä¸ªå‡ºæ¥
        copy(temp,trace)
        result = append(result,temp)
        return
    }
    // æ’åˆ—ï¼Œæ¯æ¬¡éƒ½ä»å¤´å¼€å§‹é€‰æ‹©
    for i := 0;i < len(nums);i++ {
        
        if used[i] { //å½“å‰å€¼å·²ç»é€‰æ‹©è¿‡äº†ï¼Œè·³è¿‡
            continue
        }

        trace = append(trace,nums[i]) //é€‰æ‹©
        used[i] = true

        backtrack(nums,trace,used)

        trace = trace[:len(trace)-1]//æ’¤é”€é€‰æ‹©
        used[i] = false
    } 

}
```
## 88.åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„
ç»™ä½ ä¸¤ä¸ªæŒ‰ **éé€’å‡é¡ºåº** æ’åˆ—çš„æ•´æ•°æ•°ç»„ `nums1` å’Œ `nums2`ï¼Œå¦æœ‰ä¸¤ä¸ªæ•´æ•° `m` å’Œ `n` ï¼Œåˆ†åˆ«è¡¨ç¤º `nums1` å’Œ `nums2` ä¸­çš„å…ƒç´ æ•°ç›®ã€‚è¯·ä½  **åˆå¹¶**`nums2` åˆ° `nums1` ä¸­ï¼Œä½¿åˆå¹¶åçš„æ•°ç»„åŒæ ·æŒ‰ **éé€’å‡é¡ºåº** æ’åˆ—ã€‚
**æ³¨æ„ï¼š**æœ€ç»ˆï¼Œåˆå¹¶åæ•°ç»„ä¸åº”ç”±å‡½æ•°è¿”å›ï¼Œè€Œæ˜¯å­˜å‚¨åœ¨æ•°ç»„ `nums1` ä¸­ã€‚ä¸ºäº†åº”å¯¹è¿™ç§æƒ…å†µï¼Œ`nums1` çš„åˆå§‹é•¿åº¦ä¸º `m + n`ï¼Œå…¶ä¸­å‰ `m` ä¸ªå…ƒç´ è¡¨ç¤ºåº”åˆå¹¶çš„å…ƒç´ ï¼Œå `n` ä¸ªå…ƒç´ ä¸º `0` ï¼Œåº”å¿½ç•¥ã€‚`nums2` çš„é•¿åº¦ä¸º `n` ã€‚
æ€è·¯ï¼š

- å¾ˆåƒå‰æ–‡ä¸­è®²è¿‡çš„ [21. åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨](https://leetcode.cn/problems/merge-two-sorted-lists)ï¼Œè¿™é‡Œè®©ä½ åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„ã€‚
- å¯¹äºå•é“¾è¡¨æ¥è¯´ï¼Œæˆ‘ä»¬ç›´æ¥ç”¨åŒæŒ‡é’ˆä»å¤´å¼€å§‹åˆå¹¶å³å¯ï¼Œä½†å¯¹äºæ•°ç»„æ¥è¯´ä¼šå‡ºé—®é¢˜ã€‚å› ä¸ºé¢˜ç›®è®©æˆ‘ç›´æ¥æŠŠç»“æœå­˜åˆ° `nums1` ä¸­ï¼Œè€Œ `nums1` çš„å¼€å¤´æœ‰å…ƒç´ ï¼Œå¦‚æœæˆ‘ä»¬æ— è„‘å¤åˆ¶å•é“¾è¡¨çš„é€»è¾‘ï¼Œä¼šè¦†ç›–æ‰ `nums1` çš„åŸå§‹å…ƒç´ ï¼Œå¯¼è‡´é”™è¯¯ã€‚ä½† `nums1` åé¢æ˜¯ç©ºçš„å‘€ï¼Œæ‰€ä»¥è¿™é“é¢˜éœ€è¦æˆ‘ä»¬ç¨å¾®å˜é€šä¸€ä¸‹ï¼š**å°†åŒæŒ‡é’ˆåˆå§‹åŒ–åœ¨æ•°ç»„çš„å°¾éƒ¨ï¼Œç„¶åä»åå‘å‰è¿›è¡Œåˆå¹¶**ï¼Œè¿™æ ·å³ä¾¿è¦†ç›–äº† `nums1` ä¸­çš„å…ƒç´ ï¼Œè¿™äº›å…ƒç´ ä¹Ÿå¿…ç„¶æ—©å°±è¢«ç”¨è¿‡äº†ï¼Œä¸ä¼šå½±å“ç­”æ¡ˆçš„æ­£ç¡®æ€§ã€‚
```go
func merge(nums1 []int, m int, nums2 []int, n int)  {
    //åŒæŒ‡é’ˆï¼šä»æ•°ç»„çš„å°¾éƒ¨ï¼Œå‘å‰åˆå¹¶
    left,right := m-1,n-1 //éƒ½æŒ‡å‘å°¾éƒ¨
    pos := m+n-1
    for left >= 0 && right >= 0 {
        if nums1[left] >= nums2[right] { // é€‰æ‹©å¤§çš„ï¼Œæ”¾å…¥å°¾éƒ¨
            nums1[pos] = nums1[left]
            pos--
            left--
        } else {
            nums1[pos] = nums2[right]
            pos--
            right--
        }
    }
  	// right è¿˜æœ‰å‰©ä½™ï¼Œç›´æ¥å¤åˆ¶
    for right >=0 {
        nums1[pos] = nums2[right]
        pos--
        right--
    }
    return 
}
```
## 20.æœ‰æ•ˆçš„æ‹¬å·
ç»™å®šä¸€ä¸ªåªåŒ…æ‹¬ `'('`ï¼Œ`')'`ï¼Œ`'{'`ï¼Œ`'}'`ï¼Œ`'['`ï¼Œ`']'` çš„å­—ç¬¦ä¸² `s` ï¼Œåˆ¤æ–­å­—ç¬¦ä¸²æ˜¯å¦æœ‰æ•ˆã€‚
æœ‰æ•ˆå­—ç¬¦ä¸²éœ€æ»¡è¶³ï¼š

1. å·¦æ‹¬å·å¿…é¡»ç”¨ç›¸åŒç±»å‹çš„å³æ‹¬å·é—­åˆã€‚
2. å·¦æ‹¬å·å¿…é¡»ä»¥æ­£ç¡®çš„é¡ºåºé—­åˆã€‚
3. æ¯ä¸ªå³æ‹¬å·éƒ½æœ‰ä¸€ä¸ªå¯¹åº”çš„ç›¸åŒç±»å‹çš„å·¦æ‹¬å·ã€‚æ€è·¯ï¼š

- æ ˆæ˜¯ä¸€ç§å…ˆè¿›åå‡ºçš„æ•°æ®ç»“æ„ï¼Œå¤„ç†æ‹¬å·é—®é¢˜çš„æ—¶å€™å°¤å…¶æœ‰ç”¨ã€‚
- å‡è®¾å­—ç¬¦ä¸²ä¸­åªæœ‰åœ†æ‹¬å· **ï¼ˆï¼‰**ï¼Œå¦‚æœæƒ³è®©æ‹¬å·å­—ç¬¦ä¸²æœ‰æ•ˆï¼Œé‚£ä¹ˆå¿…é¡»åšåˆ°ï¼š**æ¯ä¸ªå³æ‹¬å· **`**)**`** çš„å·¦è¾¹å¿…é¡»æœ‰ä¸€ä¸ªå·¦æ‹¬å· **`**(**`** å’Œå®ƒåŒ¹é…**ã€‚
æ¯”å¦‚è¯´å­—ç¬¦ä¸² `()))((` ä¸­ï¼Œä¸­é—´çš„ä¸¤ä¸ªå³æ‹¬å·**å·¦è¾¹**å°±æ²¡æœ‰å·¦æ‹¬å·åŒ¹é…ï¼Œæ‰€ä»¥è¿™ä¸ªæ‹¬å·ç»„åˆæ˜¯æ— æ•ˆçš„ã€‚

- åˆ©ç”¨æ ˆï¼Œä¿è¯å®ŒæˆåŒ¹é…çš„æ‹¬å·ï¼Œä¸ä¼šå­˜åœ¨åœ¨æ ˆä¸­ï¼Œæœ€åæ ˆä¸­å‰©ä¸‹çš„å°±æ˜¯æ²¡æœ‰å®ŒæˆåŒ¹é…çš„ï¼›
```go
func isValid(s string) bool {
  	// åˆå§‹
    stack := make([]byte,0)
  	// éå†å­—ç¬¦
    for i := 0;i< len(s);i++ {  
      	// å¦‚æœæ ˆä¸ä¸ºç©ºï¼Œåˆ¤æ–­æ ˆé¡¶æ‹¬å· å’Œ å½“å‰æ‹¬å·æ˜¯å¦åŒ¹é…
        if len(stack) != 0 && isPair(stack[len(stack)-1],s[i]) {
            stack = stack[:len(stack)-1] // å‡ºæ ˆ
        } else {
            stack = append(stack,s[i]) // å¦åˆ™ï¼Œå½“å‰çš„æ‹¬å·æ‰èƒ½å…¥æ ˆ
        }
    }
  	// æ ˆä¸ºç©ºï¼Œè¯´æ˜æ‹¬å·éƒ½å®Œå…¨åŒ¹é…
    if len(stack) == 0 {
        return true
    }
  	// æ¯”å¦‚ ({)}
    return false
}

func isPair(a,b byte) bool {
    if a == '(' && b == ')' {
        return true
    }

    if a == '[' && b == ']' {
        return true
    }

    if a == '{' && b == '}' {
        return true
    }

    return false
}
```
## 141.ç¯å½¢é“¾è¡¨
ç»™ä½ ä¸€ä¸ªé“¾è¡¨çš„å¤´èŠ‚ç‚¹ `head` ï¼Œåˆ¤æ–­é“¾è¡¨ä¸­æ˜¯å¦æœ‰ç¯ã€‚
å¦‚æœé“¾è¡¨ä¸­æœ‰æŸä¸ªèŠ‚ç‚¹ï¼Œå¯ä»¥é€šè¿‡è¿ç»­è·Ÿè¸ª `next` æŒ‡é’ˆå†æ¬¡åˆ°è¾¾ï¼Œåˆ™é“¾è¡¨ä¸­å­˜åœ¨ç¯ã€‚ ä¸ºäº†è¡¨ç¤ºç»™å®šé“¾è¡¨ä¸­çš„ç¯ï¼Œè¯„æµ‹ç³»ç»Ÿå†…éƒ¨ä½¿ç”¨æ•´æ•° `pos` æ¥è¡¨ç¤ºé“¾è¡¨å°¾è¿æ¥åˆ°é“¾è¡¨ä¸­çš„ä½ç½®ï¼ˆç´¢å¼•ä» 0 å¼€å§‹ï¼‰ã€‚**æ³¨æ„ï¼š**`**pos**`** ä¸ä½œä¸ºå‚æ•°è¿›è¡Œä¼ é€’** ã€‚ä»…ä»…æ˜¯ä¸ºäº†æ ‡è¯†é“¾è¡¨çš„å®é™…æƒ…å†µã€‚
*å¦‚æœé“¾è¡¨ä¸­å­˜åœ¨ç¯* ï¼Œåˆ™è¿”å› `true` ã€‚ å¦åˆ™ï¼Œè¿”å› `false` ã€‚
![ac054cb1-e8c4-45a5-8c30-e0334152f124.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411702758-ac054cb1-e8c4-45a5-8c30-e0334152f124.png)

æ€è·¯ï¼š
ç»å…¸é¢˜ç›®äº†ï¼Œä½¿ç”¨åŒæŒ‡é’ˆæŠ€å·§ä¸­çš„å¿«æ…¢æŒ‡é’ˆï¼Œæ¯å½“æ…¢æŒ‡é’ˆ `slow` å‰è¿›ä¸€æ­¥ï¼Œå¿«æŒ‡é’ˆ `fast` å°±å‰è¿›ä¸¤æ­¥ã€‚å¦‚æœ `fast` æœ€ç»ˆé‡åˆ°ç©ºæŒ‡é’ˆï¼Œè¯´æ˜é“¾è¡¨ä¸­æ²¡æœ‰ç¯ï¼›å¦‚æœ `fast` æœ€ç»ˆå’Œ `slow` ç›¸é‡ï¼Œé‚£è‚¯å®šæ˜¯ `fast` è¶…è¿‡äº† `slow` ä¸€åœˆï¼Œè¯´æ˜é“¾è¡¨ä¸­å«æœ‰ç¯ã€‚

```go
func hasCycle(head *ListNode) bool {
    //å¿«æ…¢æŒ‡é’ˆ
    slow,fast := head,head
  	// è¡¨ç¤º fast èƒ½å¤Ÿè·³è·ƒä¸¤æ­¥ã€‚å¦‚æœ fast == nil(ç©ºèŠ‚ç‚¹) æˆ–è€… fast.Next == nilï¼ˆåªæœ‰fastè¿™ä¸€ä¸ªèŠ‚ç‚¹ï¼Œæ²¡æœ‰åç»­èŠ‚ç‚¹ï¼‰
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        if slow == fast {
            return true
        }
    }
    return false
}
```
## 103.äºŒå‰æ ‘çš„é”¯é½¿å½¢å±‚åºéå†
ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„ **é”¯é½¿å½¢å±‚åºéå†** ã€‚ï¼ˆå³å…ˆä»å·¦å¾€å³ï¼Œå†ä»å³å¾€å·¦è¿›è¡Œä¸‹ä¸€å±‚éå†ï¼Œä»¥æ­¤ç±»æ¨ï¼Œå±‚ä¸å±‚ä¹‹é—´äº¤æ›¿è¿›è¡Œï¼‰ã€‚
æ€è·¯ï¼š

- è¿™é¢˜å’Œä¸Šé¢çš„å±‚åºéå†æ˜¯ä¸€æ ·çš„ï¼Œåªæ˜¯å¤šäº†ä¸€ä¸ªå…ƒç´ å€¼å­˜å‚¨çš„æ–¹å‘çš„æ§åˆ¶ `flag`
```go
func zigzagLevelOrder(root *TreeNode) [][]int {

    result := [][]int{}
  	// ç©ºæ ‘
    if root == nil {
        return result
    }

    //å’Œå±‚åºéå†ä¸€æ ·
    nodes := []*TreeNode{}
    nodes = append(nodes,root)

    flag := true //æ§åˆ¶ç»“æœ æ”¾å…¥çš„æ–¹å‘

    for len(nodes) != 0 {
        count := len(nodes) // èŠ‚ç‚¹æ•°é‡

        temp := []int{}
        for i := 0;i < count;i++ {  

            if flag { // ä¿å­˜åœ¨å°¾éƒ¨ï¼ˆæ­£åºï¼‰
                temp = append(temp,nodes[i].Val)
            } else {
              	// ä¿å­˜åœ¨å¤´éƒ¨ï¼ˆå€’åºï¼‰
                temp = append([]int{nodes[i].Val},temp...)
            }

            // leftä¸ä¸ºç©º
            if nodes[i].Left != nil {
                nodes = append(nodes,nodes[i].Left)
            }
						// right ä¸ä¸ºç©º
            if nodes[i].Right != nil {
                nodes = append(nodes,nodes[i].Right)
            }
        }
      	// åˆ‡æ¢æ–¹å‘
        flag = !flag
        result = append(result,temp)
        nodes = nodes[count:] //countä¹‹å‰çš„éœ€è¦èˆå¼ƒ
    }
    return result
}
```
## 235.äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ
ç»™å®šä¸€ä¸ªäºŒå‰æ ‘, æ‰¾åˆ°è¯¥æ ‘ä¸­ä¸¤ä¸ªæŒ‡å®šèŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚
[ç™¾åº¦ç™¾ç§‘](https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin)ä¸­æœ€è¿‘å…¬å…±ç¥–å…ˆçš„å®šä¹‰ä¸ºï¼šâ€œå¯¹äºæœ‰æ ¹æ ‘ T çš„ä¸¤ä¸ªèŠ‚ç‚¹ pã€qï¼Œæœ€è¿‘å…¬å…±ç¥–å…ˆè¡¨ç¤ºä¸ºä¸€ä¸ªèŠ‚ç‚¹ xï¼Œæ»¡è¶³ x æ˜¯ pã€q çš„ç¥–å…ˆä¸” x çš„æ·±åº¦å°½å¯èƒ½å¤§ï¼ˆ**ä¸€ä¸ªèŠ‚ç‚¹ä¹Ÿå¯ä»¥æ˜¯å®ƒè‡ªå·±çš„ç¥–å…ˆ**ï¼‰ã€‚
æ€è·¯ï¼š

- ç»™å‡ºé€’å½’å‡½æ•°çš„å®šä¹‰ï¼šç»™è¯¥å‡½æ•°è¾“å…¥ä¸‰ä¸ªå‚æ•° `root`ï¼Œ`p`ï¼Œ`q`ï¼Œå®ƒä¼šè¿”å›ä¸€ä¸ªèŠ‚ç‚¹ï¼š
- æƒ…å†µ 1ï¼Œå¦‚æœ `p` å’Œ `q` éƒ½åœ¨ä»¥ `root` ä¸ºæ ¹çš„æ ‘ä¸­ï¼Œé‚£ä¹ˆ `left` å’Œ `right` ä¸€å®šåˆ†åˆ«æ˜¯ `p` å’Œ `q`ã€‚
- æƒ…å†µ 2ï¼Œå¦‚æœ `p` å’Œ `q` éƒ½ä¸åœ¨ä»¥ `root` ä¸ºæ ¹çš„æ ‘ä¸­ï¼Œç›´æ¥è¿”å› `null`ã€‚
- æƒ…å†µ 3ï¼Œå¦‚æœ `p` å’Œ `q` åªæœ‰ä¸€ä¸ªå­˜åœ¨äº `root` ä¸ºæ ¹çš„æ ‘ä¸­ï¼Œå‡½æ•°è¿”å›è¯¥èŠ‚ç‚¹ã€‚![d83660f6-9b14-4d26-8dea-ef57d62038e5.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411702994-d83660f6-9b14-4d26-8dea-ef57d62038e5.png)


```go
// ç»™è¯¥å‡½æ•°è¾“å…¥ä¸‰ä¸ªå‚æ•° `root`ï¼Œ`p`ï¼Œ`q`ï¼Œå®ƒä¼šè¿”å›ä¸€ä¸ªèŠ‚ç‚¹ 
func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
   	
     if root == p || root == q || root == nil{
         return root
     }

     left := lowestCommonAncestor(root.Left,p,q)
     right := lowestCommonAncestor(root.Right,p,q)
		 // p q åˆ†åˆ«ä½äº root çš„ left right ä¸­
     if left != nil && right != nil {
         return root
     }
		 // p q éƒ½ä½äº left
     if left != nil {
         return left
     }
		 // p q éƒ½ä½äº right
     if right != nil {
         return right
     }
     // p q ä¸åœ¨ root æ ‘ä¸­
     return nil
}
```
## 92.åè½¬é“¾è¡¨ II
ç»™ä½ å•é“¾è¡¨çš„å¤´æŒ‡é’ˆ `head` å’Œä¸¤ä¸ªæ•´æ•° `left` å’Œ `right` ï¼Œå…¶ä¸­ `left <= right` ã€‚è¯·ä½ åè½¬ä»ä½ç½® `left` åˆ°ä½ç½® `right` çš„é“¾è¡¨èŠ‚ç‚¹ï¼Œè¿”å› **åè½¬åçš„é“¾è¡¨** ã€‚
![06d998e6-1670-4512-a089-9b42593d507c.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411703173-06d998e6-1670-4512-a089-9b42593d507c.png)

æ€è·¯ï¼š

- é€’å½’è§£æ³•ï¼šè¿­ä»£è§£æ³•å¾ˆç®€å•ï¼Œç”¨ä¸€ä¸ª for å¾ªç¯å³å¯ï¼Œä½†è¿™é“é¢˜ç»å¸¸ç”¨æ¥è€ƒå¯Ÿé€’å½’æ€ç»´ï¼Œè®©ä½ ç”¨çº¯é€’å½’çš„å½¢å¼æ¥è§£å†³ã€‚
è¦æƒ³çœŸæ­£ç†è§£é€’å½’æ“ä½œé“¾è¡¨çš„ä»£ç æ€è·¯ï¼Œå…³é”®ç‚¹è¿˜æ˜¯è¦æ˜ç¡®é€’å½’å‡½æ•°çš„å®šä¹‰ï¼Œæ¨å¯¼å‡ºé€’å½’ç¿»è½¬å‰ `N` ä¸ªèŠ‚ç‚¹çš„ç®—æ³•ï¼Œæœ€åæ”¹å†™å‡ºé€’å½’ç¿»è½¬åŒºé—´å†…çš„èŠ‚ç‚¹çš„è§£æ³•ä»£ç 

```go
// ç¿»è½¬leftï¼Œrightä¹‹é—´çš„é“¾è¡¨
func reverseBetween(head *ListNode, left int, right int) *ListNode {
    //å…ˆæ‰¾åˆ°ã€ç¿»è½¬çš„ç¬¬ä¸€ä¸ªèµ·å§‹èŠ‚ç‚¹ã€‘ï¼Œæ‰å¼€å§‹çœŸæ­£çš„ç¿»è½¬
    if left == 1 {
        return reverseN(head,right)
    }
    //è¯´æ˜å½“å‰èŠ‚ç‚¹ï¼Œä¸éœ€è¦ç¿»è½¬ã€‚å½“å‰èŠ‚ç‚¹çš„å°¾éƒ¨ï¼Œæ‹¼æ¥ç¿»è½¬åé“¾è¡¨çš„å¤´éƒ¨
    head.Next = reverseBetween(head.Next,left-1,right-1)
    return head
}

var successor *ListNode = nil
// ä»headå¼€å§‹ï¼Œç¿»è½¬nä¸ªèŠ‚ç‚¹ï¼Œè¿”å›é“¾è¡¨çš„å¤´èŠ‚ç‚¹
func reverseN(head *ListNode,  n int) *ListNode {
    if n == 1 {  //è¯´æ˜å½“å‰æ˜¯æœ€åä¸€ä¸ªèŠ‚ç‚¹
        successor = head.Next // è®°å½•åç»­èŠ‚ç‚¹
        return head
    }
		
  	// ä»head.Next å¼€å§‹ï¼Œç¿»è½¬n-1ä¸ªèŠ‚ç‚¹ï¼Œè¿”å›é“¾è¡¨çš„å¤´èŠ‚ç‚¹
    last := reverseN(head.Next,n-1)
  	// å¯¹headèŠ‚ç‚¹åè½¬ï¼ˆåè½¬åheadèŠ‚ç‚¹å°±å˜æˆäº†æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼‰
    head.Next.Next = head 
    head.Next = successor

    return last
}
```
![9c4a4cbc-a932-4565-99b7-b7b8e91ed435.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411703424-9c4a4cbc-a932-4565-99b7-b7b8e91ed435.png)


- è¿­ä»£è§£æ³•ï¼š> dummy å®šä¹‰è™šæ‹ŸèŠ‚ç‚¹
éå†æ•´ä¸ªé“¾è¡¨ï¼ŒcuræŒ‡å‘æ­£åœ¨è®¿é—®çš„èŠ‚ç‚¹ï¼Œi è®°å½•æŒ‡å‘çš„èŠ‚ç‚¹æ˜¯ç¬¬å‡ ä¸ªã€‚å¦‚æœcuræŒ‡å‘çš„èŠ‚ç‚¹ä¸æ˜¯è¦åè½¬çš„èŠ‚ç‚¹ï¼Œä¸æ–­çš„è¿½åŠ åˆ°p.NextåŒæ—¶pä¹Ÿä¸æ–­çš„ç§»åŠ¨
å¦‚æœcuræŒ‡å‘çš„èŠ‚ç‚¹æ˜¯è¦åè½¬çš„èŠ‚ç‚¹ï¼Œä¸æ–­çš„è¿½åŠ åˆ°p.NextåŒæ—¶p ä¸ç§»åŠ¨
leftNode ç”¨æ¥è®°å½•ç¬¬ä¸€ä¸ªåè½¬çš„èŠ‚ç‚¹ï¼ˆå› ä¸ºåè½¬åï¼Œç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå˜æˆåè½¬åçš„æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼‰ï¼Œå¦‚ä¸Šä¸­çš„èŠ‚ç‚¹2ï¼Œå˜æˆåè½¬åæœ€åä¸€ä¸ªèŠ‚ç‚¹

![d76a11b2-d47c-4bf7-b515-4e6e8f917145.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411703432-d76a11b2-d47c-4bf7-b515-4e6e8f917145.png)


```go
func reverseBetween(head *ListNode, left int, right int) *ListNode {
    // è™šæ‹ŸèŠ‚ç‚¹
    dummy := &ListNode{}
    p := dummy 
    // è¡¨ç¤ºå½“å‰ curæŒ‡å‘çš„æ˜¯ç¬¬å‡ ä¸ªèŠ‚ç‚¹
    i := 1
    cur := head

    var leftNode *ListNode

    // éå†é“¾è¡¨ä¸­çš„æ¯ä¸€ä¸ªèŠ‚ç‚¹
    for cur != nil {
        // å°†ä¸‹ä¸€ä¸ªèŠ‚ç‚¹è®°å½•æ¥ä¸‹
        temp := cur.Next
        if  left <=i && i <= right { // è¿›å…¥åˆ°åè½¬èŒƒå›´çš„èŠ‚ç‚¹
            // å°†èŠ‚ç‚¹ä¿å­˜åœ¨påé¢ï¼Œä½†æ˜¯pä¸ç§»åŠ¨
            cur.Next = p.Next
            p.Next = cur

            // è®°å½•ç¬¬ä¸€ä¸ªåè½¬çš„èŠ‚ç‚¹
            if i == left {
                leftNode = cur
            }
            // æœ€åè®©pæŒ‡å‘ç¬¬ä¸€ä¸ªåè½¬çš„èŠ‚ç‚¹ï¼ˆå› ä¸ºå·²ç»æˆä¸ºäº†æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼‰
            if i == right {
                p = leftNode
            }
        } else { // ä¸æ˜¯è¦åè½¬çš„èŠ‚ç‚¹
            // å°†èŠ‚ç‚¹ä¿å­˜åœ¨påé¢ï¼Œä½†æ˜¯pä¹Ÿè·Ÿç€ç§»åŠ¨
            p.Next = cur
            p = p.Next
            p.Next = nil // è®©pçš„åç»­èŠ‚ç‚¹ä¸ºnilï¼Œç‰¹ä¾‹ï¼š[3,5] left= 2 right = 2
        }
        // è·³åˆ°ï¼Œä¸‹ä¸€ä¸ªèŠ‚ç‚¹
        i++
        cur = temp
    }
    return dummy.Next
}
```
## 23.åˆå¹¶Kä¸ªå‡åºé“¾è¡¨
ç»™ä½ ä¸€ä¸ªé“¾è¡¨æ•°ç»„ï¼Œæ¯ä¸ªé“¾è¡¨éƒ½å·²ç»æŒ‰å‡åºæ’åˆ—ã€‚è¯·ä½ å°†æ‰€æœ‰é“¾è¡¨åˆå¹¶åˆ°ä¸€ä¸ªå‡åºé“¾è¡¨ä¸­ï¼Œè¿”å›åˆå¹¶åçš„é“¾è¡¨ã€‚
æ€è·¯ï¼š

- ç±»å‹äºå½’å¹¶æ’åºï¼Œå°†é“¾è¡¨æ•°ç»„åˆ‡åˆ†ç§°ä¸¤ä¸ªå­æ•°ç»„ï¼Œåˆ†åˆ«å¯¹å­æ•°ç»„æ’åºï¼Œç„¶åå°†æ’åºåçš„ä¸¤ä¸ªå­æ•°ç»„è¿›è¡Œ`merge`æˆä¸€ä¸ªå¤§çš„æœ‰åºæ•°ç»„
```go
func mergeKLists(lists []*ListNode) *ListNode {
  	// è¿™é‡Œlistsçš„é•¿åº¦å¯èƒ½ä¸º0
    if len(lists) == 0 {
        return nil
    }
    return sortK(lists,0,len(lists)-1) 
}

//å®šä¹‰ï¼šå¯¹ã€leftï¼Œrightã€‘ä¹‹é—´çš„é“¾è¡¨æ’åºï¼Œè¿”å›æœ‰åºé“¾è¡¨å¤´èŠ‚ç‚¹
func sortK( lists []*ListNode,left,right int) *ListNode {
    if left == right {
        return lists[left]
    }
  	// åˆ‡åˆ†æˆä¸¤ä¸ªå­æ•°ç»„ï¼Œåˆ†åˆ«æ’åº
    mid := left +(right-left)/2
    l := sortK(lists,left,mid)
    r := sortK(lists,mid+1,right)
  	// åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨
    return merge(l,r)
}
//å¯¹ä¸¤ä¸ªæœ‰åºé“¾è¡¨åˆå¹¶ï¼Œè¿”å›å¤´èŠ‚ç‚¹
func merge(l,r *ListNode) *ListNode {
  	//è™šæ‹Ÿå¤´èŠ‚ç‚¹
    dummy := &ListNode{Val:0,Next:nil} 

    p := dummy

    for l != nil && r != nil {
        if l.Val < r.Val {
            p.Next = l
            l = l.Next
        } else {
            p.Next = r
            r = r.Next
        }
        p = p.Next
    }
    
    if l != nil {
        p.Next = l
    }

    if r != nil {
        p.Next = r
    }
    return dummy.Next
}
```
## 54.èºæ—‹çŸ©é˜µ
ç»™ä½ ä¸€ä¸ª `m` è¡Œ `n` åˆ—çš„çŸ©é˜µ `matrix` ï¼Œè¯·æŒ‰ç…§ **é¡ºæ—¶é’ˆèºæ—‹é¡ºåº** ï¼Œè¿”å›çŸ©é˜µä¸­çš„æ‰€æœ‰å…ƒç´ ã€‚
![3b6da872-cc39-4110-8ac2-211bd87f9f20.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411703378-3b6da872-cc39-4110-8ac2-211bd87f9f20.png)

æ€è·¯ï¼š
æœ¬è´¨å°±æ˜¯å¯¹äºŒç»´æ•°ç»„çš„éå†ï¼Œå…ˆæ¨ªå‘éå†ï¼Œå†ç«–å‘éå†ï¼ˆä¸€ç›´åå¤è¿›è¡Œï¼‰ã€‚æ³¨æ„çš„ç‚¹ï¼šèŒƒå›´ä¸è¦è¶Šç•Œã€‚

```go
func spiralOrder(matrix [][]int) []int {
    m := len(matrix)
    n := len(matrix[0])

    top,end := 0, m-1
    left,right := 0,n-1
    var result []int
		// ç»“æŸæ¡ä»¶ resultå·²ç»ä¿å­˜äº†æ‰€æœ‰çš„å…ƒç´ 
    for len(result) < m * n {

        if top <= end { //ä¸Šä¸‹è¾¹ç•Œä¸è¶Šç•Œ 
            //éå†topï¼Œä»left åˆ°right
            for i := left; i <= right;i++ {
                result = append(result,matrix[top][i])
            }
            top++ // é¡¶éƒ¨ä¸‹ç§»
        }

        if left <= right {
            //éå†rightï¼Œä»topåˆ°end
            for i := top;i <= end;i++ {
                result = append(result, matrix[i][right])
            }
            right-- //å³è¾¹å·¦ç§»
        }
        
        if top <= end {
            //éå†endï¼Œä»rightåˆ°left
            for i := right;i >= left;i-- {
                result = append(result,matrix[end][i])
            }
            end-- //åº•éƒ¨ä¸Šç§»
        }
        
        if left <= right {
            //éå†leftï¼Œä»endåˆ°top
            for i := end;i >= top;i-- {
                result = append(result,matrix[i][left])
            }
            left++  
        }
    }
    return result
}
```
## 300.æœ€é•¿é€’å¢å­åºåˆ—
ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums` ï¼Œæ‰¾åˆ°å…¶ä¸­æœ€é•¿ä¸¥æ ¼é€’å¢å­åºåˆ—çš„é•¿åº¦ã€‚
**å­åºåˆ—** æ˜¯ç”±æ•°ç»„æ´¾ç”Ÿè€Œæ¥çš„åºåˆ—ï¼Œåˆ é™¤ï¼ˆæˆ–ä¸åˆ é™¤ï¼‰æ•°ç»„ä¸­çš„å…ƒç´ è€Œä¸æ”¹å˜å…¶ä½™å…ƒç´ çš„é¡ºåºã€‚ä¾‹å¦‚ï¼Œ`[3,6,2,7]` æ˜¯æ•°ç»„ `[0,3,1,6,2,2,7]` çš„å­åºåˆ—
æ€è·¯ï¼š

- `dp` æ•°ç»„çš„å®šä¹‰ï¼š`dp[i]` è¡¨ç¤ºä»¥ `nums[i]` è¿™ä¸ªæ•°ç»“å°¾çš„æœ€é•¿é€’å¢å­åºåˆ—çš„é•¿åº¦ã€‚é‚£ä¹ˆ `dp` æ•°ç»„ä¸­æœ€å¤§å€¼ï¼Œå°±æ˜¯æœ€é•¿çš„é€’å¢å­åºåˆ—é•¿åº¦ã€‚

- é€’æ¨å…³ç³»ï¼š `if nums[i] > nums[i-1] dp[i] = max(dp[i],dp[i-1] + 1)`
```go
func lengthOfLIS(nums []int) int {
    //å®šä¹‰dp[i] ä¸ºä»¥nums[i]ä¸ºç»“å°¾ï¼Œæœ€å¤§å­åºåˆ—ã€é•¿åº¦ã€‘

    dp := make([]int,len(nums))
    var result int
		// é»˜è®¤æ¯æ¬¡å…ƒç´ å°±æ˜¯ä¸€ä¸ªå­åºåˆ—
    for k,_ := range dp {
        dp[k] = 1
    }

    for i := 0;i < len(nums);i++ {

        for j := 0;j < i;j++ { //å’Œiä¹‹å‰çš„æ‰€æœ‰dpéƒ½å¯¹æ¯”ä¸€ä¸‹[0, i-1]

            if nums[i] > nums[j] { //åˆ¤æ–­å°¾éƒ¨æ•°å€¼å¤§å°
                dp[i] = max(dp[i],dp[j]+1)
            }
        }

        // æ¯ä¸ªiä½ç½®å¤„çš„æœ€é•¿é€’å¢å­åºåˆ—çš„é•¿åº¦ä¸­ã€æœ€å¤§å€¼ã€‘
        result = max(result,dp[i])
    }
    return result
}

func max(a,b int)int{
    if a > b {
        return a
    }
    return b
}
```
## 415.å­—ç¬¦ä¸²ç›¸åŠ 
ç»™å®šä¸¤ä¸ªå­—ç¬¦ä¸²å½¢å¼çš„éè´Ÿæ•´æ•° `num1` å’Œ`num2` ï¼Œè®¡ç®—å®ƒä»¬çš„å’Œå¹¶åŒæ ·ä»¥å­—ç¬¦ä¸²å½¢å¼è¿”å›ã€‚
ä½ ä¸èƒ½ä½¿ç”¨ä»»ä½•å…§å»ºçš„ç”¨äºå¤„ç†å¤§æ•´æ•°çš„åº“ï¼ˆæ¯”å¦‚ `BigInteger`ï¼‰ï¼Œ ä¹Ÿä¸èƒ½ç›´æ¥å°†è¾“å…¥çš„å­—ç¬¦ä¸²è½¬æ¢ä¸ºæ•´æ•°å½¢å¼ã€‚
æ€è·¯ï¼š

- åŒæŒ‡é’ˆï¼Œåˆ†åˆ«æŒ‡å‘å­—ç¬¦ä¸²çš„å°¾éƒ¨å­—ç¬¦
- `carry`è®°å½•è¿›ä½
```go
func addStrings(num1 string, num2 string) string {

    // è¿™é¢˜å’ŒäºŒè¿›åˆ¶ç›¸åŠ ä¸€æ ·çš„è§£æ³•ï¼Œåªæ˜¯ä¸€ä¸ªæ˜¯åè¿›åˆ¶ï¼Œä¸€ä¸ªæ˜¯äºŒè¿›åˆ¶

    l1 := len(num1)-1
    l2 := len(num2)-1

    carry  := 0
    result := ""
  	// æ³¨æ„ï¼šæ¡ä»¶æ˜¯ã€æˆ–ã€‘çš„å…³ç³»
    for l1 >= 0 || l2 >= 0 || carry != 0 {
        sum := carry
        if l1 >= 0 {
            sum += int(num1[l1] - '0')
            l1--
        }
        if l2 >= 0 {
            sum += int(num2[l2] - '0')
            l2--
        }
        result = string(sum % 10 + '0') + result // ä½™æ•°æ‹¼æ¥åˆ°resultå‰é¢
        carry = sum / 10
    }
    return result
}
```
## 160.ç›¸äº¤é“¾è¡¨
ç»™ä½ ä¸¤ä¸ªå•é“¾è¡¨çš„å¤´èŠ‚ç‚¹ `headA` å’Œ `headB` ï¼Œè¯·ä½ æ‰¾å‡ºå¹¶è¿”å›ä¸¤ä¸ªå•é“¾è¡¨ç›¸äº¤çš„èµ·å§‹èŠ‚ç‚¹ã€‚å¦‚æœä¸¤ä¸ªé“¾è¡¨ä¸å­˜åœ¨ç›¸äº¤èŠ‚ç‚¹ï¼Œè¿”å›`null`ã€‚
å›¾ç¤ºä¸¤ä¸ªé“¾è¡¨åœ¨èŠ‚ç‚¹ `c1` å¼€å§‹ç›¸äº¤**ï¼š**
![40842676-7b98-47ce-b62e-404106e7cd46.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411703428-40842676-7b98-47ce-b62e-404106e7cd46.png)

é¢˜ç›®æ•°æ® **ä¿è¯** æ•´ä¸ªé“¾å¼ç»“æ„ä¸­ä¸å­˜åœ¨ç¯ã€‚
**æ³¨æ„**ï¼Œå‡½æ•°è¿”å›ç»“æœåï¼Œé“¾è¡¨å¿…é¡» **ä¿æŒå…¶åŸå§‹ç»“æ„**
æ€è·¯ï¼š
**è§£å†³è¿™ä¸ªé—®é¢˜çš„å…³é”®æ˜¯ï¼Œé€šè¿‡æŸäº›æ–¹å¼ï¼Œè®© **`**p1**`** å’Œ **`**p2**`** èƒ½å¤ŸåŒæ—¶åˆ°è¾¾ç›¸äº¤èŠ‚ç‚¹ **`**c1**`**ã€‚**
å¦‚æœç”¨ä¸¤ä¸ªæŒ‡é’ˆ `p1` å’Œ `p2` åˆ†åˆ«åœ¨ä¸¤æ¡é“¾è¡¨ä¸Šå‰è¿›ï¼Œæˆ‘ä»¬å¯ä»¥è®© `p1` éå†å®Œé“¾è¡¨ `A` ä¹‹åå¼€å§‹éå†é“¾è¡¨ `B`ï¼Œè®© `p2` éå†å®Œé“¾è¡¨ `B` ä¹‹åå¼€å§‹éå†é“¾è¡¨ `A`ï¼Œè¿™æ ·ç›¸å½“äºã€Œé€»è¾‘ä¸Šã€ä¸¤æ¡é“¾è¡¨æ¥åœ¨äº†ä¸€èµ·ã€‚
å¦‚æœè¿™æ ·è¿›è¡Œæ‹¼æ¥ï¼Œå°±å¯ä»¥è®© `p1` å’Œ `p2` åŒæ—¶è¿›å…¥å…¬å…±éƒ¨åˆ†ï¼Œä¹Ÿå°±æ˜¯åŒæ—¶åˆ°è¾¾ç›¸äº¤èŠ‚ç‚¹ `c1`ï¼š
![61e94df8-fa44-4346-b16c-45eef1de370c.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411703666-61e94df8-fa44-4346-b16c-45eef1de370c.png)


```go
func getIntersectionNode(headA, headB *ListNode) *ListNode {

    p1,p2 := headA,headB

    for p1 != p2 {
        if p1 == nil {
            p1 = headB
        } else {
            p1 = p1.Next
        }

        if p2 == nil {
            p2 = headA
        } else {
            p2 = p2.Next
        }
    }
    return p1
}
```

- è¿™é‡Œå†æä¾›å¦å¤–ä¸€ç§æ–¹æ¡ˆæ€è·¯ï¼š

- å°†ä¸¤ä¸ªé“¾è¡¨é¦–å°¾ä¸²è”èµ·æ¥ï¼ˆç‰©ç†ä¸Šä¸²è”ï¼Œä¸Šé¢çš„è§£æ³•æ˜¯é€»è¾‘ä¸Šä¸²è”ï¼‰
- åˆ©ç”¨å¿«æ…¢æŒ‡é’ˆï¼Œåˆ¤æ–­æ˜¯å¦å­˜åœ¨ç¯
- å¦‚æœå­˜åœ¨ç¯ï¼Œ`fast`ç§»åŠ¨çš„è·ç¦»æ˜¯ 2å€çš„ `slow`ï¼ˆå› ä¸º`fast`ä¸€æ¬¡ç§»åŠ¨2æ­¥ï¼Œ`slow`ä¸€æ¬¡ç§»åŠ¨1æ­¥ï¼Œå¦‚æœç›¸é‡äº†ï¼Œè¯´æ˜`fast`ç§»åŠ¨çš„è·ç¦»æ˜¯`slow`çš„2å€ï¼‰
- é‡ç½® `slow = headA`ï¼ŒåŒæ—¶ç§»åŠ¨ `slow fast`ç›´åˆ°ç›¸é‡ï¼Œå°±æ˜¯ç›¸äº¤ç‚¹ã€‚![c7a09829-8f6a-49a3-a935-ec87dd2f4d41.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411703948-c7a09829-8f6a-49a3-a935-ec87dd2f4d41.png)


```go
func getIntersectionNode1(headA, headB *ListNode) *ListNode {
    //1.æ‰¾åˆ°Aé“¾è¡¨æœ€åä¸€ä¸ªèŠ‚ç‚¹
    q := headA

    for q.Next != nil {
        q = q.Next
    }
    //2.æ­¤æ—¶qæŒ‡å‘é“¾è¡¨Açš„æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼Œæ‹¼æ¥Aé“¾è¡¨ + Bé“¾è¡¨
    q.Next = headB

    //3.å¿«æ…¢æŒ‡é’ˆï¼Œåˆ¤æ–­æ˜¯å¦æœ‰ç¯
    slow,fast := headA,headA

    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next

        if slow == fast {//æœ‰ç¯
            break
        }
    }

    //4. æ‰§è¡Œåˆ°è¿™é‡Œï¼Œå¹¶ä¸”fast == nil || fast.Next== nilï¼Œè¯´æ˜ä¸Šé¢çš„forå¾ªç¯ï¼Œä¸æ˜¯å› ä¸ºæœ‰ç¯ç»“æŸçš„ï¼Œæ˜¯å› ä¸ºæ— ç¯
    if fast == nil || fast.Next == nil {
     	 q.Next = nil //!!!æ–­å¼€ä¸¤ä¸ªé“¾è¡¨(é¢˜ç›®è¦æ±‚å¿…é¡»ä¿æŒåŸæ¥çš„ç»“æ„)
        return nil
    }

    //5.æœ‰ç¯ï¼Œæ‰¾åˆ°ç¯çš„èµ·å§‹ç‚¹
    slow = headA
    for slow != fast {
        slow = slow.Next
        fast = fast.Next
    }
  	// !!!æ–­å¼€ä¸¤ä¸ªé“¾è¡¨(é¢˜ç›®è¦æ±‚å¿…é¡»ä¿æŒåŸæ¥çš„ç»“æ„)
    q.Next = nil

    return slow

}
```
## 143.é‡æ’é“¾è¡¨
ç»™å®šä¸€ä¸ªå•é“¾è¡¨ `L` çš„å¤´èŠ‚ç‚¹ `head` ï¼Œå•é“¾è¡¨ `L` è¡¨ç¤ºä¸ºï¼š

```go
L0 â†’ L1 â†’ â€¦ â†’ Ln - 1 â†’ Ln
```
è¯·å°†å…¶é‡æ–°æ’åˆ—åå˜ä¸ºï¼š

```go
L0 â†’ Ln â†’ L1 â†’ Ln - 1 â†’ L2 â†’ Ln - 2 â†’ â€¦
```
ä¸èƒ½åªæ˜¯å•çº¯çš„æ”¹å˜èŠ‚ç‚¹å†…éƒ¨çš„å€¼ï¼Œè€Œæ˜¯éœ€è¦å®é™…çš„è¿›è¡ŒèŠ‚ç‚¹äº¤æ¢ã€‚
æ€è·¯ï¼š

- å…ˆåˆ©ç”¨å¿«æ…¢æŒ‡é’ˆå°†é“¾è¡¨åˆ‡åˆ†ç§°ä¸¤ä¸ªå­é“¾è¡¨ `l1 l2`
- å¯¹ `l2`è¿›è¡Œåè½¬
- æœ€åå°† `l1 l2`èŠ‚ç‚¹äº¤é”™çš„æ‹¼æ¥åˆ°ä¸€èµ·
```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reorderList(head *ListNode)  {
    // æ— èŠ‚ç‚¹ or å•ä¸ªèŠ‚ç‚¹
    if head == nil || head.Next == nil {
        return
    }
    //å¿«æ…¢æŒ‡é’ˆï¼Œæ‰¾åˆ°ä¸­ç‚¹
    fast,slow := head,head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
    }

    //!!!æ³¨æ„è¿™ä¸ªç»†èŠ‚
    l1 := head // å­é“¾è¡¨ l1
    l2 := slow.Next //ä¸­ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼Œä½œä¸ºå­é“¾è¡¨ l2 èµ·å§‹èŠ‚ç‚¹
    slow.Next = nil //ä¸ºäº†è®©l1å°¾éƒ¨æŒ‡å‘ nil èŠ‚ç‚¹
  
    //ç¿»è½¬é“¾è¡¨ l2
    l2 = reverseList(l2)
  
    //åˆå¹¶é“¾è¡¨
    for l1 != nil && l2 != nil {
        l1Next := l1.Next
        l2Next := l2.Next

        l1.Next = l2
        l1 = l1Next

        l2.Next = l1 // l2æŒ‡å‘l1 (æ­¤æ—¶ l1 = l1Next å·²ç»ç§»ä½äº†ä¸€æ­¥)
        l2 = l2Next
    }
}

// ç¿»è½¬é“¾è¡¨
func reverseList(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }
   
    last := reverseList(head.Next)
    head.Next.Next = head
    head.Next = nil
    return last 
}
```
## 56.åˆå¹¶åŒºé—´
ä»¥æ•°ç»„ `intervals` è¡¨ç¤ºè‹¥å¹²ä¸ªåŒºé—´çš„é›†åˆï¼Œå…¶ä¸­å•ä¸ªåŒºé—´ä¸º `intervals[i] = [start, end]` ã€‚è¯·ä½ åˆå¹¶æ‰€æœ‰é‡å çš„åŒºé—´ï¼Œå¹¶è¿”å› *ä¸€ä¸ªä¸é‡å çš„åŒºé—´æ•°ç»„ï¼Œè¯¥æ•°ç»„éœ€æ°å¥½è¦†ç›–è¾“å…¥ä¸­çš„æ‰€æœ‰åŒºé—´* ã€‚
æ€è·¯ï¼š

- ä¸€ä¸ªåŒºé—´å¯ä»¥è¡¨ç¤ºä¸º `[start, end]`ï¼Œå…ˆæŒ‰åŒºé—´çš„ `start` æ’åºï¼š
- **æ˜¾ç„¶ï¼Œå¯¹äºå‡ ä¸ªç›¸äº¤åŒºé—´åˆå¹¶åçš„ç»“æœåŒºé—´ **`**x**`**ï¼Œ**`**x.start**`**çš„å€¼ ä¸€å®šæ˜¯è¿™äº›ç›¸äº¤åŒºé—´ä¸­ **`**start**`** æœ€å°çš„ï¼Œ**`**x.end**`** ä¸€å®šæ˜¯è¿™äº›ç›¸äº¤åŒºé—´ä¸­ **`**end**`** æœ€å¤§çš„**ï¼š![88f4c199-ca12-441b-8182-e2d74952a1cc.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411704628-88f4c199-ca12-441b-8182-e2d74952a1cc.png)


```go
func merge(intervals [][]int) [][]int {
		// æŒ‰ç…§ start æ­£åºæ’åˆ—
    sort.Slice(intervals, func(i, j int) bool {
		return intervals[i][0] < intervals[j][0]
	})

    var result [][]int
    pre := intervals[0] //å‰ä¸€ä¸ªåˆ‡ç‰‡

    for index := 1 ; index < len(intervals); index++ {
        cur := intervals[index] //å½“å‰åˆ‡ç‰‡
        
      	// å½“å‰åˆ‡ç‰‡å¤´éƒ¨ cur[0] <= å‰ä¸€ä¸ªåˆ‡ç‰‡å°¾éƒ¨pre[1] ã€æœ‰äº¤é›†ã€‘
        if cur[0] <= pre[1] {
            pre[1] = max(pre[1],cur[1]) //åˆå¹¶ä¸¤ä¸ªä¸ºä¸€ä¸ªï¼Œç”¨å°¾éƒ¨è¾ƒå¤§çš„å€¼ï¼Œä½œä¸ºåˆå¹¶åçš„åŒºé—´å°¾éƒ¨ pre[1]
        } else { //å½“å‰cur å’Œpreæ²¡æœ‰äº¤é›†ï¼Œå°†preä¿å­˜èµ·æ¥ï¼ŒåŒæ—¶curä½œä¸ºpre
            result = append(result,pre)
            pre = cur
        }
    }
		// æœ€åè®°å¾—ï¼Œå°†preä¿å­˜åˆ° resultä¸€ä»½
    result = append(result,pre)
    return result
}

func max(a,b int)int{
    if a > b {
        return a
    }
    return b
}
```
## 42.æ¥é›¨æ°´
ç»™å®š `n` ä¸ªéè´Ÿæ•´æ•°è¡¨ç¤ºæ¯ä¸ªå®½åº¦ä¸º `1` çš„æŸ±å­çš„é«˜åº¦å›¾ï¼Œè®¡ç®—æŒ‰æ­¤æ’åˆ—çš„æŸ±å­ï¼Œä¸‹é›¨ä¹‹åèƒ½æ¥å¤šå°‘é›¨æ°´ã€‚
æ€è·¯ï¼š

- å¯¹äºä»»æ„ä¸€ä¸ªä½ç½® `i`ï¼Œèƒ½å¤Ÿè£…çš„æ°´ä¸ºï¼š
```go
water[i] = 		// å·¦å³ä¸¤è¾¹çš„æœ€é«˜å€¼çš„æœ€å°å€¼ -  height[i]
							min(
  						// 0åˆ°içš„æœ€é«˜å€¼
  						max(height[0..i]) , 
  						// i åˆ° endçš„æœ€é«˜å€¼
  						max(height[i..end])  )   - height[i]
```
![1ab64ed9-00ee-49ea-b77c-85b488e5b41e.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411704272-1ab64ed9-00ee-49ea-b77c-85b488e5b41e.png)


```go
func trap(height []int) int {
    ///ï¼ï¼ï¼æ€è·¯ï¼šç­”æ¡ˆç†è§£èµ·æ¥æ¯”è¾ƒå®¹æ˜“ï¼Œç¬¬ä¸€æ¬¡åšä¼°è®¡å¾ˆéš¾æƒ³åˆ°ï¼›

    //ä»å·¦åˆ°å³éå†[0...i]ï¼Œæ±‚å·¦è¾¹æ¯ä¸ªä½ç½®içš„æœ€é«˜é«˜åº¦ï¼Œl_dp[i] = max(height[i],l_dp[i-1]) 
    //ä»å³åˆ°å·¦éå†[i...end ]ï¼Œæ±‚å³è¾¹æ¯ä¸ªä½ç½®içš„æœ€é«˜é«˜åº¦ï¼Œr_dp[i] = max(height[i],r_dp[i+1])

    l_dp := make([]int,len(height)) // ä»[0..i],æ±‚å½“å‰ä½ç½®iï¼ŒæŸ±å­çš„æœ€é«˜é«˜åº¦
    l_dp[0] = height[0]
    for i := 1;i < len(height);i++ {
        l_dp[i] = max(height[i],l_dp[i-1]) // l_dp[i-1]å‰ä¸€ä¸ªæŸ±å­çš„æœ€é«˜é«˜åº¦
    }

    r_dp := make([]int,len(height)) //ä» [i...end]ï¼Œæ±‚å½“å‰ä½ç½®iï¼ŒæŸ±å­çš„æœ€é«˜é«˜åº¦
    r_dp[len(height)-1] = height[len(height)-1]

    for i := len(height)-2;i >= 0;i-- {
        r_dp[i] = max(height[i],r_dp[i+1])
    }

    result := 0
    for i := 0;i < len(height);i++ {
        result += min(l_dp[i],r_dp[i]) - height[i] //å·¦è¾¹çš„æœ€é«˜é«˜åº¦ å’Œ å³è¾¹çš„æœ€é«˜é«˜åº¦ï¼Œå–æœ€å°å€¼ï¼Œå‡å»å½“å‰çš„é«˜åº¦ï¼Œè¡¨ç¤ºå½“å‰ä½ç½®å¯ä»¥ä¿å­˜åˆ°æ°´é‡
    }
    return result
}

func min( a,b int) int{
    if a < b {
        return a
    }
    return b
}

func max( a,b int) int{
    if a > b {
        return a
    }
    return b
}
```
## 142.ç¯å½¢é“¾è¡¨
ç»™å®šä¸€ä¸ªé“¾è¡¨çš„å¤´èŠ‚ç‚¹ `head` ï¼Œè¿”å›é“¾è¡¨å¼€å§‹å…¥ç¯çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚ *å¦‚æœé“¾è¡¨æ— ç¯ï¼Œåˆ™è¿”å› *`*null*`*ã€‚*
å¦‚æœé“¾è¡¨ä¸­æœ‰æŸä¸ªèŠ‚ç‚¹ï¼Œå¯ä»¥é€šè¿‡è¿ç»­è·Ÿè¸ª `next` æŒ‡é’ˆå†æ¬¡åˆ°è¾¾ï¼Œåˆ™é“¾è¡¨ä¸­å­˜åœ¨ç¯ã€‚ ä¸ºäº†è¡¨ç¤ºç»™å®šé“¾è¡¨ä¸­çš„ç¯ï¼Œè¯„æµ‹ç³»ç»Ÿå†…éƒ¨ä½¿ç”¨æ•´æ•° `pos` æ¥è¡¨ç¤ºé“¾è¡¨å°¾è¿æ¥åˆ°é“¾è¡¨ä¸­çš„ä½ç½®ï¼ˆ**ç´¢å¼•ä» 0 å¼€å§‹**ï¼‰ã€‚å¦‚æœ `pos` æ˜¯ `-1`ï¼Œåˆ™åœ¨è¯¥é“¾è¡¨ä¸­æ²¡æœ‰ç¯ã€‚**æ³¨æ„ï¼š**`**pos**`** ä¸ä½œä¸ºå‚æ•°è¿›è¡Œä¼ é€’**ï¼Œä»…ä»…æ˜¯ä¸ºäº†æ ‡è¯†é“¾è¡¨çš„å®é™…æƒ…å†µã€‚
**ä¸å…è®¸ä¿®æ”¹** é“¾è¡¨ã€‚
![baa1b564-bd1a-40ba-91da-51ff27aec3d9.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411704120-baa1b564-bd1a-40ba-91da-51ff27aec3d9.png)

æ€è·¯ï¼š
æˆ‘ä»¬å‡è®¾å¿«æ…¢æŒ‡é’ˆç›¸é‡æ—¶ï¼Œæ…¢æŒ‡é’ˆ `slow` èµ°äº† `k` æ­¥ï¼Œé‚£ä¹ˆå¿«æŒ‡é’ˆ `fast` ä¸€å®šèµ°äº† `2k` æ­¥ï¼š
å› ä¸º `fast` ä¸€æ¬¡è·³è·ƒè·ç¦»ä¸º`2` ï¼Œ`slow` ä¸€æ¬¡è·³è·ƒè·ç¦»ä¸º `1`
![1dd8cbd8-2950-4bc4-a024-098f0655f0d8.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411704199-1dd8cbd8-2950-4bc4-a024-098f0655f0d8.png)

å‡è®¾ã€ç›¸é‡ç‚¹ã€‘è·ç¯ã€ç›¸äº¤ç‚¹ã€‘çš„è·ç¦»ä¸º `m`ï¼Œé‚£ä¹ˆç»“åˆä¸‹å›¾çš„ `slow` æŒ‡é’ˆï¼Œç¯çš„ã€ç›¸äº¤ç‚¹ã€‘è·å¤´ç»“ç‚¹ `head` çš„è·ç¦»ä¸º `k - m`ï¼Œä¹Ÿå°±æ˜¯è¯´å¦‚æœä» `head` å‰è¿› `k - m` æ­¥å°±èƒ½åˆ°è¾¾ç¯èµ·ç‚¹ã€‚
å·§çš„æ˜¯ï¼Œå¦‚æœä»ã€ç›¸é‡ç‚¹ã€‘ç»§ç»­å‰è¿› `k - m` æ­¥ï¼Œä¹Ÿæ°å¥½åˆ°è¾¾ç¯ã€ç›¸äº¤ç‚¹ã€‘ï¼š
![ad965607-27a8-4f0c-84ba-b7a6af67db9f.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411704571-ad965607-27a8-4f0c-84ba-b7a6af67db9f.png)

æ‰€ä»¥ï¼Œåªè¦æˆ‘ä»¬æŠŠå¿«æ…¢æŒ‡é’ˆä¸­çš„ä»»ä¸€ä¸ªé‡æ–°æŒ‡å‘ `head`ï¼Œç„¶åä¸¤ä¸ªæŒ‡é’ˆåŒé€Ÿå‰è¿›ï¼Œ`k - m` æ­¥åä¸€å®šä¼šç›¸é‡ï¼Œç›¸é‡ä¹‹å¤„å°±æ˜¯ç¯çš„èµ·ç‚¹äº†ã€‚

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func detectCycle(head *ListNode) *ListNode {
   
    //1.åˆ¤æ–­æ˜¯å¦æœ‰ç¯
    fast,slow := head,head
    for fast != nil && fast.Next != nil {
        
        fast = fast.Next.Next
        slow = slow.Next
        if fast == slow {
            break
        }
    }
    //2.è¯´æ˜æ²¡æœ‰ç¯
    if fast == nil || fast.Next == nil {
        return nil
    }

    //3.è¯´æ˜æœ‰ç¯ï¼Œéœ€è¦æ‰¾åˆ°ç¯çš„èµ·å§‹ä½ç½®
    slow = head
    for slow != fast {
        fast = fast.Next
        slow = slow.Next
    }

    return slow

}
```
## 124. äºŒå‰æ ‘ä¸­çš„æœ€å¤§è·¯ç»å’Œ
äºŒå‰æ ‘ä¸­çš„ **è·¯å¾„** è¢«å®šä¹‰ä¸ºä¸€æ¡èŠ‚ç‚¹åºåˆ—ï¼Œåºåˆ—ä¸­æ¯å¯¹ç›¸é‚»èŠ‚ç‚¹ä¹‹é—´éƒ½å­˜åœ¨ä¸€æ¡è¾¹ã€‚åŒä¸€ä¸ªèŠ‚ç‚¹åœ¨ä¸€æ¡è·¯å¾„åºåˆ—ä¸­ **è‡³å¤šå‡ºç°ä¸€æ¬¡** ã€‚è¯¥è·¯å¾„ **è‡³å°‘åŒ…å«ä¸€ä¸ª** èŠ‚ç‚¹ï¼Œä¸”ä¸ä¸€å®šç»è¿‡æ ¹èŠ‚ç‚¹ã€‚
**è·¯å¾„å’Œ** æ˜¯è·¯å¾„ä¸­å„èŠ‚ç‚¹å€¼çš„æ€»å’Œã€‚ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œè¿”å›å…¶ **æœ€å¤§è·¯å¾„å’Œ** ã€‚
æ€è·¯ï¼š

- ã€ä»rootä¸ºèµ·ç‚¹çš„æœ€å¤§è·¯å¾„ã€‘è¿™é¢˜åœ¨äºé€’å½’å‡½æ•°çš„å®šä¹‰ï¼š`func oneSideMax(root *TreeNode) int `ï¼šä»`root`ä¸ºèµ·ç‚¹çš„æœ€å¤§è·¯å¾„å’Œ
ä¸ç®¡`root.Val`æ˜¯æ­£è¿˜æ˜¯è´Ÿï¼Œä»`root`èŠ‚ç‚¹å‡ºå‘ï¼ˆåˆå§‹å€¼`root.Val`ï¼‰ï¼Œå¦‚æœå·¦èŠ‚ç‚¹`leftMax`æ˜¯è´Ÿå€¼ï¼Œåªä¼šä½¿è·¯ç»å’Œå€¼æ›´å°ï¼Œä¹Ÿå°±æ˜¯`left `ä¸èƒ½ä½œä¸ºè·¯ç» ï¼›å¦‚æœå³èŠ‚ç‚¹`rightMax`æ˜¯æ­£æ•°ï¼Œå¯ä»¥ä½¿ä»`root`ä¸ºèµ·ç‚¹çš„æœ€å¤§è·¯å¾„å’Œå˜çš„æ›´å¤§ï¼Œå› æ­¤`right`å¯ä»¥ä½œä¸ºè·¯å¾„
æ¢å¥è¯è¯´ï¼šä»`root`å‡ºå‘çš„è·¯ç»å’Œï¼Œå°±æ˜¯åœ¨`root.Val`å€¼çš„åŸºç¡€ä¸Šï¼Œä¸Šè°ƒæˆ–ä¸å˜ï¼Œå¦‚æœ`leftMax`ä¸ºè´Ÿå€¼ï¼Œé‚£å°±æ˜¯ä¸‹è°ƒã€‚ä¸å¯èƒ½ä½œä¸ºä»`root`å‡ºå‘çš„æœ€å¤§è·¯å¾„ã€‚
![b01d1d3a-275f-4aa9-bb83-006dc81e6b2a.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411704706-b01d1d3a-275f-4aa9-bb83-006dc81e6b2a.png)


- ä½†æ˜¯é¢˜ç›®è¦æ±‚çš„æ˜¯ï¼šã€ç»è¿‡rootã€‘çš„æœ€å¤§è·¯å¾„å’Œï¼Œæ³¨æ„å’Œä¸Šé¢çš„åŒºåˆ«ï¼Œä¸€ä¸ªæ˜¯ä» rootå‡ºå‘ï¼Œé¢˜ç›®è¦æ±‚çš„æ˜¯ç»è¿‡ root ã€‚![be3547fa-bc1a-471b-8ebe-111ef484f5dc.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411704877-be3547fa-bc1a-471b-8ebe-111ef484f5dc.png)


```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

var result int = math.MinInt
// ã€ä»rootä¸ºèµ·ç‚¹çš„æœ€å¤§è·¯å¾„ã€‘ ä¸  ã€ç»è¿‡rootçš„æœ€å¤§è·¯å¾„å’Œï¼Œæ˜¯ä¸¤ç§ä¸åŒçš„å«ä¹‰ã€‘éœ€è¦ä½“ä¼šä¸‹
func maxPathSum(root *TreeNode) int {

    result = math.MinInt
    if root == nil {
        return 0
    }
    oneSideMax(root)
    return result
}

// oneSideMax å‡½æ•°å®šä¹‰ï¼šä»rootä¸ºèµ·ç‚¹çš„æœ€å¤§è·¯å¾„å’Œ
func oneSideMax(root *TreeNode) int {
    if root == nil {
        return 0
    }
  
    //è¿™ç‚¹æ¯”è¾ƒç»•
    leftMax := max(0,oneSideMax(root.Left)) //oneSideMax(root.Left)ä»¥root.Leftä¸ºèµ·ç‚¹çš„æœ€å¤§è·¯å¾„å’Œï¼Œç»“æœå¯èƒ½æ˜¯ã€æ­£ã€‘æˆ–ã€è´Ÿã€‘ï¼Œè´Ÿæ•°èˆå¼ƒ
    rightMax := max(0,oneSideMax(root.Right))
  
    

  // ç»è¿‡rootçš„æœ€å¤§è·¯å¾„å’Œï¼ˆä» leftèŠ‚ç‚¹å‡ºå‘çš„æœ€å¤§è·¯ç»å’ŒleftMax + ä» rightèŠ‚ç‚¹å‡ºå‘çš„æœ€å¤§è·¯ç»å’Œ rightMax + å½“å‰çš„å€¼ root.Val )
    result = max(result,root.Val+leftMax+rightMax) 
		
 		 // ä»rootå‡ºå‘çš„æœ€å¤§è·¯å¾„å’Œ
    return max(leftMax,rightMax)+root.Val 
}

func max(a,b int)int{
    if a > b {
        return a
    }
    return b
}
```
## 72. ç¼–è¾‘è·ç¦»
ç»™ä½ ä¸¤ä¸ªå•è¯ `word1` å’Œ `word2`ï¼Œ *è¯·è¿”å›å°† *`*word1*`* è½¬æ¢æˆ *`*word2*`* æ‰€ä½¿ç”¨çš„æœ€å°‘æ“ä½œæ•°* ã€‚
ä½ å¯ä»¥å¯¹ä¸€ä¸ªå•è¯è¿›è¡Œå¦‚ä¸‹ä¸‰ç§æ“ä½œï¼š

- æ’å…¥ä¸€ä¸ªå­—ç¬¦
- åˆ é™¤ä¸€ä¸ªå­—ç¬¦
- æ›¿æ¢ä¸€ä¸ªå­—ç¬¦æ€è·¯ï¼š
è§£å†³ä¸¤ä¸ªå­—ç¬¦ä¸²çš„åŠ¨æ€è§„åˆ’é—®é¢˜ï¼Œä¸€èˆ¬éƒ½æ˜¯ç”¨ä¸¤ä¸ªæŒ‡é’ˆ `i, j` åˆ†åˆ«æŒ‡å‘ä¸¤ä¸ªå­—ç¬¦ä¸²çš„æœ€åï¼Œç„¶åä¸€æ­¥æ­¥å¾€å‰èµ°ï¼Œç¼©å°é—®é¢˜çš„è§„æ¨¡ã€‚
å¯¹äºæ¯å¯¹å­—ç¬¦ `s1[i]` å’Œ `s2[j]`ï¼Œå¯ä»¥æœ‰å››ç§æ“ä½œï¼š

```go
if s1[i] == s2[j]:
    å•¥éƒ½åˆ«åšï¼ˆskipï¼‰
    i, j åŒæ—¶å‘å‰ç§»åŠ¨
else:
    ä¸‰é€‰ä¸€ï¼š
        æ’å…¥ï¼ˆinsertï¼‰
        åˆ é™¤ï¼ˆdeleteï¼‰
        æ›¿æ¢ï¼ˆreplaceï¼‰
```

- `dp`æ•°ç»„å®šä¹‰ï¼š `i`å’Œ`j`è¡¨ç¤ºå­—ç¬¦ä¸²é•¿åº¦ï¼Œ`dp[i][j]`è¡¨ç¤ºæœ€å°æ“ä½œæ•°
- é€’æ¨å…³ç³»ï¼š `i`å’Œ`j`è¡¨ç¤ºå­—ç¬¦ä¸²é•¿åº¦ï¼Œ `i-1` å’Œ `j-1`æ‰è¡¨ç¤ºæœ€åä¸€ä¸ªå­—ç¬¦çš„ç´¢å¼•
```go
if word1[i-1] == word2[j-1] {
	dp[i][j] = dp[i-1][j-1] //ä¸éœ€è¦æ“ä½œ
} else {
  dp[i-1][j] // iåˆ é™¤ jä¸å˜
  dp[i][j-1] // iä¸å˜ï¼Œåœ¨iåé¢æ–°å¢ä¸€ä¸ªå…ƒç´ å’Œjç›¸åŒ(ä¹Ÿå¯ä»¥ç†è§£ä¸º iä¸å˜ï¼Œåˆ é™¤j)
  dp[i-1][j-1] // iå’ŒjåŒæ—¶replaceä¸ºåŒä¸€ä¸ªå…ƒç´ 
  
  dp[i][j] = min( dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+1 )
}
```
ä»£ç å®ç°ï¼š

```go
func minDistance(word1 string, word2 string) int {
    
    m,n := len(word1),len(word2)
  	// 1.å®šä¹‰ dpæ•°ç»„
    dp := make([][]int,m+1)
    for k,_ := range dp {
        dp[k] = make([]int,n+1)
    }
  	// 2. åˆå§‹åŒ– base case
    for i := 0;i <= m;i++ { // word2 å­—ç¬¦ä¸²ä¸ºç©º
        dp[i][0] = i // éœ€è¦çš„æ“ä½œæ¬¡æ•°ï¼Œæ–°å¢iæ¬¡å…ƒç´ 
    }
    for j := 0;j<=n;j++ { // word1 å­—ç¬¦ä¸²ä¸ºç©º
        dp[0][j] = j // éœ€è¦çš„æ“ä½œæ¬¡æ•°ï¼Œæ–°å¢jæ¬¡å…ƒç´ 
    }
		
  	//3. ä¸€èˆ¬é€’æ¨å…³ç³»
    for i := 1;i<=m;i++ {
        for j := 1;j<=n;j++ {
            if word1[i-1] == word2[j-1] {
                dp[i][j] = dp[i-1][j-1]
            } else {
                dp[i][j] = min(min(dp[i-1][j]+1,dp[i][j-1]+1),dp[i-1][j-1]+1)
            }
        }
    }
    return dp[m][n]
}

func min(a,b int)int{
    if a < b {
        return a
    }
    return b
}
```
## 93.å¤åŸIPåœ°å€
**æœ‰æ•ˆ IP åœ°å€** æ­£å¥½ç”±å››ä¸ªæ•´æ•°ï¼ˆæ¯ä¸ªæ•´æ•°ä½äº `0` åˆ° `255` ä¹‹é—´ç»„æˆï¼Œä¸”ä¸èƒ½å«æœ‰å‰å¯¼ `0`ï¼‰ï¼Œæ•´æ•°ä¹‹é—´ç”¨ `'.'` åˆ†éš”ã€‚

- ä¾‹å¦‚ï¼š`"0.1.2.201"` å’Œ` "192.168.1.1"` æ˜¯ **æœ‰æ•ˆ** IP åœ°å€ï¼Œä½†æ˜¯ `"0.011.255.245"`ã€`"192.168.1.312"` å’Œ `"192.168@1.1"` æ˜¯ **æ— æ•ˆ** IP åœ°å€ã€‚ç»™å®šä¸€ä¸ªåªåŒ…å«æ•°å­—çš„å­—ç¬¦ä¸² `s` ï¼Œç”¨ä»¥è¡¨ç¤ºä¸€ä¸ª IP åœ°å€ï¼Œè¿”å›æ‰€æœ‰å¯èƒ½çš„**æœ‰æ•ˆ IP åœ°å€**ï¼Œè¿™äº›åœ°å€å¯ä»¥é€šè¿‡åœ¨ `s` ä¸­æ’å…¥ `'.'` æ¥å½¢æˆã€‚ä½  **ä¸èƒ½** é‡æ–°æ’åºæˆ–åˆ é™¤ `s` ä¸­çš„ä»»ä½•æ•°å­—ã€‚ä½ å¯ä»¥æŒ‰ **ä»»ä½•** é¡ºåºè¿”å›ç­”æ¡ˆã€‚
æ€è·¯ï¼š

- `for`å¾ªç¯æ¯å®Œæˆä¸€ç»„`[start,i]`æ•°å­—çš„æˆªå–ï¼Œå‰©ä¸‹çš„å­—ç¬¦ä¸²ç•™ç»™ä¸‹ä¸€ä¸ªé€’å½’å‡½æ•°æˆªå–![a8e3ad37-ee5a-40e2-8b78-e3610eabc221.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411704919-a8e3ad37-ee5a-40e2-8b78-e3610eabc221.png)


```go
var result []string
func restoreIpAddresses(s string) []string {

    trace := []string{} //è®°å½•æ¯ä¸ªåˆ†æ®µ
  	
    result = []string{}
    backtrack(s,0,trace)
    return result
}

func backtrack(s string , start int ,trace []string) {
  	// ç»ˆæ­¢æ¡ä»¶
		// æ•´ä¸ªå­—ç¬¦ä¸²séœ€è¦æ­£å¥½è¢«å®Œæ•´åˆ†å‰²
    if start == len(s) && len(trace) == 4 {
        result = append(result,strings.Join(trace,".")) // åˆ†å‰²ç¨‹4ä¸ªéƒ¨åˆ†ï¼Œæ‹¼æ¥æˆ ipåœ°å€çš„æ ¼å¼
        return
    }

    if len(trace) >= 4 { // åˆ°startä½ç½®ï¼Œå¦‚æœå·²ç»æ‹†åˆ†è¶…è¿‡äº†4æ®µï¼Œ[start,...]åé¢çš„ä½ç½®æ²¡å¿…è¦ç»§ç»­æ‹†åˆ†äº†
        return 
    }

    for i := start;i < len(s);i++ {

        if !isVaild(s,start,i) { // åˆ¤æ–­ [start,i] æ˜¯å¦æ˜¯æœ‰æ•ˆçš„å­—ç¬¦ä¸²
            continue // ç»§ç»­æ‰©å¤§i
        }

        // é€‰æ‹© [start,i]
        trace = append(trace,s[start:i+1])
        backtrack(s,i+1,trace) // ç»§ç»­ä¸‹ä¸€ä¸ªç‰‡æ®µçš„æˆªå–
				// æ’¤é”€é€‰æ‹©
        trace = trace[:len(trace)-1]
    }
}

func isVaild(s string, start ,end int) bool {
    //1.é•¿åº¦åªèƒ½æ˜¯1-3ä¹‹é—´
    length := end - start+1

    if length > 3|| length == 0 {
        return false
    }
    //2.é•¿åº¦å¤§äº1çš„è¯ï¼Œå¦‚æœå‰ç¼€å‡ºç°å­—ç¬¦0ï¼Œæ˜¯ä¸æ­£ç¡®
    if length > 1 &&  s[start] == '0' { 
        return false
    }

    //3. åˆ¤æ–­æ˜¯å¦åœ¨ 255 èŒƒå›´å†…
    val ,_ := strconv.Atoi(s[start:end+1])
    if val > 255 {
        return false
    }
    return true
}
```
## 19.åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬Nä¸ªç»“ç‚¹
ç»™ä½ ä¸€ä¸ªé“¾è¡¨ï¼Œåˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬ `n` ä¸ªç»“ç‚¹ï¼Œå¹¶ä¸”è¿”å›é“¾è¡¨çš„å¤´ç»“ç‚¹ã€‚
![584ec3a6-351b-4567-a7ea-af1aa762ff66.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411705286-584ec3a6-351b-4567-a7ea-af1aa762ff66.png)

æ€è·¯ï¼š
è¦åˆ é™¤å€’æ•°ç¬¬ `n` ä¸ªèŠ‚ç‚¹ï¼Œå°±å¾—è·å¾—å€’æ•°ç¬¬ `n + 1` ä¸ªèŠ‚ç‚¹çš„å¼•ç”¨ã€‚

- ç¬¬ä¸€æ­¥ï¼Œæˆ‘ä»¬å…ˆè®©ä¸€ä¸ªæŒ‡é’ˆ `p1` æŒ‡å‘é“¾è¡¨çš„å¤´èŠ‚ç‚¹ `head`ï¼Œç„¶åèµ° `k` æ­¥ï¼š![ce9a0a9f-2065-4ff9-90f5-71231209dbb4.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411705239-ce9a0a9f-2065-4ff9-90f5-71231209dbb4.png)


- ç¬¬äºŒæ­¥ï¼Œç”¨ä¸€ä¸ªæŒ‡é’ˆ `p2` æŒ‡å‘é“¾è¡¨å¤´èŠ‚ç‚¹ `head`ï¼š![66d9cff9-d839-4eec-8f07-7176a03732ea.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411705231-66d9cff9-d839-4eec-8f07-7176a03732ea.png)


- ç¬¬ä¸‰æ­¥ï¼Œè®© `p1` å’Œ `p2` åŒæ—¶å‘å‰èµ°ï¼Œ`p1` èµ°åˆ°é“¾è¡¨æœ«å°¾çš„ç©ºæŒ‡é’ˆæ—¶èµ°äº† `n - k` æ­¥ï¼Œ`p2` ä¹Ÿèµ°äº† `n - k` æ­¥ï¼Œä¹Ÿå°±æ˜¯é“¾è¡¨çš„å€’æ•°ç¬¬ `k` ä¸ªèŠ‚ç‚¹ï¼š![13e41cf3-cc08-44f8-8f1d-654bf33c28a3.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411705414-13e41cf3-cc08-44f8-8f1d-654bf33c28a3.png)

è¿™æ ·ï¼Œåªéå†äº†ä¸€æ¬¡é“¾è¡¨ï¼Œå°±è·å¾—äº†å€’æ•°ç¬¬ `k` ä¸ªèŠ‚ç‚¹ `p2`ã€‚
è§£æ³•ä¸­åœ¨é“¾è¡¨å¤´éƒ¨æ¥ä¸€ä¸ªè™šæ‹ŸèŠ‚ç‚¹ `dummy` æ˜¯ä¸ºäº†é¿å…åˆ é™¤å€’æ•°ç¬¬ä¸€ä¸ªå…ƒç´ æ—¶å‡ºç°ç©ºæŒ‡é’ˆå¼‚å¸¸ï¼Œåœ¨å¤´éƒ¨åŠ å…¥ `dummy` èŠ‚ç‚¹å¹¶ä¸å½±å“å°¾éƒ¨å€’æ•°ç¬¬ `k` ä¸ªå…ƒç´ æ˜¯ä»€ä¹ˆã€‚

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func removeNthFromEnd(head *ListNode, n int) *ListNode {
    //éœ€è¦é¢å¤–åŠ ä¸€ä¸ªè™šæ‹ŸèŠ‚ç‚¹
    dummy := &ListNode{Val:0}
    dummy.Next = head

    //æŸ¥æ‰¾å€’æ•°ç¬¬Nä¸ªèŠ‚ç‚¹ï¼ˆè¿™é‡Œæ˜¯æ‰¾n+1èŠ‚ç‚¹ï¼‰
    node := findN(dummy,n+1) 
  	// åˆ é™¤ n èŠ‚ç‚¹
    node.Next = node.Next.Next
    return dummy.Next
}


func findN(head *ListNode,n int) *ListNode {
  	// a b éƒ½æŒ‡å‘é“¾è¡¨å¤´éƒ¨
    a,b := head,head
  	// a å…ˆç§»åŠ¨
    for i := 0;i<n;i++{
        a = a.Next
    }
	
    for a != nil {
        a = a.Next //a åˆ°è¾¾å°¾éƒ¨
        b = b.Next //b æŒ‡å‘çš„å°±æ˜¯ç¬¬nä¸ªèŠ‚ç‚¹
    }
    return b
}
```
## 1143.æœ€é•¿å…¬å…±å­åºåˆ—
ç»™å®šä¸¤ä¸ªå­—ç¬¦ä¸² `text1` å’Œ `text2`ï¼Œè¿”å›è¿™ä¸¤ä¸ªå­—ç¬¦ä¸²çš„æœ€é•¿ **å…¬å…±å­åºåˆ—** çš„é•¿åº¦ã€‚å¦‚æœä¸å­˜åœ¨ **å…¬å…±å­åºåˆ—** ï¼Œè¿”å› `0` ã€‚
ä¸€ä¸ªå­—ç¬¦ä¸²çš„ **å­åºåˆ—** æ˜¯æŒ‡è¿™æ ·ä¸€ä¸ªæ–°çš„å­—ç¬¦ä¸²ï¼šå®ƒæ˜¯ç”±åŸå­—ç¬¦ä¸²åœ¨ä¸æ”¹å˜å­—ç¬¦çš„ç›¸å¯¹é¡ºåºçš„æƒ…å†µä¸‹åˆ é™¤æŸäº›å­—ç¬¦ï¼ˆä¹Ÿå¯ä»¥ä¸åˆ é™¤ä»»ä½•å­—ç¬¦ï¼‰åç»„æˆçš„æ–°å­—ç¬¦ä¸²ã€‚

- ä¾‹å¦‚ï¼Œ`"ace"` æ˜¯ `"abcde"` çš„å­åºåˆ—ï¼Œä½† `"aec"` ä¸æ˜¯ `"abcde"` çš„å­åºåˆ—ã€‚ä¸¤ä¸ªå­—ç¬¦ä¸²çš„ **å…¬å…±å­åºåˆ—** æ˜¯è¿™ä¸¤ä¸ªå­—ç¬¦ä¸²æ‰€å…±åŒæ‹¥æœ‰çš„å­åºåˆ—ã€‚
æ€è·¯ï¼š

- åŠ¨æ€è§„åˆ’ï¼šå’Œ [72. ç¼–è¾‘è·ç¦»](https://leetcode.cn/problems/edit-distance) åŒä¸ºç»å…¸çš„åŒå­—ç¬¦ä¸²åŠ¨æ€è§„åˆ’é—®é¢˜ã€‚
- `dp[i][j]`å®šä¹‰ï¼šè¡¨ç¤º`text1`ä¸­`[0,i-1]`é•¿åº¦ä¸º`i`å­—ç¬¦ä¸² å’Œ`text2`ä¸­`[0,j-1`]é•¿åº¦ä¸º`j`å­—ç¬¦ä¸²ï¼Œå…¬å…±å­åºåˆ—çš„æœ€é•¿é•¿åº¦
- é€’æ¨å…³ç³»ï¼š![36a1a462-4124-4c93-a9bc-105332825b51.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411705514-36a1a462-4124-4c93-a9bc-105332825b51.png)

![c392e87c-051d-46b7-9a3b-6b0c85f986b6.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411705917-c392e87c-051d-46b7-9a3b-6b0c85f986b6.png)


```go
func longestCommonSubsequence(text1 string, text2 string) int {
   
    m := len(text1)
    n := len(text2)
		
  	//base case dp[0][...] = dp[...][0] = 0
    dp := make([][]int,m+1)
    for i := 0;i < m+1 ;i++ {
        dp[i] = make([]int,n+1)
    }
		// //iå’Œjè¡¨ç¤ºå­—ç¬¦ä¸²é•¿åº¦
    for i := 1;i <= m;i++ { 
        for j := 1;j <=n ;j++ {
            if text1[i-1] == text2[j-1] { //è¯´æ˜å°¾éƒ¨çš„å­—ç¬¦ç›¸åŒï¼Œç®—ä½œä¸€ä¸ªå…¬å…±å­—ç¬¦
                dp[i][j] = 1 + dp[i-1][j-1]
            } else {
                dp[i][j] = max(dp[i-1][j],dp[i][j-1]) //å¯èƒ½[i-1][j]å°¾éƒ¨å­—ç¬¦ç›¸åŒ æˆ–è€… [i][j-1]å°¾éƒ¨å­—ç¬¦ç›¸åŒ
            }
        }
    }
    return dp[m][n]
}

func max( a,b int)int{
    if a > b {
        return a
    }
    return b
}
```
## 82.åˆ é™¤æ’åºé“¾è¡¨ä¸­çš„é‡å¤å…ƒç´ II
ç»™å®šä¸€ä¸ªå·²æ’åºçš„é“¾è¡¨çš„å¤´ `head` ï¼Œ *åˆ é™¤åŸå§‹é“¾è¡¨ä¸­æ‰€æœ‰é‡å¤æ•°å­—çš„èŠ‚ç‚¹ï¼Œåªç•™ä¸‹ä¸åŒçš„æ•°å­—* ã€‚è¿”å› *å·²æ’åºçš„é“¾è¡¨* ã€‚
æ€è·¯ï¼š

- å®šä¹‰è™šæ‹ŸèŠ‚ç‚¹ `dummy`ï¼Œä¿å­˜ä¸é‡å¤çš„èŠ‚ç‚¹
- æ‰¾åˆ°èŠ‚ç‚¹å€¼ç›¸åŒçš„å·¦å³èŠ‚ç‚¹æŒ‡é’ˆï¼Œ`[left,right]`ä¹‹é—´å°±æ˜¯é‡å¤çš„æ•°å­—èŠ‚ç‚¹ï¼ˆä¸¢å¼ƒï¼‰![c113e5f7-cc8d-481d-88dd-9492a67ba748.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411705902-c113e5f7-cc8d-481d-88dd-9492a67ba748.png)


```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func deleteDuplicates(head *ListNode) *ListNode {
    // è¯´æ˜ æ²¡æœ‰èŠ‚ç‚¹ or åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹
    if head == nil || head.Next == nil {
        return head
    }
    // ç”¨æ¥ä¿å­˜ç»“æœ
    dummy := &ListNode{0,nil}
    node := dummy


    for head != nil {

        // å›ºå®šå·¦è¾¹
        left := head
        // çœ‹æ˜¯å¦æœ‰ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æ•°å€¼å’Œleftç›¸åŒ
        for head.Next != nil && left.Val == head.Next.Val {
            head = head.Next
        }

        //
        // å¦‚æœleft å’Œ head ç›¸åŒï¼Œè¯´æ˜æ²¡æœ‰ç§»åŠ¨è¿‡ã€‚å¦åˆ™ï¼Œ æ˜¯[left,head]ä¹‹é—´çš„å°±æ˜¯é‡å¤çš„å…ƒç´ ï¼ˆèˆå¼ƒï¼‰
        if left == head { // è¯´æ˜æœ¬èŠ‚ç‚¹ä¸é‡å¤ï¼Œä¿å­˜åˆ°ç»“æœä¸­
            node.Next = left
            node = node.Next
        }
        // headç§»åŠ¨ä¸€ä½ï¼Œä»ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå¼€å§‹ç»§ç»­æ¯”è¾ƒ
        head = head.Next
    }
  
    // ã€æ³¨æ„ã€‘ï¼šæ–­å¼€æœ€åä¸€ä¸ªèŠ‚ç‚¹
    node.Next = nil
    return dummy.Next
}
```
## 94. äºŒå‰æ ‘çš„ä¸­åºéå†
ç»™å®šä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œè¿”å› *å®ƒçš„ ****ä¸­åº**** éå†* ã€‚
æ€è·¯ï¼š
ä¸­åºéå†ç»“æœçš„ç‰¹ç‚¹æ˜¯ `root.val` åœ¨ä¸­é—´ï¼Œå·¦å³å­æ ‘åœ¨ä¸¤ä¾§ï¼š
æä¾›é€’å½’ + è¿­ä»£ä¸¤ç§éå†æ–¹æ³•ï¼š

- é€’å½’æ–¹æ³•ï¼š
```go
var result []int
func inorderTraversal1(root *TreeNode) []int {
    result = []int{}
    inorder(root)
    return result
}

func inorder(root *TreeNode) {
    if root == nil {
        return
    }
    inorder(root.Left) // éå† root.Left æ ‘
    result = append(result,root.Val) // å½“å‰ root.Valå€¼
    inorder(root.Right) // éå† root.Right æ ‘
}
```
![acd59612-2899-495d-ac68-bffe933071e1.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411706089-acd59612-2899-495d-ac68-bffe933071e1.png)


- è¿­ä»£æ–¹æ³•åˆ©ç”¨æ ˆï¼Œå…ˆå°†å·¦å­æ ‘å…¥æ ˆï¼Œå‡ºæ ˆçš„æ—¶å€™ï¼Œè®°å½•å‡ºæ ˆæ•°å€¼ï¼ˆæ•ˆæœç›¸å½“äºå…ˆéå†å·¦å­æ ‘ï¼Œå¾—åˆ°å·¦æ ‘çš„ä¸­åºéå†ç»“æœï¼‰ï¼›å½“å·¦å­æ ‘ä¸ºç©ºçš„æ—¶å€™ï¼Œå†å°†å³å­æ ‘å…¥æ ˆï¼ˆç­‰ä»·äºéå†å³å­æ ‘ï¼Œå¾—åˆ°å³æ ‘çš„ä¸­åºéå†ç»“æœï¼‰

```go
func inorderTraversal(root *TreeNode) []int {
    result := make([]int,0)
  	// æ ˆ
    sk := []*TreeNode{}
  
    for len(sk) != 0 || root != nil {
      	
        for root != nil {
            sk = append(sk,root) //å…¥æ ˆï¼š å°†å·¦èŠ‚ç‚¹ä¸æ–­çš„è¿½åŠ åˆ° sk ä¸­
            root = root.Left
        }
        // å‡ºæ ˆ
        root = sk[len(sk)-1]
        sk = sk[:len(sk)-1]
        result = append(result,root.Val) // ä¸­åºéå†å€¼
      	// å³èŠ‚ç‚¹ç»§ç»­å…¥æ ˆ
        root = root.Right
    }
    return result
}
```
![ad1d0575-6c14-43a2-8b3a-d0d344930786.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411706155-ad1d0575-6c14-43a2-8b3a-d0d344930786.png)

![b332ce46-1c33-4f20-bfc1-285d7d504c65.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411706150-b332ce46-1c33-4f20-bfc1-285d7d504c65.png)

## 199.äºŒå‰æ ‘çš„å³è§†å›¾
ç»™å®šä¸€ä¸ªäºŒå‰æ ‘çš„ **æ ¹èŠ‚ç‚¹**`root`ï¼Œæƒ³è±¡è‡ªå·±ç«™åœ¨å®ƒçš„å³ä¾§ï¼ŒæŒ‰ç…§ä»é¡¶éƒ¨åˆ°åº•éƒ¨çš„é¡ºåºï¼Œè¿”å›ä»å³ä¾§æ‰€èƒ½çœ‹åˆ°çš„èŠ‚ç‚¹å€¼ã€‚
æ€è·¯ï¼š
ä¸Šé¢å‡ºç°äº†å¤šæ¬¡çš„å±‚åºéå†çš„é¢˜ç›®ï¼Œè¿™ä¸ªé¢˜ç›®åªæ˜¯è¦å¾—åˆ°æ¯å±‚çš„æœ€å³è¾¹çš„èŠ‚ç‚¹å€¼
![fba85177-1b60-49fd-88cb-b1a99c4b7702.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411706405-fba85177-1b60-49fd-88cb-b1a99c4b7702.png)


```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func rightSideView(root *TreeNode) []int {
    //å±‚åºéå†
    result := []int{}
    if root == nil {
        return result
    }
  	// åˆå§‹èŠ‚ç‚¹
    nodes := []*TreeNode{}
    nodes = append(nodes,root)

    for len(nodes) != 0 {
      	// æ¯å±‚çš„èŠ‚ç‚¹æ•°
        count := len(nodes)

        for i := 0;i<count;i++ {
          
            if i == count-1 { // æ¯å±‚æœ€åä¸€ä¸ªèŠ‚ç‚¹
                result = append(result,nodes[i].Val)
            }

            if nodes[i].Left != nil {
                nodes = append(nodes,nodes[i].Left)
            }
            if nodes[i].Right != nil {
                nodes = append(nodes,nodes[i].Right)
            }
        }
        //!!!å¼¹å‡ºnodesä¸­çš„è¢«éå†è¿‡çš„èŠ‚ç‚¹
        nodes = nodes[count:]
    }
    return result
}
```
## 74.äºŒåˆ†æŸ¥æ‰¾
ç»™å®šä¸€ä¸ª `n` ä¸ªå…ƒç´ æœ‰åºçš„ï¼ˆå‡åºï¼‰æ•´å‹æ•°ç»„ `nums` å’Œä¸€ä¸ªç›®æ ‡å€¼ `target` ï¼Œå†™ä¸€ä¸ªå‡½æ•°æœç´¢ `nums` ä¸­çš„ `target`ï¼Œå¦‚æœç›®æ ‡å€¼å­˜åœ¨è¿”å›ä¸‹æ ‡ï¼Œå¦åˆ™è¿”å› `-1`ã€‚
æ€è·¯ï¼š
äºŒåˆ†æœç´¢ç®—æ³•æœ€åŸºç¡€çš„é¢˜ç›®ï¼š å®šä¹‰`left right`æŒ‡å‘æ•°ç»„çš„ä¸¤ç«¯ï¼Œé€šè¿‡`target`å’Œ `nums[mid]`å€¼æ¯”è¾ƒï¼Œç¼©å°æœç´¢èŒƒå›´ï¼Œç›´åˆ°æ‰¾åˆ°ç›®æ ‡å€¼

```go
func search(nums []int, target int) int {
  	// å®šä¹‰ left right 
    left,right := 0,len(nums)-1
  
    for left <= right {
      	// ä¸­é—´ç´¢å¼•
        mid := left+(right-left)/2
      	
        if nums[mid] == target { // æ‰¾åˆ°ç›®æ ‡å€¼
            return mid
        } else if nums[mid] > target { // è¯´æ˜ç›®æ ‡å€¼åœ¨ [left,mid-1]ä¹‹é—´
            right = mid-1
        } else { // è¯´æ˜ç›®æ ‡å€¼åœ¨[mid+1,right] ä¹‹é—´
            left = mid+1
        }
    }
    return -1
}
```
## 232.ç”¨æ ˆå®ç°é˜Ÿåˆ—
è¯·ä½ ä»…ä½¿ç”¨ä¸¤ä¸ªæ ˆå®ç°å…ˆå…¥å…ˆå‡ºé˜Ÿåˆ—ã€‚é˜Ÿåˆ—åº”å½“æ”¯æŒä¸€èˆ¬é˜Ÿåˆ—æ”¯æŒçš„æ‰€æœ‰æ“ä½œï¼ˆ`push`ã€`pop`ã€`peek`ã€`empty`ï¼‰ï¼š
å®ç° `MyQueue` ç±»ï¼š

- `void push(int x)` å°†å…ƒç´  x æ¨åˆ°é˜Ÿåˆ—çš„æœ«å°¾
- `int pop()` ä»é˜Ÿåˆ—çš„å¼€å¤´ç§»é™¤å¹¶è¿”å›å…ƒç´ 
- `int peek()` è¿”å›é˜Ÿåˆ—å¼€å¤´çš„å…ƒç´ 
- `boolean empty()` å¦‚æœé˜Ÿåˆ—ä¸ºç©ºï¼Œè¿”å› `true` ï¼›å¦åˆ™ï¼Œè¿”å› `false`![474bc009-a797-4be8-9618-18c2fefb39e4.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411706495-474bc009-a797-4be8-9618-18c2fefb39e4.png)


```go
//æ ¸å¿ƒæ€æƒ³ï¼š
//å…¥æ ˆï¼šå¯¹stack1å…¥æ ˆ
//å‡ºæ ˆï¼šåˆ¤æ–­stack2æ˜¯å¦ä¸ºç©ºï¼›ä¸ä¸ºç©ºï¼šå‡ºæ ˆstack2ã€‚ã€‚ã€‚å¦‚æœä¸ºç©ºï¼Œéœ€è¦å°†stack1ä¸­çš„æ”¾å…¥åˆ°stack2ä¸­

type MyQueue struct {
    sk1 []int
    sk2 []int
}


func Constructor() MyQueue {
    mq := MyQueue{}
    mq.sk1 = make([]int,0)
    mq.sk2 = make([]int,0)
    return mq
}

// å…¥æ ˆ
func (this *MyQueue) Push(x int)  {
    this.sk1 = append(this.sk1,x)
}

// å‡ºæ ˆ
func (this *MyQueue) Pop() int {
  	// sk2 ä¸ä¸ºç©ºï¼Œç›´æ¥å‡ºæ ˆ
    if len(this.sk2) != 0 {
        val := this.sk2[len(this.sk2)-1]
        this.sk2 = this.sk2[:len(this.sk2)-1]
        return val
    } else if len(this.sk1) != 0 { // sk2ä¸ºç©ºï¼Œä½†æ˜¯sk1ä¸ä¸ºç©º

        for j := len(this.sk1)-1;j>= 0;j-- { //æŠŠsk1ä¸­çš„å…ƒç´ ï¼Œå€’ç€æ”¾å…¥åˆ°sk2ä¸­
            this.sk2 = append(this.sk2,this.sk1[j])
        }
        //!!!æ¸…ç©º
        this.sk1 = []int{}
      	// å‡ºæ ˆ sk2
        val := this.sk2[len(this.sk2)-1]
        this.sk2 = this.sk2[:len(this.sk2)-1]
        return val
    }

    return 0
}

// é¢„è§ˆ
func (this *MyQueue) Peek() int {
    if len(this.sk2) != 0 {
        val := this.sk2[len(this.sk2)-1]
        //this.sk2 = this.sk2[:len(this.sk2-1)]
        return val
    } else if len(this.sk1) != 0 {
       for j := len(this.sk1)-1;j>= 0;j-- { //æŠŠsk1ä¸­çš„å…ƒç´ ï¼Œå€’ç€æ”¾å…¥åˆ°sk2ä¸­
            this.sk2 = append(this.sk2,this.sk1[j])
        }
        //!!!æ¸…ç©º
        this.sk1 = []int{}
        val := this.sk2[len(this.sk2)-1]
        //this.sk2 = this.sk2[:len(this.sk2)-1]
        return val
    }

    return 0
}

func (this *MyQueue) Empty() bool {
    if len(this.sk2) == 0 && len(this.sk1) == 0 {
        return true
    }
    return false
}
```
## 148. æ’åºé“¾è¡¨
ç»™ä½ é“¾è¡¨çš„å¤´ç»“ç‚¹ `head` ï¼Œè¯·å°†å…¶æŒ‰ **å‡åº** æ’åˆ—å¹¶è¿”å› **æ’åºåçš„é“¾è¡¨** ã€‚
æ€è·¯ï¼š

- åˆ©ç”¨å¤–æ…¢æŒ‡é’ˆæŠ€å·§ï¼Œå…ˆæ‰¾åˆ°é“¾è¡¨çš„ä¸­é—´èŠ‚ç‚¹
- åˆ©ç”¨ä¸­é—´èŠ‚ç‚¹ï¼Œå°†é“¾è¡¨åˆ†æˆä¸¤ä¸ªå­é“¾è¡¨ï¼Œåˆ†åˆ«å¯¹å­é“¾è¡¨è¿›è¡Œæ’åº
- æœ€åå†å°†ä¸¤ä¸ªæœ‰åºå­é“¾è¡¨ï¼Œåˆå¹¶æˆä¸€ä¸ªæœ€ç»ˆçš„ç»“æœ![dd310bd4-dcba-4388-b054-94203ddcdac5.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411706877-dd310bd4-dcba-4388-b054-94203ddcdac5.png)


```go
func sortList(head *ListNode) *ListNode {
    
    if head == nil || head.Next == nil { //ã€ç©ºé“¾è¡¨ã€‘ æˆ–è€… ã€åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹çš„é“¾è¡¨ã€‘
        return head
    }

    // å¿«æ…¢æŒ‡é’ˆæ‰¾åˆ°ä¸­é—´èŠ‚ç‚¹ï¼Œå¹¶ä¸”åˆ‡å¼€æˆä¸¤ä¸ªéƒ¨åˆ†
    fast,slow := head,head
    pre := head 
    for fast != nil && fast.Next != nil { 
        fast = fast.Next.Next
        pre = slow  // ï¼ï¼ï¼è¿™ä¸ªå¾ˆé‡è¦ï¼Œå­˜å‚¨ä¸­ç‚¹çš„ã€å‰ç½®èŠ‚ç‚¹ã€‘
        slow = slow.Next
    }
    pre.Next = nil //ï¼ï¼ï¼ç›®çš„ï¼šæ‰¾åˆ°ä¸­é—´èŠ‚ç‚¹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œä½¿ã€å·¦å³é“¾è¡¨æ–­å¼€ã€‘
    
    l1 := sortList(head) //å·¦é“¾è¡¨
    l2 := sortList(slow) //å³é“¾è¡¨
    return merge(l1,l2)
}

func merge(l1,l2 *ListNode) *ListNode {
  	//1.åˆ›å»ºä¸€ä¸ªè™šæ‹ŸèŠ‚ç‚¹dummy
    dummy := &ListNode{0,nil}
    cur := dummy
		
  	//2.åˆå¹¶ä¸¤ä¸ªå‡åºé“¾è¡¨ï¼Œæ‹¼æ¥åˆ°curåé¢
    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            cur.Next = l1
            l1 = l1.Next
        } else {
            cur.Next = l2
            l2 = l2.Next
        }
        cur = cur.Next
    }

    if l1 != nil {
        cur.Next = l1
    }

    if l2 != nil {
        cur.Next = l2
    }

    return dummy.Next
}
```
## 31.ä¸‹ä¸€ä¸ªæ’åˆ—
æ•´æ•°æ•°ç»„çš„ä¸€ä¸ª **æ’åˆ—** å°±æ˜¯å°†å…¶æ‰€æœ‰æˆå‘˜ä»¥åºåˆ—æˆ–çº¿æ€§é¡ºåºæ’åˆ—ã€‚

- ä¾‹å¦‚ï¼Œ`arr = [1,2,3]` ï¼Œä»¥ä¸‹è¿™äº›éƒ½å¯ä»¥è§†ä½œ `arr` çš„æ’åˆ—ï¼š`[1,2,3]`ã€`[1,3,2]`ã€`[3,1,2]`ã€`[2,3,1]` ã€‚æ•´æ•°æ•°ç»„çš„ **ä¸‹ä¸€ä¸ªæ’åˆ—** æ˜¯æŒ‡å…¶æ•´æ•°çš„ä¸‹ä¸€ä¸ªå­—å…¸åºæ›´å¤§çš„æ’åˆ—ã€‚æ›´æ­£å¼åœ°ï¼Œå¦‚æœæ•°ç»„çš„æ‰€æœ‰æ’åˆ—æ ¹æ®å…¶å­—å…¸é¡ºåºä»å°åˆ°å¤§æ’åˆ—åœ¨ä¸€ä¸ªå®¹å™¨ä¸­ï¼Œé‚£ä¹ˆæ•°ç»„çš„ **ä¸‹ä¸€ä¸ªæ’åˆ—** å°±æ˜¯åœ¨è¿™ä¸ªæœ‰åºå®¹å™¨ä¸­æ’åœ¨å®ƒåé¢çš„é‚£ä¸ªæ’åˆ—ã€‚å¦‚æœä¸å­˜åœ¨ä¸‹ä¸€ä¸ªæ›´å¤§çš„æ’åˆ—ï¼Œé‚£ä¹ˆè¿™ä¸ªæ•°ç»„å¿…é¡»é‡æ’ä¸ºå­—å…¸åºæœ€å°çš„æ’åˆ—ï¼ˆå³ï¼Œå…¶å…ƒç´ æŒ‰å‡åºæ’åˆ—ï¼‰ã€‚

- ä¾‹å¦‚ï¼Œ`arr = [1,2,3]` çš„ä¸‹ä¸€ä¸ªæ’åˆ—æ˜¯ `[1,3,2]` ã€‚
- ç±»ä¼¼åœ°ï¼Œ`arr = [2,3,1]` çš„ä¸‹ä¸€ä¸ªæ’åˆ—æ˜¯ `[3,1,2]` ã€‚
- è€Œ `arr = [3,2,1]` çš„ä¸‹ä¸€ä¸ªæ’åˆ—æ˜¯ `[1,2,3]` ï¼Œå› ä¸º `[3,2,1]` ä¸å­˜åœ¨ä¸€ä¸ªå­—å…¸åºæ›´å¤§çš„æ’åˆ—ã€‚ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums` ï¼Œæ‰¾å‡º `nums` çš„ä¸‹ä¸€ä¸ªæ’åˆ—ã€‚
å¿…é¡»**[åŸåœ°](https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)**ä¿®æ”¹ï¼Œåªå…è®¸ä½¿ç”¨é¢å¤–å¸¸æ•°ç©ºé—´ã€‚
æ€è·¯ï¼š
ä»¥ `1,2,3,4,5,6` ä¸ºä¾‹ï¼Œå…¶æ’åˆ—ä¾æ¬¡ä¸ºï¼š

```go
123456
123465
123546
...
654321
```
å¯ä»¥çœ‹åˆ°æœ‰è¿™æ ·çš„å…³ç³»ï¼š`123456 < 123465 < 123546 < ... < 654321`ã€‚

- æˆ‘ä»¬å¸Œæœ›ä¸‹ä¸€ä¸ªæ•° æ¯”å½“å‰æ•°å¤§ï¼Œè¿™æ ·æ‰æ»¡è¶³ â€œä¸‹ä¸€ä¸ªæ’åˆ—â€ çš„å®šä¹‰ã€‚å› æ­¤åªéœ€è¦ å°†åé¢çš„ã€Œå¤§æ•°ã€ä¸å‰é¢çš„ã€Œå°æ•°ã€äº¤æ¢ï¼Œå°±èƒ½å¾—åˆ°ä¸€ä¸ªæ›´å¤§çš„æ•°ã€‚æ¯”å¦‚ 123456ï¼Œå°† 5 å’Œ 6 äº¤æ¢å°±èƒ½å¾—åˆ°ä¸€ä¸ªæ›´å¤§çš„æ•° 123465
- æˆ‘ä»¬è¿˜å¸Œæœ›ä¸‹ä¸€ä¸ªæ•° å¢åŠ çš„å¹…åº¦å°½å¯èƒ½çš„å°ï¼Œè¿™æ ·æ‰æ»¡è¶³â€œä¸‹ä¸€ä¸ªæ’åˆ—ä¸å½“å‰æ’åˆ—ç´§é‚»â€œçš„è¦æ±‚ã€‚ä¸ºäº†æ»¡è¶³è¿™ä¸ªè¦æ±‚ï¼Œæˆ‘ä»¬éœ€è¦ï¼š
- åœ¨å°½å¯èƒ½**é å³çš„ä½ä½**è¿›è¡Œäº¤æ¢ï¼Œéœ€è¦**ä»åå‘å‰**æŸ¥æ‰¾
- å°†ä¸€ä¸ª å°½å¯èƒ½å°çš„ã€Œå¤§æ•°ã€ ä¸å‰é¢çš„ã€Œå°æ•°ã€äº¤æ¢ã€‚æ¯”å¦‚ 123465ï¼Œä¸‹ä¸€ä¸ªæ’åˆ—åº”è¯¥æŠŠ 5 å’Œ 4 äº¤æ¢è€Œä¸æ˜¯æŠŠ 6 å’Œ 4 äº¤æ¢
- å°†ã€Œå¤§æ•°ã€æ¢åˆ°å‰é¢åï¼Œéœ€è¦å°†ã€Œå¤§æ•°ã€åé¢çš„æ‰€æœ‰æ•° é‡ç½®ä¸ºå‡åºï¼Œå‡åºæ’åˆ—å°±æ˜¯æœ€å°çš„æ’åˆ—ã€‚ä»¥ 123465 ä¸ºä¾‹ï¼šé¦–å…ˆæŒ‰ç…§ä¸Šä¸€æ­¥ï¼Œäº¤æ¢ 5 å’Œ 4ï¼Œå¾—åˆ° 1235 64ï¼›ç„¶åéœ€è¦å°† 5 ä¹‹åçš„æ•°é‡ç½®ä¸ºå‡åºï¼Œå¾—åˆ° 1235 46ã€‚æ˜¾ç„¶ 1235 46 æ¯” 1235 64 æ›´å°ï¼Œ123546 å°±æ˜¯ 123465 çš„ä¸‹ä¸€ä¸ªæ’åˆ—è¿™ä¸ªå°±æ˜¯æ¨åˆ°ä¸‹ä¸€ä¸ªæ’åˆ—çš„åŸºæœ¬è§„åˆ™

1. å°½å¯èƒ½çš„åœ¨å³è¾¹äº¤æ¢
2. å°½å¯èƒ½è®©å°½å¯èƒ½å°çš„ã€å¤§æ•°ã€‘å’Œå‰é¢çš„ã€å°æ•°ã€‘äº¤äº’
3. äº¤æ¢å®Œæˆåï¼Œå¯¹åç»­çš„æ•°è¿›è¡Œå‡åºæ’åˆ—
```go
func nextPermutation(nums []int)  {
  	///ï¼ï¼ï¼è¿™é¢˜çš„æ€è·¯ä¸€èˆ¬å¾ˆéš¾æƒ³å‡ºæ¥ï¼ˆæ›´å¤šçš„æ˜¯æ‰¾è§„å¾‹ï¼‰

 	 i := len(nums)-2 // ä»å€’æ•°ç¬¬äºŒæ•°å­—å¼€å§‹ï¼ˆç›®çš„ï¼šæˆ‘ä»¬è¦æ‰¾åé¢çš„æ•°ã€å¤§ã€‘ å‰é¢çš„æ•°ã€å°ã€‘ï¼Œæ¯”å¦‚: 123456ä¸­çš„ 5å’Œ6ï¼‰
    for i >= 0 && nums[i] >= nums[i+1] { // è¯´æ˜ä»ã€åå‘å‰ã€‘æ˜¯å‡åºæ’åˆ—ï¼ˆæ¯”å¦‚ 654321 ä¹Ÿå°±æ˜¯è¯´ï¼šåé¢çš„æ•°ã€å°ã€‘ï¼Œè€Œä¸æ˜¯ã€å¤§ã€‘ï¼‰
        i--
    }
   
		
    if i >= 0 { //è¯´æ˜æ‰¾åˆ°äº†ã€åé¢çš„æ•°å¤§ã€‘å‰é¢çš„æ•°ã€å°ã€‘çš„ç´¢å¼•ä½ç½®,æ¯”å¦‚ 1234 65ï¼Œä¸­çš„æ•°å€¼4çš„ä½ç½®
        end := len(nums)-1
        for end >= 0 &&  nums[i] >= nums[end] { // ä»åå‘å‰ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªæ¯”iç¨å¾®å¤§çš„æ•°ï¼Œæ¯”å¦‚ 1234 65ï¼Œä¸­çš„æ•°å€¼ 5
            end--
        }
        //äº¤æ¢
        nums[i],nums[end] = nums[end],nums[i]
    }

    //å¯¹i+1åçš„æ•°å­—å‡åºæ’åº[i+1,len(nums)-1] ï¼Œæ¯”å¦‚ 1235 64ï¼Œæ’åºåå˜æˆ 1235 46
    l,r := i+1,len(nums)-1
    for l < r {
        nums[l],nums[r] = nums[r],nums[l]
        l++
        r--
    }
}
```
## 22.æ‹¬å·ç”Ÿæˆ
æ•°å­— `n` ä»£è¡¨ç”Ÿæˆæ‹¬å·çš„å¯¹æ•°ï¼Œè¯·ä½ è®¾è®¡ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºèƒ½å¤Ÿç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„å¹¶ä¸” **æœ‰æ•ˆçš„** æ‹¬å·ç»„åˆã€‚
æ€è·¯ï¼š

- åˆ©ç”¨å›æº¯ç®—æ³•ï¼Œåœ¨æ¯ä¸ªä½ç½®é€‰æ‹©ã€å·¦æ‹¬å·ã€‘æˆ–è€…ã€å³æ‹¬å·ã€‘ï¼Œç»„æˆæ‹¬å·ç»„åˆ
- ä¸ºäº†å‡å°‘ä¸å¿…è¦çš„ç©·ä¸¾ï¼Œæˆ‘ä»¬è¦çŸ¥é“åˆæ³•æ‹¬å·ä¸²æœ‰ä»¥ä¸‹æ€§è´¨
- **ä¸€ä¸ªã€Œåˆæ³•ã€æ‹¬å·ç»„åˆçš„å·¦æ‹¬å·æ•°é‡ä¸€å®šç­‰äºå³æ‹¬å·æ•°é‡ï¼Œè¿™ä¸ªå¾ˆå¥½ç†è§£**ã€‚
- **å¯¹äºä¸€ä¸ªã€Œåˆæ³•ã€çš„æ‹¬å·å­—ç¬¦ä¸²ç»„åˆ **`**p**`**ï¼Œå¿…ç„¶å¯¹äºä»»ä½• **`**0 <= i < len(p)**`** éƒ½æœ‰ï¼šå­ä¸² **`**p[0..i]**`** ä¸­å·¦æ‹¬å·çš„æ•°é‡éƒ½å¤§äºæˆ–ç­‰äºå³æ‹¬å·çš„æ•°é‡**ã€‚å› ä¸ºä»å·¦å¾€å³ç®—çš„è¯ï¼Œè‚¯å®šæ˜¯å·¦æ‹¬å·å¤šå˜›ï¼Œåˆ°æœ€åå·¦å³æ‹¬å·æ•°é‡ç›¸ç­‰ï¼Œè¯´æ˜è¿™ä¸ªæ‹¬å·ç»„åˆæ˜¯åˆæ³•çš„ã€‚
`backtrack`å‡½æ•°ä¸­ï¼Œ`left`è¡¨ç¤ºå‰©ä½™å¯é€‰çš„å·¦æ‹¬å·æ•°é‡ `right`è¡¨ç¤ºå‰©ä½™å¯é€‰çš„å³æ‹¬å·æ•°é‡

```go
var result []string
func generateParenthesis(n int) []string {
    result = []string{}
    
    track := []byte{}
  	// 1. é»˜è®¤å·¦å³å‰©ä½™æ‹¬å·éƒ½æ˜¯nä¸ª
    backtrack(track,n,n)
    return result
}

//leftå‰©ä½™å·¦æ‹¬å·æ•°é‡ rightå‰©ä½™å³æ‹¬å·æ•°é‡
func backtrack(track []byte,left,right int) { 
  	// æ‹¬å·æ°å¥½éƒ½ä½¿ç”¨å®Œæˆ
    if left == 0 && right == 0 {
        result = append(result,string(track))
        return
    }
  	// å‰©ä½™right < å‰©ä½™leftï¼Œè¯´æ˜righté€‰æ‹©å¤šäº†ï¼Œä¸ç¬¦åˆé¢˜æ„
    if left < 0 || right < 0  || right < left { 
        return
    }

    track = append(track,'(') // é€‰æ‹©å·¦æ‹¬å·
    backtrack(track,left-1,right)
    track = track[:len(track)-1] // æ’¤é”€é€‰æ‹©

    track = append(track,')') // é€‰æ‹©å³æ‹¬å·
    backtrack(track,left,right-1)
    track = track[:len(track)-1] //æ’¤é”€é€‰æ‹©
}
```
## 8. å­—ç¬¦ä¸²è½¬æ¢æ•´æ•°
è¯·ä½ æ¥å®ç°ä¸€ä¸ª `myAtoi(string s)` å‡½æ•°ï¼Œä½¿å…¶èƒ½å°†å­—ç¬¦ä¸²è½¬æ¢æˆä¸€ä¸ª 32 ä½æœ‰ç¬¦å·æ•´æ•°ã€‚
å‡½æ•° `myAtoi(string s)` çš„ç®—æ³•å¦‚ä¸‹ï¼š

1. **ç©ºæ ¼ï¼š**è¯»å…¥å­—ç¬¦ä¸²å¹¶ä¸¢å¼ƒæ— ç”¨çš„å‰å¯¼ç©ºæ ¼ï¼ˆ`" "`ï¼‰
2. **ç¬¦å·ï¼š**æ£€æŸ¥ä¸‹ä¸€ä¸ªå­—ç¬¦ï¼ˆå‡è®¾è¿˜æœªåˆ°å­—ç¬¦æœ«å°¾ï¼‰ä¸º `'-'` è¿˜æ˜¯ `'+'`ã€‚å¦‚æœä¸¤è€…éƒ½ä¸å­˜åœ¨ï¼Œåˆ™å‡å®šç»“æœä¸ºæ­£ã€‚
3. **è½¬æ¢ï¼š**é€šè¿‡è·³è¿‡å‰ç½®é›¶æ¥è¯»å–è¯¥æ•´æ•°ï¼Œç›´åˆ°é‡åˆ°éæ•°å­—å­—ç¬¦æˆ–åˆ°è¾¾å­—ç¬¦ä¸²çš„ç»“å°¾ã€‚å¦‚æœæ²¡æœ‰è¯»å–æ•°å­—ï¼Œåˆ™ç»“æœä¸º0ã€‚
4. **èˆå…¥ï¼š**å¦‚æœæ•´æ•°æ•°è¶…è¿‡ 32 ä½æœ‰ç¬¦å·æ•´æ•°èŒƒå›´ `[âˆ’231, 231 âˆ’ 1]` ï¼Œéœ€è¦æˆªæ–­è¿™ä¸ªæ•´æ•°ï¼Œä½¿å…¶ä¿æŒåœ¨è¿™ä¸ªèŒƒå›´å†…ã€‚å…·ä½“æ¥è¯´ï¼Œå°äº `âˆ’231` çš„æ•´æ•°åº”è¯¥è¢«èˆå…¥ä¸º `âˆ’231` ï¼Œå¤§äº `231 âˆ’ 1` çš„æ•´æ•°åº”è¯¥è¢«èˆå…¥ä¸º `231 âˆ’ 1` ã€‚è¿”å›æ•´æ•°ä½œä¸ºæœ€ç»ˆç»“æœã€‚
æ€è·¯ï¼š
æ•´ä¸ªå­—ç¬¦ä¸²çš„æ ¼å¼æ˜¯å›ºå®š **ã€ç©ºæ ¼ã€‘+ã€ç¬¦å·ã€‘+ ã€æ•°å­—/å­—æ¯ç­‰ç­‰ç¬¦å·ã€‘**
è¿™é¢˜åªéœ€è¦æ ¹æ®ä¸Šé¢çš„4ä¸ªæ¡ä»¶å®ç°å³å¯

```go
func myAtoi(s string) int {
    count := len(s)
    sign := 1
    result := 0
    index := 0
   
    //1.å…ˆå»æ‰å‰ç¼€ ç©ºæ ¼
    for index < count && s[index] == ' ' {
        index++
    }

    //2.æŸ¥çœ‹ç¬¦å·ä½
    if index < count {
        if s[index] == '+' {
            sign = 1
            index++
        } else if s[index] == '-' {
            sign = -1
            index++
        }
    } 

    //3. æŠŠæ•°å­—å…¨éƒ¨æ‹¿å‡ºæ¥ï¼ˆé‡åˆ°éæ•°å­—ï¼Œç»“æŸforå¾ªç¯ï¼‰
    for index < count && s[index] >= '0' && s[index] <= '9' {
        result = result * 10 + int(s[index]-'0')
      	// 4. èˆå…¥ï¼ˆæˆªæ–­ï¼‰
        if sign * result >= math.MaxInt32 {
            return math.MaxInt32
        } else if sign * result <= math.MinInt32 {
            return math.MinInt32
        } 
        index++
    }
    return sign * result
}
```
## 69. xçš„å¹³æ–¹æ ¹
ç»™ä½ ä¸€ä¸ªéè´Ÿæ•´æ•° `x` ï¼Œè®¡ç®—å¹¶è¿”å› `x` çš„ **ç®—æœ¯å¹³æ–¹æ ¹** ã€‚ç”±äºè¿”å›ç±»å‹æ˜¯æ•´æ•°ï¼Œç»“æœåªä¿ç•™ **æ•´æ•°éƒ¨åˆ†** ï¼Œå°æ•°éƒ¨åˆ†å°†è¢« **èˆå» ã€‚**
**æ³¨æ„ï¼š**ä¸å…è®¸ä½¿ç”¨ä»»ä½•å†…ç½®æŒ‡æ•°å‡½æ•°å’Œç®—ç¬¦ï¼Œä¾‹å¦‚ `pow(x, 0.5)` æˆ–è€… `x ** 0.5` ã€‚
æ€è·¯ï¼š

- è¿™é‡Œå…¶å®æ˜¯ä¸€é“æ•°å­¦é¢˜ã€‚æ¯”å¦‚ æ±‚æ•°å­— `4` çš„å¹³æ–¹æ ¹ï¼Œè½¬æ¢æˆæ±‚ä¸¤ä¸ªæ•°çš„ä¹˜ç§¯ï¼Œå°±æ˜¯ `2*2=4`ã€‚
- åˆ©ç”¨äºŒåˆ†æ³•ï¼Œæ‰¾ä¸€ä¸ªæ•°å­— `mid`ï¼Œè®© `mid*mid`çš„å€¼ä¸æ–­çš„è¶‹è¿‘äº `x`ï¼Œé‚£ä¹ˆ`mid`å°±æ˜¯å¹³æ–¹æ ¹
```go
// x æ˜¯æ•´æ•°ï¼Œæ±‚å¹³æ–¹æ ¹
func mySqrt(x int) int {
    
    left, right := 0,x
    for left <= right {
        mid := left + (right-left)/2
        
        if x == mid * mid {
            return mid
        } else if x  < mid * mid {
            right = mid - 1 // mid åå¤§
        } else {
            left = mid + 1 // mid åå°
        }
    }
    // æ‰§è¡Œåˆ°è¿™é‡Œï¼Œleft > right ï¼Œç»“æœæ˜¯ä¸€ä¸ªæµ®ç‚¹æ•°,æ¯”å¦‚ 2.3434,ä½äº [right,left]ä¹‹é—´ï¼Œå› ä¸ºåªä¿ç•™æ•´æ•°éƒ¨åˆ†ï¼Œæ‰€ä»¥å– rightçš„å€¼
    return right
}


// æœ‰æ¬¡é¢è¯•ï¼Œå®é™…é‡åˆ°çš„æ˜¯è¿™ä¸ªé¢˜ç›®ï¼ˆä¸Šé¢çš„å˜å½¢é¢˜ï¼‰
// xæ˜¯æµ®ç‚¹æ•°æ±‚å¹³æ–¹æ ¹ï¼Œä¿ç•™3ä½å°æ•°
func mySqrt1(x float64) float64 {
	l, r := 0.0, x
	for l <= r {
		mid := (l + r) /2 
		if x < mid*mid {
			r = mid - 1e-3
		} else {
			l = mid + 1e-3
		}
	}
	return r
}
```
## 2. ä¸¤æ•°ç›¸åŠ 
ç»™ä½ ä¸¤ä¸ª **éç©º** çš„é“¾è¡¨ï¼Œè¡¨ç¤ºä¸¤ä¸ªéè´Ÿçš„æ•´æ•°ã€‚å®ƒä»¬æ¯ä½æ•°å­—éƒ½æ˜¯æŒ‰ç…§ **é€†åº** çš„æ–¹å¼å­˜å‚¨çš„ï¼Œå¹¶ä¸”æ¯ä¸ªèŠ‚ç‚¹åªèƒ½å­˜å‚¨ **ä¸€ä½** æ•°å­—ã€‚
è¯·ä½ å°†ä¸¤ä¸ªæ•°ç›¸åŠ ï¼Œå¹¶ä»¥ç›¸åŒå½¢å¼è¿”å›ä¸€ä¸ªè¡¨ç¤ºå’Œçš„é“¾è¡¨ã€‚ä½ å¯ä»¥å‡è®¾é™¤äº†æ•°å­— 0 ä¹‹å¤–ï¼Œè¿™ä¸¤ä¸ªæ•°éƒ½ä¸ä¼šä»¥ 0 å¼€å¤´ã€‚
![3c81be53-b6e9-490a-898b-47fad2920d5f.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411706898-3c81be53-b6e9-490a-898b-47fad2920d5f.png)

æ€è·¯ï¼š

- é€†åºå­˜å‚¨å¾ˆå‹å¥½äº†ï¼Œç›´æ¥éå†é“¾è¡¨å°±æ˜¯ä»ã€ä¸ªä½ã€‘å¼€å§‹çš„ï¼Œç¬¦åˆæˆ‘ä»¬è®¡ç®—åŠ æ³•çš„ä¹ æƒ¯é¡ºåºã€‚å¦‚æœæ˜¯æ­£åºå­˜å‚¨ï¼Œé‚£å€’è¦è´¹ç‚¹è„‘ç­‹äº†ï¼Œå¯èƒ½éœ€è¦ç¿»è½¬é“¾è¡¨æˆ–è€…ä½¿ç”¨æ ˆæ¥è¾…åŠ©ã€‚
- è¿™é“é¢˜ä¸»è¦è€ƒå¯Ÿ é“¾è¡¨åŒæŒ‡é’ˆæŠ€å·§å’ŒåŠ æ³•è¿ç®—è¿‡ç¨‹ä¸­å¯¹è¿›ä½çš„å¤„ç†ã€‚æ³¨æ„è¿™ä¸ª `carry` å˜é‡çš„å¤„ç†ï¼Œåœ¨æˆ‘ä»¬æ‰‹åŠ¨æ¨¡æ‹ŸåŠ æ³•è¿‡ç¨‹çš„æ—¶å€™ä¼šç»å¸¸ç”¨åˆ°ã€‚
- **ä»£ç ä¸­è¿˜ç”¨åˆ°ä¸€ä¸ªé“¾è¡¨çš„ç®—æ³•é¢˜ä¸­æ˜¯å¾ˆå¸¸è§çš„ã€Œè™šæ‹Ÿå¤´ç»“ç‚¹ã€æŠ€å·§ï¼Œä¹Ÿå°±æ˜¯ **`**dummy**`** èŠ‚ç‚¹**
```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
  	// dummy è™šæ‹ŸèŠ‚ç‚¹
    dummy := &ListNode{Val:0,Next:nil}
    p := dummy
  
  	// è®°å½•è¿›ä½
    carry := 0
 
  	// l1 l2 åˆ†åˆ«æŒ‡å‘ä¸¤ä¸ªé“¾è¡¨çš„å¤´éƒ¨ï¼Œåªæœ‰æœ‰ä¸€ä¸ªä¸ä¸ºnil æˆ–è€… è¿›ä½ä¸ä¸º0
    for l1 != nil || l2 != nil || carry > 0 { 
        val := carry //è¿›ä½æ•°

        if l1 != nil {
            val += l1.Val //l1æ•°å€¼
            l1 = l1.Next
        }

        if l2 != nil {
            val += l2.Val//l2æ•°å€¼
            l2 = l2.Next
        }

        carry = val / 10 //ä¸‹ä¸€æ¬¡çš„è¿›ä½
        val = val % 10   //å½“å‰ç»“æœ
        p.Next = &ListNode{Val:val,Next:nil} //æ‹¼æ¥åˆ°pçš„Next
        p = p.Next
    }
		// è¿”å›æœ€ç»ˆçš„å¤´èŠ‚ç‚¹
    return dummy.Next
}
```
## 70. çˆ¬æ¥¼æ¢¯
å‡è®¾ä½ æ­£åœ¨çˆ¬æ¥¼æ¢¯ã€‚éœ€è¦ `n` é˜¶ä½ æ‰èƒ½åˆ°è¾¾æ¥¼é¡¶ã€‚
æ¯æ¬¡ä½ å¯ä»¥çˆ¬ `1` æˆ– `2` ä¸ªå°é˜¶ã€‚ä½ æœ‰å¤šå°‘ç§ä¸åŒçš„æ–¹æ³•å¯ä»¥çˆ¬åˆ°æ¥¼é¡¶å‘¢ï¼Ÿ
æ€è·¯ï¼š

- åŠ¨æ€è§„åˆ’é¢˜å‹
- `dp[i]`å«ä¹‰ï¼šåˆ°è¾¾ `i`é˜¶ï¼Œå¯ä»¥æœ‰ `dp[i]`ç§ä¸åŒçš„æ–¹æ³•
- é€’æ¨å…³ç³»ï¼šåˆ°è¾¾ `i-1`é˜¶ï¼Œæœ‰ `dp[i-1]`ç§æ–¹æ³•ï¼Œåˆ°è¾¾ `i-2`é˜¶ï¼Œæœ‰ `dp[i-2]`ç§æ–¹æ³•ï¼Œåˆ°è¾¾ `i`é˜¶ã€å¯ä»¥ä» `i-1`é˜¶ï¼Œçˆ¬ `1`ä¸ªå°é˜¶ç›´æ¥åˆ°è¾¾ã€‘ æˆ–è€… ã€å¯ä»¥ä» `i-2`é˜¶ï¼Œçˆ¬ `2`ä¸ªå°é˜¶ç›´æ¥åˆ°è¾¾ã€‘ï¼Œæœ‰ `dp[i] = dp[i-1] + dp[i-2]`ç§æ–¹æ³•
```go
func climbStairs(n int) int {
	// å®šä¹‰ dp æ•°ç»„ï¼Œé•¿åº¦ä¸º n+1
	dp := make([]int, n+1)
	
	for i := 0; i <= n; i++ {
    		// base case
        if i == 0 {
            dp[i] = 1 
        } else if i == 1 { // base case
            dp[i] = 1
        } else {
            dp[i] = dp[i-1] + dp[i-2] //åˆ°è¾¾dp[i],æœ‰ä¸¤ç§æ–¹æ³•ï¼šä¸€ç§ç›´æ¥ä»dp[i-1],ä¸€ç§ç›´æ¥ä»dp[i-2]
        }
	}

    return dp[n]
}
```
## 165. æ¯”è¾ƒç‰ˆæœ¬å·
ç»™ä½ ä¸¤ä¸ª **ç‰ˆæœ¬å·å­—ç¬¦ä¸²**`version1` å’Œ `version2` ï¼Œè¯·ä½ æ¯”è¾ƒå®ƒä»¬ã€‚ç‰ˆæœ¬å·ç”±è¢«ç‚¹ `'.'` åˆ†å¼€çš„ä¿®è®¢å·ç»„æˆã€‚**ä¿®è®¢å·çš„å€¼** æ˜¯å®ƒ **è½¬æ¢ä¸ºæ•´æ•°** å¹¶å¿½ç•¥å‰å¯¼é›¶ã€‚
æ¯”è¾ƒç‰ˆæœ¬å·æ—¶ï¼Œè¯·æŒ‰ **ä»å·¦åˆ°å³çš„é¡ºåº** ä¾æ¬¡æ¯”è¾ƒå®ƒä»¬çš„ä¿®è®¢å·ã€‚å¦‚æœå…¶ä¸­ä¸€ä¸ªç‰ˆæœ¬å­—ç¬¦ä¸²çš„ä¿®è®¢å·è¾ƒå°‘ï¼Œåˆ™å°†ç¼ºå¤±çš„ä¿®è®¢å·è§†ä¸º `0`ã€‚
è¿”å›è§„åˆ™å¦‚ä¸‹ï¼š

- å¦‚æœ `version1 < version2` è¿”å› `-1`ï¼Œ
- å¦‚æœ `version1 > version2` è¿”å› `1`ï¼Œ
- é™¤æ­¤ä¹‹å¤–è¿”å› `0`ã€‚æ€è·¯ï¼š
è¿™æ˜¯ä¸€ä¸ªæ¯”è¾ƒå®ç”¨çš„é¢˜ç›®ï¼Œå·¥ä½œä¸­ä¹Ÿå¯èƒ½å‡ºç°
![5066f476-e07d-4aaf-acb3-5e5a9caf30af.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411707168-5066f476-e07d-4aaf-acb3-5e5a9caf30af.png)


- å°†ç‰ˆæœ¬å·å­—ç¬¦ä¸²ï¼ŒæŒ‰ç…§ `.`åˆ†å‰²ä¸ºå­å­—ç¬¦ä¸²
- åˆ©ç”¨åŒæŒ‡é’ˆæŠ€å·§ï¼Œå®šä¹‰ä¸¤ä¸ªæŒ‡é’ˆåˆ†åˆ«æŒ‡å‘ä¸¤ä¸ª ç‰ˆæœ¬å·çš„å­å­—ç¬¦ä¸²ï¼Œä¾æ¬¡æ¯”è¾ƒå¯¹åº”ä½çš„æ•´æ•°å€¼ï¼ˆå­—ç¬¦ä¸²è½¬æˆæ•´æ•°ï¼‰ï¼Œç¼ºå¤±çš„å€¼è§†ä¸º`0`
```go
func compareVersion(version1 string, version2 string) int {
    //1.å…ˆæŒ‰ç…§"." æ‹†åˆ†å­—ç¬¦ä¸²
    slicev1 := strings.Split(version1,".")
    slicev2 := strings.Split(version2,".")

    //2.å¯¹åº”ä½ç½®ä¸€ä¸€å¯¹æ¯”
    i,j := 0,0 
    for ; i < len(slicev1) && j < len(slicev2);i,j = i+1,j+1 {
        val1 ,_ := strconv.Atoi(slicev1[i])
        val2,_ := strconv.Atoi(slicev2[j])
        if val1 > val2 {
            return 1
        } else if val1 < val2 {
            return -1
        }
    }
		
  	// è¯´æ˜ version2 å­—ç¬¦ä¸²æ¯”è¾ƒçŸ­
    for i < len(slicev1) {
        val1 ,_ := strconv.Atoi(slicev1[i])
        i++
        if val1 > 0 { // version2 ç¼ºå¤±çš„è§†ä¸º 0
            return 1
        }else if val1 < 0 {
            return -1
        }
    }
		
  	// è¯´æ˜ version1 å­—ç¬¦ä¸²æ¯”è¾ƒçŸ­
    for j < len(slicev2) {
        val2,_ := strconv.Atoi(slicev2[j])
        j++
        if val2 > 0 { // version1 ç¼ºå¤±çš„è§†ä¸º 0
            return -1
        }else if val2 < 0 {
            return 1
        }
    }

    return 0
}
```
## 239. æ»‘åŠ¨çª—å£æœ€å¤§å€¼
ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums`ï¼Œæœ‰ä¸€ä¸ªå¤§å°ä¸º `k` çš„æ»‘åŠ¨çª—å£ä»æ•°ç»„çš„æœ€å·¦ä¾§ç§»åŠ¨åˆ°æ•°ç»„çš„æœ€å³ä¾§ã€‚ä½ åªå¯ä»¥çœ‹åˆ°åœ¨æ»‘åŠ¨çª—å£å†…çš„ `k` ä¸ªæ•°å­—ã€‚æ»‘åŠ¨çª—å£æ¯æ¬¡åªå‘å³ç§»åŠ¨ä¸€ä½ã€‚
è¿”å› *æ»‘åŠ¨çª—å£ä¸­çš„æœ€å¤§å€¼* ã€‚
æ€è·¯ï¼š
ä½¿ç”¨ã€é˜Ÿåˆ—ã€‘å……å½“ä¸æ–­æ»‘åŠ¨çš„çª—å£ï¼Œæ¯æ¬¡æ»‘åŠ¨è®°å½•ã€é˜Ÿåˆ—ã€‘çš„æœ€å¤§å€¼ï¼š
![ace486ae-bc6b-4df4-9923-5a5f2aa05a89.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411707274-ace486ae-bc6b-4df4-9923-5a5f2aa05a89.png)

å¦‚ä½•åœ¨ `O(1)` æ—¶é—´è®¡ç®—æœ€å¤§å€¼ï¼Œåªéœ€è¦ä¸€ä¸ªç‰¹æ®Šçš„æ•°æ®ç»“æ„ã€Œå•è°ƒé˜Ÿåˆ—ã€ï¼Œ`push` æ–¹æ³•ä¾ç„¶åœ¨é˜Ÿå°¾æ·»åŠ å…ƒç´ ï¼Œä½†æ˜¯è¦æŠŠå‰é¢æ¯”è‡ªå·±å°çš„å…ƒç´ éƒ½åˆ æ‰ï¼Œç›´åˆ°é‡åˆ°æ›´å¤§çš„å…ƒç´ æ‰åœæ­¢åˆ é™¤ã€‚
![64365157-570e-4a01-9775-c5322a3a9611.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411707121-64365157-570e-4a01-9775-c5322a3a9611.png)

ä½¿ç”¨å•è°ƒé˜Ÿåˆ—æ•°æ®ç»“æ„å°±èƒ½å®Œæˆæœ¬é¢˜ï¼Œé˜Ÿåˆ—å¤´éƒ¨å…ƒç´ å°±æ˜¯æœ€å¤§å€¼ã€‚

```go
func maxSlidingWindow(nums []int, k int) []int {
    // åˆ©ç”¨å•è°ƒé˜Ÿåˆ—ï¼Œè®°å½•çª—å£å†…æœ€å¤§å€¼
    var result []int
    
    var q Queue
		
  	// 1. å…ˆåŠ å…¥kä¸ªå…ƒç´ 
    for i := 0;i<k;i++ {
        q.Push(nums[i])
    }
    result = append(result,q.MaxVal())//è®°å½•æœ€å¤§å€¼

    for i := k;i<len(nums);i++ {
        q.Pop(nums[i-k])//é˜Ÿåˆ—å®¹é‡ä¸ºkï¼Œåœ¨åŠ å…¥æ–°å…ƒç´ ä¹‹å‰ï¼Œå…ˆåˆ é™¤å·¦è¾¹ nums[i-k]
        q.Push(nums[i])// å†è¿½åŠ æ–°å…ƒç´  nums[i]
        result = append(result,q.MaxVal()) //è®°å½•æœ€å¤§å€¼
    }
    return result
}


// å•è°ƒé˜Ÿåˆ—
type Queue struct {
    q []int
}

// Push é˜Ÿåˆ—
func (t *Queue)Push(val int){
    for len(t.q) != 0 && t.q[len(t.q)-1] < val { //é˜Ÿåˆ—ä¸­æ¯”valå°çš„æ•°å€¼ï¼Œå…¨éƒ¨åˆ é™¤
        //å¼¹å‡ºå°¾éƒ¨
        t.q = t.q[:len(t.q)-1]
    }
    t.q = append(t.q,val)//åŠ å…¥é˜Ÿåˆ—å°¾éƒ¨
}

// é˜Ÿåˆ—ä¸­çš„æœ€å¤§å€¼
func (t *Queue)MaxVal() int {
    return t.q[0]
}

// å¦‚æœå’Œé˜Ÿåˆ—å¤´éƒ¨æœ€å¤§å…ƒç´ ç›¸åŒï¼Œåˆ é™¤é˜Ÿåˆ—å¤´éƒ¨å…ƒç´ 
func (t *Queue)Pop(val int) {
    if val == t.q[0] {
        t.q = t.q[1:] //åˆ é™¤å¤´éƒ¨
    }
}
```
## 41. ç¼ºå¤±çš„ç¬¬ä¸€ä¸ªæ­£æ•°
ç»™ä½ ä¸€ä¸ªæœªæ’åºçš„æ•´æ•°æ•°ç»„ `nums` ï¼Œè¯·ä½ æ‰¾å‡ºå…¶ä¸­æ²¡æœ‰å‡ºç°çš„æœ€å°çš„æ­£æ•´æ•°ã€‚è¯·ä½ å®ç°æ—¶é—´å¤æ‚åº¦ä¸º `O(n)` å¹¶ä¸”åªä½¿ç”¨å¸¸æ•°çº§åˆ«é¢å¤–ç©ºé—´çš„è§£å†³æ–¹æ¡ˆã€‚
æ€è·¯ï¼š
è¿™é¢˜å¦‚æœç¬¬ä¸€æ¬¡åšï¼Œä¼šæ„Ÿè§‰å¾ˆç»•ã€‚å…¶å®æœ¬è´¨ç›®çš„å°±æ˜¯è®©æ•°å€¼ï¼šæ¯”å¦‚ `1`æ”¾åˆ°ç´¢å¼• `0`ï¼Œ `2` æ”¾åˆ°ç´¢å¼•`1`ï¼Œæ•°å€¼`3`æ”¾åˆ°ç´¢å¼•`2` ã€‚ è¿™æ ·å°±å½¢æˆäº†ï¼Œéšç€ç´¢å¼•`i`çš„é€’å¢ï¼Œå…ƒç´ å€¼ä¹Ÿæ˜¯é¡ºåºé€’å¢çš„ï¼ˆå¹¶ä¸”ä¹‹é—´æ˜¯ `+1` çš„å…³ç³»ï¼‰
é¢˜ç›®è¦æ±‚ã€ç¼ºå¤±çš„æœ€å°æ­£æ•´æ•°ã€‘ï¼šå°†æ•°ç»„ä¸­çš„å…ƒç´ ï¼ŒæŒ‰ç…§ 1ï¼Œ2ï¼Œ3ï¼Œ4ï¼Œ5ï¼Œ6.... è¿™ä¸ªé¡ºåºæ’åˆ—ã€‚ï¼ˆåŒæ—¶è§‚å¯Ÿåˆ°1,2,3,4,5å’Œæ•°ç»„ç´¢å¼•çš„å…³ç³» 0,1,2,3,4ï¼Œæ˜¯ç›¸å·®`1`çš„å…³ç³»ï¼‰

- æ•°ç»„çš„é•¿åº¦ä¸º`n`ï¼Œå¦‚æœæ•°ç»„ä¸­çš„å…ƒç´ éƒ½æ˜¯æŒ‰ç…§1ï¼Œ2ï¼Œ3ï¼Œ4ï¼Œ5ï¼Œ6.... è¿™ä¸ªé¡ºåºæ’åˆ—ï¼Œä¹Ÿå°±æ˜¯ã€`1ï½n`ã€‘ï¼Œé‚£ä¹ˆæœ€å°çš„æ­£æ•´æ•°å°±æ˜¯`n+1`
- å¦‚æœæ•°ç»„ä¸­çš„å…ƒç´ å‡ºç°è·³ç©ºï¼ˆä¹Ÿå°±æ˜¯ç¼ºå¤±æŸä¸€ä¸ªï¼‰é‚£ä¹ˆç´¢å¼•ä½ç½® `i`å¯¹åº”çš„å…ƒç´ å€¼ `nums[i]`ï¼Œä¹‹é—´ä¸æ»¡è¶³ `i+1 == nums[i]`![4306a0c3-a8cd-4c73-b881-4e073b49049a.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411707603-4306a0c3-a8cd-4c73-b881-4e073b49049a.png)


```go
func firstMissingPositive(nums []int) int {
   
    for i := 0;i < len(nums);i++ {
        // å…ƒç´ å€¼è¦åœ¨[1~n]ä¹‹é—´ && nums[i]-1ç´¢å¼•å¤„çš„å…ƒç´ å€¼ä¸æ˜¯ nums[i]
        for nums[i] >= 1 && nums[i] <= len(nums) && nums[i] != nums[nums[i]-1] {
            // äº¤æ¢ 
            nums[nums[i]-1],nums[i] = nums[i],nums[nums[i]-1]
        }
    }

    // æ‰¾åˆ°ç¬¬ä¸€ä¸ªï¼Œç´¢å¼• i å’Œæ•°å€¼ ä¸æ˜¯ +1 çš„å…³ç³»ï¼›
    for i := 0; i < len(nums);i++ {
        if nums[i] != i+1 {
            return i+1
        }
    }
    // å¦‚æœä¸Šé¢å…¨éƒ¨éƒ½æ‰§è¡Œå®Œæˆï¼Œè¿˜æ²¡æœ‰æ‰¾åˆ°ï¼Œé‚£ä¹ˆè¿™ä¸ªæ•°å€¼å°±æ˜¯æ•°ç»„é•¿åº¦+1
    return len(nums)+1
}
```
## 322. é›¶é’±å…‘æ¢
ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `coins` ï¼Œè¡¨ç¤ºä¸åŒé¢é¢çš„ç¡¬å¸ï¼›ä»¥åŠä¸€ä¸ªæ•´æ•° `amount` ï¼Œè¡¨ç¤ºæ€»é‡‘é¢ã€‚è®¡ç®—å¹¶è¿”å›å¯ä»¥å‡‘æˆæ€»é‡‘é¢æ‰€éœ€çš„ **æœ€å°‘çš„ç¡¬å¸ä¸ªæ•°** ã€‚å¦‚æœæ²¡æœ‰ä»»ä½•ä¸€ç§ç¡¬å¸ç»„åˆèƒ½ç»„æˆæ€»é‡‘é¢ï¼Œè¿”å› `-1` ã€‚
ä½ å¯ä»¥è®¤ä¸ºæ¯ç§ç¡¬å¸çš„æ•°é‡æ˜¯æ— é™çš„ã€‚
æ€è·¯ï¼š

- åŠ¨æ€è§„åˆ’é¢˜å‹
- å®šä¹‰`dp`æ•°ç»„ï¼š`dp[i]`è¡¨ç¤ºå‡‘æˆé‡‘é¢`i` æ‰€éœ€è¦çš„**æœ€å°‘çš„ç¡¬å¸ä¸ªæ•°**ä¸º `dp[i]`
- é€’æ¨å…³ç³»ï¼šä¸ºäº†å‡‘æˆé‡‘é¢ `i`ï¼Œå¯ä»¥ä¾›æˆ‘ä»¬é€‰æ‹©çš„ç¡¬å¸æœ‰`coins[0....]`ä¸åŒé¢é¢çš„ç¡¬å¸ï¼›
å¦‚æœé€‰æ‹©æŸä¸ªç¡¬å¸ `coins[j]`ï¼Œé‚£ä¹ˆå‰©ä½™é‡‘é¢å˜ä¸º`i - coins[j]` ï¼›
ç»§ç»­é€‰æ‹©æŸä¸ªç¡¬å¸ `coins[x]`ï¼Œé‚£ä¹ˆå‰©ä½™çš„é‡‘é¢å˜ä¸º `i -coins[j] - coins[x]`
![0e6c1318-773f-4757-bc09-857fe2c2bff6.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411707573-0e6c1318-773f-4757-bc09-857fe2c2bff6.png)

æœ€ç»ˆçš„é€’æ¨å…³ç³»ä¸ºï¼š`dp[i] = min(dp[i], dp[i-coins[0...] + 1])`
`dp[i-coins[0...] + 1 ` å«ä¹‰ï¼š `coins[0...]` æ¯æ¬¡é€‰æ‹©ï¼Œæ‰€æœ‰çš„ç¡¬å¸å¯ä¾›é€‰æ‹©ï¼Œå¦‚æœé€‰æ‹©æŸä¸ªç¡¬å¸`coins[j]`åï¼Œå‡‘æˆå‰©ä½™é‡‘é¢`i-coins[j]`éœ€è¦ `dp[i-coins[j]]`æœ€å°‘ç¡¬å¸ä¸ªæ•° +1 è¡¨ç¤ºé€‰ä¸­äº†ç¡¬å¸`coins[j]`
`min`è¡¨ç¤ºï¼Œé‡‘é¢ `i`å¯ä»¥é€‰çš„ç¡¬å¸æœ‰å¾ˆå¤šç§`coins[0...]`ï¼Œæˆ‘ä»¬åªéœ€ ç¡¬å¸æœ€å°çš„ç»“æœ
*è¿˜æœ‰ä¸ªå‰æï¼Œé€‰ä¸­çš„ç¡¬å¸çš„é¢é¢ï¼Œä¸èƒ½å¤§äºè¦å‡‘çš„é‡‘é¢*`*i*`

```go
func coinChange(coins []int, amount int) int {

   
    dp := make([]int,amount+1)
  	// base case
    for k,_ := range dp {
        dp[k] = amount+1 // å› ä¸ºè¦æ±‚æœ€å°å€¼ï¼Œå‡è®¾éƒ½æ˜¯1å…ƒæ¥å‡‘ï¼Œæœ€å¤šéœ€è¦amountä¸ªç¡¬å¸ï¼Œè¿™é‡Œè®¾ç½®å¤§ä¸€ä½ï¼Œå°±å¯ä»¥è¡¨ç¤ºå¾ˆå¤§çš„æ•°å€¼äº†
    }
  
    dp[0] = 0 // æ²¡æœ‰é‡‘é¢ï¼Œä¹Ÿå°±ä¸éœ€è¦ç¡¬å¸

    for i := 1;i <= amount;i++ { // é‡‘é¢ä»1å¼€å§‹
      	// å¯ä¾›é€‰æ‹©çš„ç¡¬å¸ [0,len(coins)-1]
        for j := 0;j < len(coins);j++ {
            if i - coins[j] >= 0 { //å½“å‰é€‰æ‹©çš„ç¡¬å¸é‡‘é¢coins[j]ï¼Œä¸èƒ½è¶…è¿‡é‡‘é¢iï¼ˆæ‰èƒ½é€‰æ‹©ï¼‰
                dp[i] = min(dp[i],dp[i-coins[j]]+1 )
            }
        }
    }

    if dp[amount] == amount+1 {
        // è¯´æ˜å‡‘ä¸æˆæ”¹é‡‘é¢
        return -1
    }
    return dp[amount]
}

func min(a,b int)int{
    if a < b {
        return a
    }
    return b
}
```
## 32. æœ€é•¿æœ‰æ•ˆæ‹¬å·
ç»™ä½ ä¸€ä¸ªåªåŒ…å« `'('` å’Œ `')'` çš„å­—ç¬¦ä¸²ï¼Œæ‰¾å‡ºæœ€é•¿æœ‰æ•ˆï¼ˆæ ¼å¼æ­£ç¡®ä¸”è¿ç»­ï¼‰æ‹¬å·å­ä¸²çš„é•¿åº¦ã€‚
æ€è·¯ï¼š

- æœ€å€¼é—®é¢˜ï¼šå°±è¦æƒ³åˆ° åŠ¨æ€è§„åˆ’`dp[i]`è¡¨ç¤ºä»¥` s[i]` ç»“å°¾çš„å­—ç¬¦ä¸²çš„é•¿åº¦
å¦‚æœ `s[i] == '(' `ï¼Œä¸æ˜¯ä¸€ä¸ªæœ‰æ•ˆå­—ç¬¦ä¸²ï¼Œ`dp[i]`é•¿åº¦ä¸º`0`
å¦‚æœ `s[i] == ')'`ï¼Œå¦‚æœèƒ½æ‰¾åˆ° å·¦æ‹¬å·ï¼Œè¯´æ˜å½“å‰çš„å³æ‹¬å·ä½œä¸ºå­—ç¬¦ä¸²çš„ç»“å°¾ï¼Œèƒ½æ‰¾åˆ°å·¦æ‹¬å·å’Œè‡ªå·±ä¸€èµ·ç»„æˆä¸€ä¸ªæœ‰æ•ˆçš„å­—ç¬¦ä¸²ï¼Œå¦åˆ™ï¼Œå³æ‹¬å·ï¼Œä½œä¸ºç»“å°¾ï¼Œä¸æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„å­—ç¬¦ä¸²

- æ¶‰åŠåˆ°æ‹¬å·çš„é—®é¢˜ï¼šå°±éœ€è¦æƒ³åˆ° **æ ˆ**å½“é‡åˆ°å·¦æ‹¬å·ï¼Œç›´æ¥å…¥æ ˆ å·¦æ‹¬å·çš„ç´¢å¼•å€¼
å¦‚æœé‡åˆ°å³æ‹¬å·ï¼Œçœ‹ä¸‹æ ˆä¸­æ˜¯å¦ä¸ºç©ºï¼Œä¸ä¸ºç©ºï¼Œè¯´æ˜å¯ä»¥æ‰¾åˆ°å·¦æ‹¬å·å’Œå³æ‹¬å·ä¸€èµ·ç»„æˆæœ‰æ•ˆå­—ç¬¦ä¸²ï¼Œå¦åˆ™ï¼Œä¸èƒ½ç»„æˆæœ‰æ•ˆå­—ç¬¦ä¸²ï¼ˆå³æ‹¬å·éœ€è¦å…¥æ ˆï¼‰

```go
func longestValidParentheses(s string) int {
  
	stackIndex := []int{} // å› ä¸ºæ˜¯æ‹¬å·é—®é¢˜ï¼Œæ‰€ä»¥ç”¨åˆ°æ ˆï¼ˆæ ˆä¸­å­˜å‚¨çš„æ˜¯ç´¢å¼•å€¼ï¼‰
	dp := make([]int, len(s))

	maxLen := 0
	// éå†å­—ç¬¦ï¼Œå°è¯•ä»¥æ¯ä¸ªå­—ç¬¦ä½œä¸ºã€ç»“å°¾å­—ç¬¦ã€‘
	for i := 0; i < len(s); i++ {
		if s[i] == '(' {
			stackIndex = append(stackIndex, i) //ã€å·¦æ‹¬å·ã€‘ã€ç´¢å¼•ã€‘å…¥æ ˆ

			dp[i] = 0 //ä»¥å·¦æ‹¬å·ç»“å°¾çš„å­ä¸²ï¼Œæ˜¯æ— æ•ˆçš„ï¼Œæ‰€ä»¥é•¿åº¦=0
		} else { // è¯´æ˜æ˜¯å³æ‹¬å·
			if len(stackIndex) != 0 { //è¯´æ˜æ ˆé‡Œé¢æœ‰å·¦æ‹¬å·
				leftIndex := stackIndex[len(stackIndex)-1]
				stackIndex = stackIndex[:len(stackIndex)-1] //å‡ºæ ˆ
				// å½“å‰ å³æ‹¬å·ç´¢å¼• i  - å·¦æ‹¬å·çš„ç´¢å¼• leftIndex + 1 å¯ä»¥è®¡ç®—å‡ºå­—ç¬¦ä¸²çš„é•¿åº¦
				len := i + 1 - leftIndex //æœ‰æ•ˆå­ä¸²é•¿åº¦
       
				if leftIndex-1 >= 0 {  // å¦‚æœå·¦æ‹¬å·ç´¢å¼•çš„å‰ä¸€ä¸ªç´¢å¼• leftIndex-1ï¼Œå­˜åœ¨
					dp[i] = len + dp[leftIndex-1] // å½“å‰çš„é•¿åº¦len,è¿˜å¯ä»¥å’Œå‰é¢çš„ä»¥leftIndex-1ä¸ºç»“å°¾çš„å­—ç¬¦ä¸² æ‹¼æ¥æˆä¸€ä¸ªæ›´é•¿çš„æœ‰æ•ˆå­—ç¬¦ä¸²
				} else {
					dp[i] = len
				}

			} else { // è¯´æ˜å½“å‰çš„å³æ‹¬å·ï¼Œåœ¨æ ˆä¸­æ‰¾ä¸åˆ°å·¦æ‹¬å·ï¼Œå°±æ˜¯ä¸€ä¸ªæ— æ•ˆå­—ç¬¦ä¸²çš„ç»“å°¾
				dp[i] = 0
			}
		}
		// æ±‚æœ€å€¼
		maxLen = max(maxLen, dp[i])
	}

	return maxLen
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```
## LCR 140. è®­ç»ƒè®¡åˆ’ II
ç»™å®šä¸€ä¸ªå¤´èŠ‚ç‚¹ä¸º `head` çš„é“¾è¡¨ç”¨äºè®°å½•ä¸€ç³»åˆ—æ ¸å¿ƒè‚Œç¾¤è®­ç»ƒé¡¹ç›®ç¼–å·ï¼Œè¯·æŸ¥æ‰¾å¹¶è¿”å›å€’æ•°ç¬¬ `cnt` ä¸ªè®­ç»ƒé¡¹ç›®ç¼–å·ã€‚
æ€è·¯ï¼š
è¿™é¢˜å’Œå‰é¢çš„åˆ é™¤é“¾è¡¨ä¸­å€’æ•°ç¬¬ n ä¸ªèŠ‚ç‚¹ä¸€æ ·çš„å¥—è·¯ï¼š
`p1`æŒ‡å‘é“¾è¡¨å¤´éƒ¨ï¼Œå¹¶ä¸”ç§»åŠ¨ `k`æ­¥
![80f510bb-3959-4835-9572-b67e41f3d5c6.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411707561-80f510bb-3959-4835-9572-b67e41f3d5c6.png)

`p2`æŒ‡å‘é“¾è¡¨å¤´éƒ¨ï¼Œ`p1`ç»§ç»­ç§»åŠ¨ å‰©ä½™çš„ `n-k`æ­¥
![2fcd0f1d-73d1-4bd3-8fd6-69e1d54488a4.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411707723-2fcd0f1d-73d1-4bd3-8fd6-69e1d54488a4.png)

å½“ `p1 == nil`çš„æ—¶å€™ï¼Œ`p2`ç§»åŠ¨åˆ°äº†å€’æ•°çš„ç¬¬ `k`ä¸ªèŠ‚ç‚¹
![c2f88e5f-89a4-4400-87cf-6212d212a6f4.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411707769-c2f88e5f-89a4-4400-87cf-6212d212a6f4.png)


```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func trainingPlan(head *ListNode, cnt int) *ListNode {

    // base case 
	if head == nil {
		return head
	}

	p1 := head // p1 å…ˆè·³è·ƒ cnt ä¸ªèŠ‚ç‚¹
	for i := 0; i < cnt; i++ {
		p1 = p1.Next
	}

	p2 := head
	for p1 != nil { //p1 ä»å½“å‰ä½ç½®åˆ°è¾¾å°¾éƒ¨
		p1 = p1.Next
		p2 = p2.Next //p2 æ­£å¥½ç§»åŠ¨åˆ°è·ç¦»å°¾éƒ¨cntä¸ªèŠ‚ç‚¹çš„ä½ç½®ï¼ˆå€’æ•°ï¼‰
	}

	return p2
}
```
## 76. æœ€å°è¦†ç›–å­ä¸²
ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² `s` ã€ä¸€ä¸ªå­—ç¬¦ä¸² `t` ã€‚è¿”å› `s` ä¸­æ¶µç›– `t` æ‰€æœ‰å­—ç¬¦çš„æœ€å°å­ä¸²ã€‚å¦‚æœ `s` ä¸­ä¸å­˜åœ¨æ¶µç›– `t` æ‰€æœ‰å­—ç¬¦çš„å­ä¸²ï¼Œåˆ™è¿”å›ç©ºå­—ç¬¦ä¸² `""` ã€‚
**æ³¨æ„ï¼š**

- å¯¹äº `t` ä¸­é‡å¤å­—ç¬¦ï¼Œæˆ‘ä»¬å¯»æ‰¾çš„å­å­—ç¬¦ä¸²ä¸­è¯¥å­—ç¬¦æ•°é‡å¿…é¡»ä¸å°‘äº `t` ä¸­è¯¥å­—ç¬¦æ•°é‡ã€‚
- å¦‚æœ `s` ä¸­å­˜åœ¨è¿™æ ·çš„å­ä¸²ï¼Œæˆ‘ä»¬ä¿è¯å®ƒæ˜¯å”¯ä¸€çš„ç­”æ¡ˆã€‚æ€è·¯ï¼š
è¿™é¢˜å°±æ˜¯å…¸å‹çš„æ»‘åŠ¨çª—å£ç±»é¢˜ç›®ï¼Œä¸€èˆ¬æ¥è¯´éš¾åº¦ç•¥é«˜ï¼Œè§£æ³•æ¡†æ¶å¦‚ä¸‹ï¼š

```go
nums := []int{1,2,3,4,5,6}
func main() {
  
  //1. å®šä¹‰ `left right := 0,0` æŒ‡å‘èµ·å§‹ä½ç½® `0`
  left, right := 0,0
  
  // right è¶Šç•Œç»“æŸ
  for right < len(nums) {
    
    // 2.ä¸æ–­ç§»åŠ¨ right
    val := nums[right]
    right++ 
    
    // do something.....
    
    // 3.å½“ condition ä¸ç¬¦åˆé¢˜æ„çš„æ—¶å€™ï¼Œç§»åŠ¨ leftï¼Œç›´åˆ°æ»¡è¶³é¢˜æ„ï¼Œè·³å‡º condition
    for  condition {
      val := nums[left]
      left++
    }
    
    //.......
  }
}
```
é¢˜ç›®è¦æ±‚ è¿”å› `s` ä¸­æ¶µç›– `t` æ‰€æœ‰å­—ç¬¦çš„æœ€å°å­ä¸²ã€‚

- éœ€è¦çŸ¥é“ `t`ä¸­æœ‰å“ªäº›å­—ç¬¦
- åœ¨ `s`ä¸­æ‰¾åˆ°åŒ…å«`t`ä¸­æ‰€æœ‰å­—ç¬¦çš„å­—ç¬¦ä¸²ï¼ˆæ³¨æ„æ˜¯åŒ…å«ï¼Œä¸æ˜¯ç›¸ç­‰ï¼‰ï¼Œæ¯”å¦‚ `s = abc t = ac`ï¼Œå­—ç¬¦ä¸² `s`æ˜¯åŒ…å« `t`çš„æ‰€æœ‰å­—ç¬¦çš„ï¼›
æ¯”å¦‚ `s = abc t = aa`ï¼Œå­—ç¬¦ä¸² `s`æ˜¯ä¸åŒ…å« `t`ä¸­çš„æ‰€æœ‰å­—ç¬¦çš„ï¼Œå› ä¸º`t`ä¸­æœ‰ä¸¤ä¸ª `a`, `s`ä¸­åªæœ‰ä¸€ä¸ª `a`

```go
func minWindow(s string, t string) string {
    
    // window è®°å½•çª—å£å†…ã€æ³¨æ„ï¼šä¸æ˜¯çª—å£å†…çš„æ‰€æœ‰å­—ç¬¦ï¼Œè€Œæ˜¯tä¸­å­˜åœ¨çš„ã€‘å­—ç¬¦ + é¢‘ç‡
    // need è®°å½•tä¸­å‡ºç°çš„ å­—ç¬¦+é¢‘ç‡
    need,window := make(map[byte]int),make(map[byte]int)

    for i := 0;i<len(t);i++ {
        need[t[i]]++ //è®°å½•tä¸­å­—ç¬¦ + é¢‘ç‡
    }

    //è®°å½•çª—å£ä¸­ å½“æŸä¸ªå­—ç¬¦æ•°é‡ å·²ç»è¾¾åˆ°äº† t ä¸­ ç›¸åº”å­—ç¬¦æ•°é‡çš„é¢„æœŸï¼Œvaild++ è¯´æ˜çª—å£ä¸­åŒ…å«äº† t ä¸­çš„ä¸€ä¸ªæœ‰æ•ˆå­—ç¬¦
    vaild := 0
    left,right := 0,0

    start := 0
    length := math.MaxInt

    for right < len(s) {
        val := s[right] //  val å°†è¦è¿›å…¥çª—å£çš„å­—ç¬¦
        right++

        // åˆ¤æ–­è¯¥å­—ç¬¦æ˜¯å¦åœ¨needä¸­å‡ºç°ï¼ˆå†å¼ºè°ƒä¸€éï¼šwindowä¸­è®°å½•çš„æ˜¯åœ¨ needä¸­å­˜åœ¨çš„å­—ç¬¦æ•°é‡ï¼Œä¸æ˜¯çª—å£ä¸­çš„æ‰€æœ‰å­—ç¬¦ï¼‰
        if _,ok := need[val]; ok {
            window[val]++  // çª—å£ä¸­å­—ç¬¦æ•°é‡ +1
            if window[val] == need[val] {//è¯´æ˜windowä¸­è¯¥å­—ç¬¦çš„æ•°é‡ï¼Œè¾¾åˆ°äº†needä¸­å­—ç¬¦çš„æ•°é‡
                vaild++ // çª—å£ä¸­ï¼Œæœ‰ä¸€ä¸ªå­—ç¬¦æ•°é‡è¾¾åˆ°ç›®æ ‡é¢„æœŸ
            }
        }

        for vaild == len(need) { //è¡¨ç¤ºwindowä¸­å­—ç¬¦é¢‘ç‡å’Œneedä¸­çš„å­—ç¬¦é¢‘ç‡å…¨éƒ¨éƒ½ä¸€æ ·äº†ï¼ˆä¹Ÿå°±æ˜¯åŒ…å«äº†tä¸­çš„æ‰€æœ‰çš„å­—ç¬¦ï¼‰
            //æ‰¾æœ€å°çš„å­ä¸²ï¼Œæ”¶ç¼© right
            if right - left < length { 
                start = left
                length = right-left
            }

            //val å°†è¦ä»çª—å£åˆ é™¤çš„å­—ç¬¦
            val := s[left]
            left++
            if _,ok := need[val];ok {
              	// çª—å£ä¸­çš„å­—ç¬¦æ•°é‡ = needä¸­å­—ç¬¦æ•°é‡ä¸€æ ·ï¼Œä¸€æ—¦å­—ç¬¦ä»çª—å£ä¸­ç§»é™¤ï¼Œé‚£ä¹ˆçª—å£ä¸­çš„å­—ç¬¦ä¸²å°±ä¸å†å®Œå…¨åŒ…å« t ä¸­çš„æ‰€æœ‰å­—ç¬¦äº†
                if window[val] == need[val] {
                    vaild--
                } 
                window[val]--
            }
        }

    }
  	// è¯´æ˜ä¸å­˜åœ¨å®Œå…¨åŒ…å« t ä¸­æ‰€æœ‰å­—ç¬¦çš„å­—ç¬¦ä¸²
    if length == math.MaxInt {
        return ""
    }
    return string(s[start:start+length])
}
```
## 105. ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘
ç»™å®šä¸¤ä¸ªæ•´æ•°æ•°ç»„ `preorder` å’Œ `inorder` ï¼Œå…¶ä¸­ `preorder` æ˜¯äºŒå‰æ ‘çš„**å…ˆåºéå†**ï¼Œ `inorder` æ˜¯åŒä¸€æ£µæ ‘çš„**ä¸­åºéå†**ï¼Œè¯·æ„é€ äºŒå‰æ ‘å¹¶è¿”å›å…¶æ ¹èŠ‚ç‚¹ã€‚
æ€è·¯ï¼š
**æ„é€ äºŒå‰æ ‘ï¼Œç¬¬ä¸€ä»¶äº‹ä¸€å®šæ˜¯æ‰¾æ ¹èŠ‚ç‚¹ï¼Œç„¶åæƒ³åŠæ³•æ„é€ å·¦å³å­æ ‘**ã€‚
äºŒå‰æ ‘çš„å‰åºå’Œä¸­åºéå†ç»“æœçš„ç‰¹ç‚¹å¦‚ä¸‹ï¼š
![05ed1f0a-a0c0-41d1-a8da-222418ce1786.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411708116-05ed1f0a-a0c0-41d1-a8da-222418ce1786.png)


```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func buildTree(preorder []int, inorder []int) *TreeNode {
  	// æ•°ç»„ä¸ºç©ºï¼Œè¿”å›nil
    if len(preorder) == 0 || len(inorder) == 0 {
        return nil
    }
  	// leftLen è¡¨ç¤ºå·¦èŠ‚ç‚¹çš„ä¸ªæ•°
    leftLen := 0
    // å‰åºçš„é¦–å…ƒç´ ä¸ºæ ¹èŠ‚ç‚¹
    va := preorder[0]
    //åœ¨ä¸­åºéå†ä¸­æ‰¾åˆ°å¯¹åº”çš„ä½ç½®
    for k,v := range inorder {
        if v == va {
            leftLen = k
            break 
        }
    }
		
  	// ç»“åˆä¸‹å›¾ç†è§£
    root := &TreeNode{Val:preorder[0],Left:buildTree(preorder[1:1+leftLen],inorder[:leftLen]),Right:buildTree(preorder[1+leftLen:],inorder[leftLen+1:])}
    return root
}
```
![32a483e6-2c29-47bb-8b34-d173fd33e1a5.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411708260-32a483e6-2c29-47bb-8b34-d173fd33e1a5.png)

## 78. å­é›†
ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums` ï¼Œæ•°ç»„ä¸­çš„å…ƒç´  **äº’ä¸ç›¸åŒ** ã€‚è¿”å›è¯¥æ•°ç»„æ‰€æœ‰å¯èƒ½çš„å­é›†ï¼ˆå¹‚é›†ï¼‰ã€‚è§£é›† **ä¸èƒ½** åŒ…å«é‡å¤çš„å­é›†ã€‚ä½ å¯ä»¥æŒ‰ **ä»»æ„é¡ºåº** è¿”å›è§£é›†ã€‚
æ€è·¯ï¼š
å›æº¯ç®—æ³•ï¼šç±»ä¼¼äºéå†è¿™æ£µæ ‘
![5ad20e9f-ec8e-4a24-bc81-f08b526f3ccb.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411708369-5ad20e9f-ec8e-4a24-bc81-f08b526f3ccb.png)


```go
var result [][]int
func subsets(nums []int) [][]int {
  	// ç»“æœ
    result = [][]int{}
  	// éå†è·¯å¾„
    trace := []int{}
    backtrack(nums,trace,0)
    return result
}

func backtrack(nums []int,trace []int,start int) {
		
  	// å°† trace ä¿å­˜åˆ°resultä¸­
    temp := make([]int,len(trace))
    copy(temp,trace)
    result = append(result,temp)
	
  	// é€‰æ‹©èŒƒå›´: [start:len(nums)-1]
    for i := start;i < len(nums);i++ {
        //é€‰æ‹©
        trace = append(trace,nums[i])
			
      	// ä¸‹ä¸€å±‚çš„é€‰æ‹©
        backtrack(nums,trace,i+1)
        //æ’¤é”€
        trace = trace[:len(trace)-1]
    }
}
```
## 43. å­—ç¬¦ä¸²ç›¸ä¹˜
ç»™å®šä¸¤ä¸ªä»¥å­—ç¬¦ä¸²å½¢å¼è¡¨ç¤ºçš„éè´Ÿæ•´æ•° `num1` å’Œ `num2`ï¼Œè¿”å› `num1` å’Œ `num2` çš„ä¹˜ç§¯ï¼Œå®ƒä»¬çš„ä¹˜ç§¯ä¹Ÿè¡¨ç¤ºä¸ºå­—ç¬¦ä¸²å½¢å¼ã€‚
**æ³¨æ„ï¼š**ä¸èƒ½ä½¿ç”¨ä»»ä½•å†…ç½®çš„ BigInteger åº“æˆ–ç›´æ¥å°†è¾“å…¥è½¬æ¢ä¸ºæ•´æ•°ã€‚
æ€è·¯ï¼š

- å®šä¹‰ä¸¤ä¸ªæŒ‡é’ˆ`i j`ï¼Œåˆ†åˆ«æŒ‡å‘ `num1` å’Œ `num2`çš„å°¾éƒ¨ï¼Œä»ä¸ªä½å¼€å§‹è®¡ç®—ä¹˜ç§¯
- è®¡ç®—çš„ç»“æœç´¯åŠ ï¼Œä¿å­˜åˆ° `res`çš„ç´¢å¼• `i+j+1`ä½ç½®å¤„![15c237c1-f0fb-4c3f-8400-3e6cbabee0ae.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411708374-15c237c1-f0fb-4c3f-8400-3e6cbabee0ae.png)


- æœ€åï¼Œå°†`res`ä¸­çš„ç»“æœï¼Œä»å°¾éƒ¨åˆ°é¦–éƒ¨ï¼ˆä¹Ÿå°±æ˜¯ä»ä¸ªä½ï¼‰ä¾æ¬¡è¿›ä½ï¼Œå¾—åˆ°æœ€ç»ˆçš„ç»“æœ![eb074461-6963-4596-add0-097fe6eaa046.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411708374-eb074461-6963-4596-add0-097fe6eaa046.png)


```go
func multiply(num1 string, num2 string) string {
    
  	// å®šä¹‰result åˆ‡ç‰‡ï¼Œé•¿åº¦ä¸º m+n
    m,n := len(num1),len(num2)
    result := make([]int,m+n)

    // 1.ä»åå¾€å‰ã€ç›¸ä¹˜ã€‘ï¼Œï¼ˆä»ä¸ªä½å¼€å§‹è¿›è¡Œç›¸ä¹˜ï¼‰
    for i := m-1;i >= 0;i-- {
        for j := n-1;j >= 0;j-- {
            result[i+j+1] += int(num1[i] - '0') * int(num2[j]-'0') // ä¹˜ç§¯çš„ç»“æœï¼Œç´¯åŠ ä¿å­˜åˆ° result[i+j+1]
        }
    }

    // 2.ä»åå¾€å‰ã€è¿›ä½ã€‘
    for i := len(result)-1;i >= 0;i-- {
        if result[i] >= 10 { // è¶…è¿‡æ•°å€¼10
            result[i-1] += result[i] / 10 // è¿›ä½
            result[i] %= 10 //å½“å‰å–ä½™
        }
    }
	
    
    // å¦‚æœé¢˜ç›®ä¸­ä¸¤ä¸ªå­—ç¬¦ä¸²ä¸º 1234 å’Œ 0ï¼Œé‚£ä¹ˆresultä¸­å…¨éƒ¨éƒ½æ˜¯å‰å¯¼ 0ï¼Œéƒ½æ˜¯æ— æ„ä¹‰çš„ 0
    res := ""
  
    zero := true // ä»ç¬¬ä¸€ä¸ªé0çš„æ•°å­—ï¼Œå¼€å§‹è®°å½•ç»“æœ
    for _,v := range result { //éå†æ•°å€¼
        if v == 0 && zero { // å¿½ç•¥æ‰ï¼Œå‰å¯¼ 0
            continue
        }
        zero = false // è¿™ä¸ªè¡¨ç¤ºï¼Œé‡åˆ°ç¬¬ä¸€ä¸ªé0çš„å…ƒç´ ï¼Œåç»­çš„0æ‰è®¤ä¸ºæœ‰æ•ˆ
        res +=  string('0' + rune(v))
    }
    // æ²¡ç»“æœï¼Œé»˜è®¤æ˜¯0
    if res == "" { 
        res = "0"
    }
    return  res
}
```
## 151. åè½¬å­—ç¬¦ä¸²ä¸­çš„å•è¯
ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² `s` ï¼Œè¯·ä½ åè½¬å­—ç¬¦ä¸²ä¸­ **å•è¯** çš„é¡ºåºã€‚**å•è¯** æ˜¯ç”±éç©ºæ ¼å­—ç¬¦ç»„æˆçš„å­—ç¬¦ä¸²ã€‚`s` ä¸­ä½¿ç”¨è‡³å°‘ä¸€ä¸ªç©ºæ ¼å°†å­—ç¬¦ä¸²ä¸­çš„ **å•è¯** åˆ†éš”å¼€ã€‚è¿”å› **å•è¯** é¡ºåºé¢ å€’ä¸” **å•è¯** ä¹‹é—´ç”¨å•ä¸ªç©ºæ ¼è¿æ¥çš„ç»“æœå­—ç¬¦ä¸²ã€‚
**æ³¨æ„ï¼š**è¾“å…¥å­—ç¬¦ä¸² `s`ä¸­å¯èƒ½ä¼šå­˜åœ¨å‰å¯¼ç©ºæ ¼ã€å°¾éšç©ºæ ¼æˆ–è€…å•è¯é—´çš„å¤šä¸ªç©ºæ ¼ã€‚è¿”å›çš„ç»“æœå­—ç¬¦ä¸²ä¸­ï¼Œå•è¯é—´åº”å½“ä»…ç”¨å•ä¸ªç©ºæ ¼åˆ†éš”ï¼Œä¸”ä¸åŒ…å«ä»»ä½•é¢å¤–çš„ç©ºæ ¼ã€‚
**ç¤ºä¾‹ 1ï¼š**

```go
è¾“å…¥ï¼šs = "the sky is blue"
è¾“å‡ºï¼š"blue is sky the"
```
æ€è·¯ï¼š
è¿™é¢˜å¦‚æœåšè¿‡äº†ï¼Œå¾ˆå®¹æ˜“ç†è§£+è®°å¿†ï¼Œå…¨æ˜¯æŠ€å·§ï¼Œæ²¡æœ‰æ„Ÿæƒ…ã€‚é¢è¯•åä¸º`OD`å²—ä½æœ‰è¿™é“åŸå§‹é¢˜ç›®ã€‚

- å…ˆå»æ‰å¤šä½™çš„ç©ºæ ¼
- å¯¹æ•´ä¸ªå­—ç¬¦ä¸²è¿›è¡Œåè½¬
- ç„¶åç§»åŠ¨å¯¹æ¯ä¸ªå•è¯è¿›è¡Œåè½¬
```go
func reverseWords(s string) string {
    //1.å…ˆæ¸…ç†ç©ºæ ¼
    result := []byte{}
    for i := 0;i<len(s);i++ { //ä¸€ä¸ªå­—ç¬¦ä¸€ä¸ªå­—ç¬¦çš„è¿‡æ»¤
        if s[i] != ' ' { // ä¸æ˜¯ç©ºæ ¼ï¼Œä¿å­˜
            result = append(result,s[i])
        } else {// æ˜¯ç©ºæ ¼ï¼Œè¦æ±‚å¿…é¡»å­˜åœ¨æœ‰æ•ˆå­—ç¬¦ï¼Œå¹¶ä¸”ä¸æ˜¯ç©ºæ ¼
            if len(result) != 0 && result[len(result)-1] != ' ' {
                result = append(result,' ')
            }
        }
    }
    //2.å¦‚æœå­˜åœ¨ï¼ˆå»é™¤æœ€åä¸€ä¸ªç©ºæ ¼ï¼‰
    if result[len(result)-1] == ' ' {
        result = result[:len(result)-1]
    }
    //3.ç¿»è½¬æ•´ä¸ªå­—ç¬¦ä¸²
    reverse(result,0,len(result)-1)

    //4.ç¿»è½¬æ¯ä¸ªå•è¯
    for i := 0;i < len(result); {
        for j := i;j < len(result);j++ {// æ‰¾åˆ°ä¸€ä¸ªå•è¯
            if j + 1 == len(result) || result[j+1] == ' ' { //æ‰¾åˆ°ç©ºæ ¼ï¼Œæˆ–è€… ç»“å°¾
                reverse(result,i,j)
                //å¼€å§‹ä¸‹ä¸€ä¸ªå•è¯ï¼ˆè·³è¿‡ç»“å°¾å’Œç©ºæ ¼ï¼‰
                i = j + 2
                break
            }

        }
    }
		// æœ€ç»ˆç»“æœ
    return string(result)
}

func reverse(word []byte,i,j int){
    for i < j {
        word[i],word[j] = word[j],word[i]
        i++
        j--
    }
}
```
## 155. æœ€å°æ ˆ
è®¾è®¡ä¸€ä¸ªæ”¯æŒ `push` ï¼Œ`pop` ï¼Œ`top` æ“ä½œï¼Œå¹¶èƒ½åœ¨å¸¸æ•°æ—¶é—´å†…æ£€ç´¢åˆ°æœ€å°å…ƒç´ çš„æ ˆã€‚
å®ç° `MinStack` ç±»:

- `MinStack()` åˆå§‹åŒ–å †æ ˆå¯¹è±¡ã€‚
- `void push(int val)` å°†å…ƒç´ valæ¨å…¥å †æ ˆã€‚
- `void pop()` åˆ é™¤å †æ ˆé¡¶éƒ¨çš„å…ƒç´ ã€‚
- `int top()` è·å–å †æ ˆé¡¶éƒ¨çš„å…ƒç´ ã€‚
- `int getMin()` è·å–å †æ ˆä¸­çš„æœ€å°å…ƒç´ ã€‚æ€è·¯ï¼š
æˆ‘ä»¬çŸ¥é“æ ˆæ˜¯ä¸€ç§æ“ä½œå—é™çš„æ•°æ®ç»“æ„ï¼Œåªèƒ½ä»æ ˆé¡¶æ’å…¥æˆ–å¼¹å‡ºå…ƒç´ ï¼Œæ‰€ä»¥å¯¹äºæ ‡å‡†çš„æ ˆæ¥è¯´ï¼Œå¦‚æœæƒ³å®ç°æœ¬é¢˜çš„ `getMin` æ–¹æ³•ï¼Œåªèƒ½è€è€å®å®æŠŠæ‰€æœ‰å…ƒç´ å¼¹å‡ºæ¥ç„¶åæ‰¾æœ€å°å€¼ã€‚**æƒ³æé«˜æ—¶é—´æ•ˆç‡ï¼Œé‚£è‚¯å®šè¦é€šè¿‡ç©ºé—´æ¢æ—¶é—´çš„æ€è·¯**ã€‚
æ‰€ä»¥è¿™é“é¢˜çš„å…³é”®å°±æ˜¯ï¼Œ**æ¯ä¸ªå…ƒç´ å…¥æ ˆæ—¶ï¼Œè¿˜è¦è®°ä¸‹æ¥å½“å‰æ ˆä¸­çš„æœ€å°å€¼**ã€‚æ¯”æ–¹è¯´ï¼Œå¯ä»¥ç”¨ä¸€ä¸ªé¢å¤–çš„æ ˆ `minstack` æ¥è®°å½•æ ˆä¸­æ¯ä¸ªå…ƒç´ å…¥æ ˆæ—¶çš„**æ ˆä¸­çš„æœ€å°å…ƒç´ **æ˜¯å¤šå°‘ï¼Œè¿™æ ·æ¯æ¬¡è·å–å…ƒç´ æ—¶å°±èƒ½å¿«é€Ÿå¾—åˆ°å‰©ä½™æ ˆä¸­çš„æœ€å°å…ƒç´ äº†ã€‚

```go
type MinStack struct {
    stack []int // å­˜å‚¨æ‰€æœ‰å…ƒç´ 
    minstack []int // å­˜å‚¨æœ€å°å…ƒç´ ï¼ˆä¹Ÿå°±æ˜¯æ¯”æ ˆé¡¶å…ƒç´ è¿˜è¦å°çš„å…ƒç´ ï¼Œæ‰èƒ½ä¿å­˜åˆ° minstackä¸­ï¼‰
}


func Constructor() MinStack {
    return MinStack {
        stack:make([]int,0),
        minstack:make([]int,0),
    }
}


func (this *MinStack) Push(val int)  {
  	// å…¥æ ˆ
    this.stack = append(this.stack,val)

    if len(this.minstack) == 0 {
        this.minstack = append(this.minstack,val)
    } else {
      	// val æ¯” minstack æ ˆé¡¶å…ƒç´ æ›´å°ï¼Œæ‰èƒ½ä¿å­˜ï¼ˆè®°å½•æ ˆä¸­æ¯ä¸ªå…ƒç´ å…¥æ ˆæ—¶çš„æ ˆä¸­çš„æœ€å°å…ƒç´ ï¼‰
        if this.minstack[len(this.minstack)-1] >= val {
            this.minstack = append(this.minstack,val)
        }
    }
}


func (this *MinStack) Pop()  {
		// å¦‚æœå¼¹å‡ºçš„å…ƒç´ å’Œæœ€å°æ ˆçš„æ ˆé¡¶å…ƒç´ ä¸€æ ·ï¼Œæœ€å°æ ˆä¹Ÿéœ€è¦å¼¹å‡º
    if this.Top() == this.minstack[len(this.minstack)-1] {
         this.minstack = this.minstack[:len(this.minstack)-1]
    }
		// å¼¹å‡ºæ ˆé¡¶å…ƒç´ 
    this.stack = this.stack[:len(this.stack)-1]
}

// æ ˆé¡¶å…ƒç´ 
func (this *MinStack) Top() int {
    return this.stack[len(this.stack)-1]
}

// æœ€å°å…ƒç´ 
func (this *MinStack) GetMin() int {
    return this.minstack[len(this.minstack)-1]
}
```
## 129. æ±‚æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹æ•°å­—ä¹‹å’Œ
ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œæ ‘ä¸­æ¯ä¸ªèŠ‚ç‚¹éƒ½å­˜æ”¾æœ‰ä¸€ä¸ª `0` åˆ° `9` ä¹‹é—´çš„æ•°å­—ã€‚
æ¯æ¡ä»æ ¹èŠ‚ç‚¹åˆ°å¶èŠ‚ç‚¹çš„è·¯å¾„éƒ½ä»£è¡¨ä¸€ä¸ªæ•°å­—ï¼š

- ä¾‹å¦‚ï¼Œä»æ ¹èŠ‚ç‚¹åˆ°å¶èŠ‚ç‚¹çš„è·¯å¾„ `1 -> 2 -> 3` è¡¨ç¤ºæ•°å­— `123` ã€‚è®¡ç®—ä»æ ¹èŠ‚ç‚¹åˆ°å¶èŠ‚ç‚¹ç”Ÿæˆçš„ **æ‰€æœ‰æ•°å­—ä¹‹å’Œ** ã€‚
**å¶èŠ‚ç‚¹** æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚
![b81426c7-4cbb-4b3c-8c47-72d1e0c2c741.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411708599-b81426c7-4cbb-4b3c-8c47-72d1e0c2c741.png)

æ€è·¯ï¼š
è¿™é¢˜å°±æ˜¯æ ‡å‡†çš„äºŒå‰æ ‘éå†é¢˜å‹ï¼Œéå†çš„åŒæ—¶éœ€è¦ç´¯ç§¯æ¯ä¸ªèŠ‚ç‚¹çš„å€¼

```go
func sumNumbers(root *TreeNode) int {
    return traverse(root,0)
}

// root ä»æ ¹èŠ‚ç‚¹åˆ°å¶èŠ‚ç‚¹ç”Ÿæˆçš„ æ‰€æœ‰è·¯å¾„æ•°å­—ä¹‹å’Œ 
// cur ç´¯ç§¯åˆ°root èŠ‚ç‚¹ï¼Œå¯¹åº”çš„æ•°å­—
func traverse(root *TreeNode,cur int) int {
    
    if root == nil {
        return 0
    }
    // éå†åˆ°å½“å‰èŠ‚ç‚¹ï¼Œå¯¹åº”çš„è·¯å¾„æ•°å­—
    cur = 10 * cur + root.Val
   
    if root.Left == nil && root.Right == nil { // è¯´æ˜å½“å‰æ˜¯å¶å­èŠ‚ç‚¹
        return cur // è¿”å›è·¯å¾„æ•°å­—
    }
  	// ä» root.Leftåˆ°å¶å­èŠ‚ç‚¹ è·¯å¾„æ•°å­—ä¹‹å’Œ + ä» root.Right åˆ°å¶å­èŠ‚ç‚¹ è·¯å¾„æ•°å­—ä¹‹å’Œ
    return traverse(root.Left,cur) + traverse(root.Right,cur)
}
```
## 101. å¯¹ç§°äºŒå‰æ ‘
ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œ æ£€æŸ¥å®ƒæ˜¯å¦è½´å¯¹ç§°ã€‚
![ec7456b7-81ec-45b3-8895-a6eba4d2c083.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411708734-ec7456b7-81ec-45b3-8895-a6eba4d2c083.png)

æ€è·¯ï¼š

- è§‚å¯Ÿä¸‹ä¸Šé¢çš„ç¤ºä¾‹ï¼Œã€å¯¹ç§°ã€‘å°±æ˜¯å·¦å³ä¸¤é¢—æ ‘æ˜¯é•œåƒã€‚å¯¹ç§°çš„æ£€æŸ¥è¿‡ç¨‹ï¼Œå°±æ˜¯äºŒå‰æ ‘çš„éå†è¿‡ç¨‹ã€‚
- å…ˆæ£€æŸ¥å·¦å³ä¸¤ä¸ªæ ¹èŠ‚ç‚¹`root.Left root.Right`æ˜¯å¦ç›¸åŒï¼›
- å¦‚æœç›¸åŒï¼Œå†æ£€æŸ¥ã€å·¦èŠ‚ç‚¹çš„å·¦æ ‘ å’Œ å³èŠ‚ç‚¹çš„å³æ ‘ã€‘ ä»¥åŠã€å·¦èŠ‚ç‚¹çš„å³æ ‘ å’Œ å³èŠ‚ç‚¹çš„å·¦æ ‘ã€‘æ˜¯å¦å¯¹ç§°
```go
func isSymmetric(root *TreeNode) bool {
  	// ç©ºæ ‘ï¼Œä¸€å®šå¯¹ç§°
   if root == nil {
       return true
   }
	 // æ£€æŸ¥å·¦å³æ ‘æ˜¯å¦å¯¹ç§°
   return check(root.Left,root.Right)
}

// check æ ¡éªŒå·¦å³æ ‘å¯¹ç§°
func check(left,right *TreeNode) bool {
    // éƒ½æ˜¯nil
    if left == nil && right == nil {
        return true
    }
    // æœ‰ä¸€ä¸ªæ˜¯nil
    if left == nil || right == nil {
        return false
    }
  	// å·¦å³èŠ‚ç‚¹ä¸ç›¸åŒ
    if left.Val != right.Val {
        return false
    }
    // åœ¨ã€å·¦å³æ ‘æ ¹èŠ‚ç‚¹ã€‘ç›¸åŒçš„æƒ…å†µä¸‹ï¼Œç»§ç»­æ£€æŸ¥ä¸‹å±‚çš„æ ‘ç»“æ„ï¼Œæ˜¯å¦å¯¹ç§°
    return check(left.Left,right.Right) && check(left.Right,right.Left)
}
```
## 144. äºŒå‰æ ‘çš„å‰åºéå†
ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œè¿”å›å®ƒèŠ‚ç‚¹å€¼çš„ **å‰åº** éå†ã€‚

```go
// è¿­ä»£æ–¹å¼å‰åºéå†äºŒå‰æ ‘ ï¼ˆ è¿™ä¸ªè§£æ³•å’Œä¸Šé¢çš„ã€ä¸­åºéå†ã€‘å¯¹æ¯”çœ‹ä¸‹ï¼Œå¯ä»¥çœ‹åˆ°å®Œå…¨ä¸€æ ·çš„å†™æ³•ï¼Œåªæ˜¯ ã€è®°å½•æ•°å€¼ã€‘çš„ä½ç½®ä¸åŒè€Œå·²
func preorderTraversal1(root *TreeNode) []int {

    result := []int{}
    if root == nil {
        return result
    }

    sk := []*TreeNode{}
    for len(sk) != 0 || root != nil {
      	// å…ˆå¤„ç†å·¦èŠ‚ç‚¹
        for root != nil {
            result = append(result,root.Val) // è®°å½•æ•°å€¼
            sk = append(sk,root) // å…¥æ ˆ
            root = root.Left
        }
        // å†å¤„ç†å³èŠ‚ç‚¹
        root = sk[len(sk)-1]
        sk = sk[:len(sk)-1] // å‡ºæ ˆ
        root = root.Right
    }
    return result
}


// æœ€ç®€å•çš„é€’å½’æ–¹å¼éå†äºŒå‰æ ‘
var res []int
func preorderTraversal(root *TreeNode) []int {

    res = []int{}
    preorder(root)

    return res
}

func preorder(root *TreeNode){
    if root == nil {
        return
    }

    res = append(res,root.Val)
    preorder(root.Left)
    preorder(root.Right)
}
```
## 104. äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦
ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ `root` ï¼Œè¿”å›å…¶æœ€å¤§æ·±åº¦ã€‚äºŒå‰æ ‘çš„ **æœ€å¤§æ·±åº¦** æ˜¯æŒ‡ä»æ ¹èŠ‚ç‚¹åˆ°æœ€è¿œå¶å­èŠ‚ç‚¹çš„æœ€é•¿è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ•°ã€‚
æ€è·¯ï¼š
æ³¨æ„`maxDepth`å‡½æ•°çš„å®šä¹‰ï¼šä»¥ `root`ä¸ºæ ¹èŠ‚ç‚¹çš„äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

// ä»¥ `root`ä¸ºæ ¹èŠ‚ç‚¹çš„äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦
func maxDepth(root *TreeNode) int {
  	// å¦‚æœèŠ‚ç‚¹ä¸ºnil,æ·±åº¦ä¸º0
    if root == nil {
        return 0
    }
  	// ä»¥ root.Left ä¸ºæ ¹èŠ‚ç‚¹çš„äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦ 
  	// ä»¥ root.Right ä¸ºæ ¹èŠ‚ç‚¹çš„äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦ 
    // å–æœ€å¤§å€¼ + 1 ä½œä¸º ä»¥ `root`ä¸ºæ ¹èŠ‚ç‚¹çš„äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦ï¼ˆ +1 è¡¨ç¤ºå½“å‰çš„rootè¿™ä¸ªèŠ‚ç‚¹çš„è®¡æ•°ï¼‰
    return max(maxDepth(root.Left),maxDepth(root.Right)) + 1
}

func max( a,b int) int{
    if a > b {
        return a
    }
    return b
}
```
## 39. ç»„åˆæ€»å’Œ
ç»™ä½ ä¸€ä¸ª **æ— é‡å¤å…ƒç´ ** çš„æ•´æ•°æ•°ç»„ `candidates` å’Œä¸€ä¸ªç›®æ ‡æ•´æ•° `target` ï¼Œæ‰¾å‡º `candidates` ä¸­å¯ä»¥ä½¿æ•°å­—å’Œä¸ºç›®æ ‡æ•° `target` çš„ æ‰€æœ‰ **ä¸åŒç»„åˆ** ï¼Œå¹¶ä»¥åˆ—è¡¨å½¢å¼è¿”å›ã€‚ä½ å¯ä»¥æŒ‰ **ä»»æ„é¡ºåº** è¿”å›è¿™äº›ç»„åˆã€‚
`candidates` ä¸­çš„ **åŒä¸€ä¸ª** æ•°å­—å¯ä»¥ **æ— é™åˆ¶é‡å¤è¢«é€‰å–** ã€‚å¦‚æœè‡³å°‘ä¸€ä¸ªæ•°å­—çš„è¢«é€‰æ•°é‡ä¸åŒï¼Œåˆ™ä¸¤ç§ç»„åˆæ˜¯ä¸åŒçš„ã€‚
å¯¹äºç»™å®šçš„è¾“å…¥ï¼Œä¿è¯å’Œä¸º `target` çš„ä¸åŒç»„åˆæ•°å°‘äº `150` ä¸ªã€‚
æ€è·¯ï¼š
åˆ©ç”¨å›æº¯ç®—æ³•è§£é¢˜ï¼š

- éœ€è¦æŒ‡å®š `start`é™å®šå¯é€‰å…ƒç´ çš„èŒƒå›´ï¼ˆå› ä¸ºæ˜¯æ±‚ç»„åˆé—®é¢˜ï¼‰ï¼Œå¦‚æœæ˜¯æ±‚æ’åˆ—ï¼Œä¸ç”¨æŒ‡å®šå½¢å‚ `start`ï¼ˆå¯ä»¥çœ‹ä¸‹ä¸Šé¢çš„å›æº¯ç®—æ³•è§£é¢˜å¥—è·¯æ¨¡æ¿ï¼‰
- å…ƒç´ å¯ä»¥é‡å¤ä½¿ç”¨å¤šæ¬¡è¿™é“é¢˜çš„å…³é”®åœ¨äº `candidates` ä¸­çš„**å…ƒç´ å¯ä»¥å¤ç”¨å¤šæ¬¡**ï¼Œä½“ç°åœ¨ä»£ç ä¸­æ˜¯ä¸‹é¢è¿™æ®µï¼š

```go
func backtrace(candidates []int, start int, trace []int, target int, sum int) {
  
  for i := start; i < len(candidates); i++ {
		// é€‰æ‹©
    
    // ä¸‹ä¸€å±‚çš„é€‰æ‹©ã€æ³¨æ„è¿™é‡Œï¼šiã€‘
		backtrace(candidates, i , trace, target, sum)
    
    // æ’¤é”€
	}
}
```
å¦‚æœé¢˜ç›®è¦æ±‚ `candidates`ä¸­çš„å…ƒç´ ã€ä¸èƒ½ã€‘é‡å¤å¤šæ¬¡ï¼Œä½“ç°åœ¨ä»£ç ä¸­æ˜¯ä¸‹é¢è¿™æ®µï¼š

```go
func backtrace(candidates []int, start int, trace []int, target int, sum int) {
  
  for i := start; i < len(candidates); i++ {
		// é€‰æ‹©
    
    // ä¸‹ä¸€å±‚çš„é€‰æ‹©ã€æ³¨æ„è¿™é‡Œï¼ši+1ã€‘
		backtrace(candidates, i+1 , trace, target, sum)
    
    // æ’¤é”€
	}
}
```
æ³¨æ„ä½“ä¼šå…ˆè¿™ä¸¤ç§åŒºåˆ«ã€‚
å®é™…ä»£ç å¦‚ä¸‹ï¼š

```go
var result [][]int

func combinationSum(candidates []int, target int) [][]int {
	//å›æº¯ç®—æ³•

	result = [][]int{}
	trace := []int{}
	backtrace(candidates, 0, trace, target, 0)

	return result
}

// å› ä¸ºæ±‚ç»„åˆé—®é¢˜ï¼Œéœ€è¦ startæ¥é™å®šå…ƒç´ çš„é€‰æ‹©èŒƒå›´ï¼Œå¦‚æœæ˜¯æ±‚æ’åˆ—ï¼Œå°±ä¸éœ€è¦ startå‚æ•°
func backtrace(candidates []int, start int, trace []int, target int, sum int) {
	
  // ç»ˆæ­¢æ¡ä»¶
	if sum >= target {  // å› ä¸ºéƒ½æ˜¯æ­£æ•´æ•°ï¼ˆå‰ªæï¼‰
		if sum == target { // æ‰¾åˆ°ä¸€ä¸ªç»“æœ
			temp := make([]int, len(trace))
			copy(temp, trace)
			result = append(result, temp)
		}
		return
	}

	// æ‰§è¡Œåˆ°è¿™é‡Œï¼Œè¯´æ˜ sum < targetï¼Œç»§ç»­æ‰¾ä¸‹ä¸€ä¸ªå…ƒç´ åŠ å…¥åˆ° trace ä¸­
	for i := start; i < len(candidates); i++ {
    // é€‰æ‹©
		trace = append(trace, candidates[i])
		sum += candidates[i]

    // ä¸‹ä¸€å±‚ï¼ˆå…ƒç´ å¯ä»¥é‡å¤é€‰æ‹©ï¼‰çš„é€‰æ‹©èŒƒå›´ä¸º [i:len(nums)-1]
    // å¦‚æœä¸èƒ½é‡å¤é€‰æ‹©ï¼Œè¿™é‡Œåº”è¯¥å¡«å†™ i+1
		backtrace(candidates, i , trace, target, sum)

    // æ’¤é”€
		trace = trace[:len(trace)-1]
		sum -= candidates[i]
	}
}
```
## 101. å¹³è¡¡äºŒå‰æ ‘
ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œåˆ¤æ–­å®ƒæ˜¯å¦æ˜¯ å¹³è¡¡äºŒå‰æ ‘
æ€è·¯ï¼š
**å¹³è¡¡äºŒå‰æ ‘** æ˜¯æŒ‡è¯¥æ ‘æ‰€æœ‰èŠ‚ç‚¹çš„å·¦å³å­æ ‘çš„é«˜åº¦ç›¸å·®ä¸è¶…è¿‡ 1
å…¶å®è¿™é¢˜æ˜¯**æ±‚æ ‘çš„æœ€å¤§æ·±åº¦**çš„ä¸€ä¸ªæ‰©å±•ï¼Œå¤šäº†ä¸€æ­¥æ±‚å·¦å³å­æ ‘çš„é«˜åº¦å·®

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

var isbalance bool = true
func isBalanced(root *TreeNode) bool {
    isbalance = true
    if root == nil {
        return true
    }
    maxDepth(root)
    return isbalance
}

// æ±‚æ ‘çš„æœ€å¤§æ·±åº¦
func maxDepth(root *TreeNode) int {
    if root == nil {
        return 0
    }
		// å·¦å³æ ‘çš„æœ€å¤§æ·±åº¦
    leftVal := maxDepth(root.Left)
    rightVal := maxDepth(root.Right)
  	// å¦‚æœé«˜åº¦å·®ï¼Œç»å¯¹å€¼ç›¸å·® 1ï¼Œè¯´æ˜ä¸å¹³è¡¡
  if abs(leftVal,rightVal) > 1 {
        isbalance = false
    }
    return 1 + max(leftVal,rightVal)
}

func abs(a,b int) int {
    if a > b {
        return a-b
    }
    return b-a
}
func max(a,b int)int{
    if a>b {
        return a
    }
    return b
}
```
## 48. æ—‹è½¬å›¾åƒ
ç»™å®šä¸€ä¸ª *n* Ã— *n* çš„äºŒç»´çŸ©é˜µ `matrix` è¡¨ç¤ºä¸€ä¸ªå›¾åƒã€‚è¯·ä½ å°†å›¾åƒé¡ºæ—¶é’ˆæ—‹è½¬ 90 åº¦ã€‚ä½ å¿…é¡»åœ¨**[åŸåœ°](https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)** æ—‹è½¬å›¾åƒï¼Œè¿™æ„å‘³ç€ä½ éœ€è¦ç›´æ¥ä¿®æ”¹è¾“å…¥çš„äºŒç»´çŸ©é˜µã€‚**è¯·ä¸è¦** ä½¿ç”¨å¦ä¸€ä¸ªçŸ©é˜µæ¥æ—‹è½¬å›¾åƒã€‚
![5f696fa3-0859-4759-90f1-df9a41d0a8cc.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411708978-5f696fa3-0859-4759-90f1-df9a41d0a8cc.png)

æ€è·¯ï¼š
è¿™é¢˜å…¶å®å°±æ˜¯**çªçœ¼æ³•**æ‰¾åˆ°æ•°å­—ä¹‹é—´çš„äº¤æ¢è§„åˆ™ã€‚
å…ˆæŠŠäºŒç»´çŸ©é˜µæ²¿å¯¹è§’çº¿åè½¬ï¼Œç„¶ååè½¬çŸ©é˜µçš„æ¯ä¸€è¡Œï¼Œç»“æœå°±æ˜¯é¡ºæ—¶é’ˆåè½¬æ•´ä¸ªçŸ©é˜µã€‚

```go
func rotate(matrix [][]int)  {
    ///ï¼ï¼ï¼å·§æ€é¢˜ï¼šé¡ºæ—¶é’ˆæ—‹è½¬,ä»å·¦ä¸Šè§’åˆ°å³ä¸‹è§’--å¯¹è§’çº¿äº¤æ¢ï¼›å¦‚æœæ˜¯é€†æ—¶é’ˆæ—‹è½¬ï¼ŒæŒ‰ç…§å³ä¸Šè§’åˆ°å·¦ä¸‹è§’-å¯¹è§’çº¿äº¤æ¢
    ///1.é¡ºæ—¶é’ˆæ—‹è½¬,æŒ‰ç…§ä»å·¦ä¸Šè§’åˆ°å³ä¸‹è§’--å¯¹è§’çº¿äº¤æ¢ï¼Œç»“æœä¸º
    /*
        1 4 7
        2 5 8
        3 6 9
    */
    n := len(matrix)
    for i := 0;i < n;i++ {
        for j := i+1;j < n;j++ {
            //å¯¹è§’çº¿ç¿»è½¬
            matrix[i][j],matrix[j][i] = matrix[j][i],matrix[i][j]
        }
    }
    
    ///2.å†è§‚å¯Ÿï¼Œæ¯ä¸€è¡Œé¦–å°¾äº¤æ¢ï¼Œå³ä¸ºç»“æœ
    for i := 0;i < n;i++ {
        left ,right := 0,n-1
        for left < right {
            matrix[i][left],matrix[i][right] = matrix[i][right],matrix[i][left]
            left++
            right--
        }
    }
}
```
## 543. äºŒå‰æ ‘çš„ç›´å¾„
ç»™ä½ ä¸€æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œè¿”å›è¯¥æ ‘çš„ **ç›´å¾„** ã€‚äºŒå‰æ ‘çš„ **ç›´å¾„** æ˜¯æŒ‡æ ‘ä¸­ä»»æ„ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´æœ€é•¿è·¯å¾„çš„ **é•¿åº¦** ã€‚è¿™æ¡è·¯å¾„å¯èƒ½ç»è¿‡ä¹Ÿå¯èƒ½ä¸ç»è¿‡æ ¹èŠ‚ç‚¹ `root` ã€‚
ä¸¤èŠ‚ç‚¹ä¹‹é—´è·¯å¾„çš„ **é•¿åº¦** ç”±å®ƒä»¬ä¹‹é—´è¾¹æ•°è¡¨ç¤ºã€‚
æ€è·¯ï¼š
æ‰€è°“äºŒå‰æ ‘çš„ç›´å¾„ï¼Œå°±æ˜¯å·¦å³å­æ ‘çš„æœ€å¤§æ·±åº¦ä¹‹å’Œï¼Œé‚£ä¹ˆç›´æ¥çš„æƒ³æ³•æ˜¯å¯¹æ¯ä¸ªèŠ‚ç‚¹è®¡ç®—å·¦å³å­æ ‘çš„æœ€å¤§é«˜åº¦ï¼Œå¾—å‡ºæ¯ä¸ªèŠ‚ç‚¹çš„ç›´å¾„ï¼Œä»è€Œå¾—å‡ºæœ€å¤§çš„é‚£ä¸ªç›´å¾„ã€‚

```go
var result int = 0
func diameterOfBinaryTree(root *TreeNode) int {
   
    result = 0
    maxDepth(root)
    return result
}

// æ ‘çš„æœ€å¤§é«˜åº¦
func maxDepth(root *TreeNode) int{

    if root == nil {
        return 0
    }
    // rootå·¦å­æ ‘æœ€å¤§é«˜åº¦
    leftDepth := maxDepth(root.Left)
    // rootå³å­æ ‘æœ€å¤§é«˜åº¦
    rightDepth := maxDepth(root.Right)
    //ç»è¿‡rootèŠ‚ç‚¹çš„æœ€å¤§ç›´å¾„ï¼ˆæ³¨æ„ï¼šè¿™é‡Œä¸éœ€è¦å¯¹leftDepth + rightDepth å†+1ï¼‰ï¼Œè®¡ç®—çš„æ˜¯è¾¹çš„æ•°ç›®
    result = max(result,leftDepth+rightDepth) 
  
  	// å·¦å³å­æ ‘é«˜åº¦çš„æœ€å¤§å€¼ + 1
    return 1 + max(leftDepth,rightDepth) 
}

func max(a,b int) int {
    if a > b {
        return a
    }
    return b
}
```
## 470. ç”¨ Rand7()å®ç°Rand10()
ç»™å®šæ–¹æ³• `rand7` å¯ç”Ÿæˆ `[1,7]` èŒƒå›´å†…çš„å‡åŒ€éšæœºæ•´æ•°ï¼Œè¯•å†™ä¸€ä¸ªæ–¹æ³• `rand10` ç”Ÿæˆ `[1,10]` èŒƒå›´å†…çš„å‡åŒ€éšæœºæ•´æ•°ã€‚
ä½ åªèƒ½è°ƒç”¨ `rand7()` ä¸”ä¸èƒ½è°ƒç”¨å…¶ä»–æ–¹æ³•ã€‚è¯·ä¸è¦ä½¿ç”¨ç³»ç»Ÿçš„ `Math.random()` æ–¹æ³•ã€‚
æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹å°†æœ‰ä¸€ä¸ªå†…éƒ¨å‚æ•° `n`ï¼Œå³ä½ å®ç°çš„å‡½æ•° `rand10()` åœ¨æµ‹è¯•æ—¶å°†è¢«è°ƒç”¨çš„æ¬¡æ•°ã€‚è¯·æ³¨æ„ï¼Œè¿™ä¸æ˜¯ä¼ é€’ç»™ `rand10()` çš„å‚æ•°ã€‚
æ€è·¯ï¼š

- `(rand7()-1)*7` ç­‰ä»·äº `(ã€1...7ã€‘- 1) * 7 ` ç­‰ä»·äº `[0...6]*7` ä¹Ÿç­‰ä»·äº `ã€0ï¼Œ7ï¼Œ14ï¼Œ21ï¼Œ28ï¼Œ35ï¼Œ42ã€‘` æ¯ä¸ªæ•°å­—åªå‡ºç°çš„æ¦‚ç‡ä¸º`1/7`
- `(rand7()-1)*7 + rand7() ` ç­‰ä»·äº`ã€0ï¼Œ7ï¼Œ14ï¼Œ21ï¼Œ28ï¼Œ35ï¼Œ42ã€‘+ rand7()` ç­‰ä»·äºæ¯ä¸ªæ•°å€¼`(0 , 7 ,14...)`åˆ†åˆ« `+ rand7()` å³ä¸º`[1...7][8...14][15...21].....[43..49] æ¯ç§å€¼å‡ºç°çš„æ¦‚ç‡éƒ½æ˜¯ç›¸åŒçš„ï¼›1/49`
- è½¬åŒ–ä¸€ä¸‹ä¸ºï¼š`[1...10] [11...20] [21..30] [31....40] [41...49]` è¿™é‡Œå°‘äº†`50`è¿™ä¸ªæ•°å€¼ï¼Œå¯¹`10`æ±‚ä½™æ•°ï¼Œå°‘äº†å‡ºç°ä¸€æ¬¡`0`çš„æœºä¼š
- æ¯”å¦‚æ±‚ã€ä½™æ•°1 ã€‘åˆ†åˆ«ä¸º `1 11 21 31 41` å¯¹10æ±‚ä½™ï¼Œå¯ä»¥å¾—åˆ°`5`æ¬¡`1`
- æ±‚ã€ä½™æ•°0ã€‘åˆ†åˆ«ä¸º`10 20 30 40`å¯¹10æ±‚ä½™ï¼Œåªèƒ½å¾—åˆ°`4`æ¬¡`1`
```go
func rand10() int {
   
    for {
        num := (rand7()-1)*7 + rand7() 
        if num <= 40 { // è¿™é‡Œè¦èˆå¼ƒ[41...49]è¿™äº›æ•°å€¼
            return num % 10 + 1 // å› ä¸ºæ±‚ [1..10]ï¼Œæ‰€ä»¥éœ€è¦ num%10 + 1
        }
    }
    return 0    
}
```
## 98. éªŒè¯äºŒå‰æœç´¢æ ‘
ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œåˆ¤æ–­å…¶æ˜¯å¦æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„äºŒå‰æœç´¢æ ‘ã€‚
**æœ‰æ•ˆ** äºŒå‰æœç´¢æ ‘å®šä¹‰å¦‚ä¸‹ï¼š

- èŠ‚ç‚¹çš„å·¦å­æ ‘åªåŒ…å«å°äº å½“å‰èŠ‚ç‚¹çš„æ•°ã€‚
- èŠ‚ç‚¹çš„å³å­æ ‘åªåŒ…å« **å¤§äº** å½“å‰èŠ‚ç‚¹çš„æ•°ã€‚
- æ‰€æœ‰å·¦å­æ ‘å’Œå³å­æ ‘è‡ªèº«å¿…é¡»ä¹Ÿæ˜¯äºŒå‰æœç´¢æ ‘ã€‚æ€è·¯ï¼š
åˆå­¦è€…åšè¿™é¢˜å¾ˆå®¹æ˜“æœ‰è¯¯åŒºï¼š`BST`ï¼ˆäºŒå‰æœç´¢æ ‘ï¼‰ ä¸æ˜¯å·¦å°å³å¤§ä¹ˆï¼Œé‚£æˆ‘åªè¦æ£€æŸ¥ `root.val > root.left.val` ä¸” `root.val < root.right.val` ä¸å°±è¡Œäº†ï¼Ÿ
è¿™æ ·æ˜¯ä¸å¯¹çš„ï¼Œå› ä¸º `BST` å·¦å°å³å¤§çš„ç‰¹æ€§æ˜¯æŒ‡ `root.val` è¦æ¯”ã€å·¦å­æ ‘çš„**æ‰€æœ‰èŠ‚ç‚¹**éƒ½æ›´å¤§ã€‘ï¼Œè¦æ¯”ã€å³å­æ ‘çš„**æ‰€æœ‰èŠ‚ç‚¹**éƒ½å°ã€‘ï¼Œä½ åªæ£€æŸ¥å·¦å³ä¸¤ä¸ªå­èŠ‚ç‚¹å½“ç„¶æ˜¯ä¸å¤Ÿçš„ã€‚
æ­£ç¡®è§£æ³•æ˜¯é€šè¿‡ä½¿ç”¨è¾…åŠ©å‡½æ•°ï¼Œå¢åŠ å‡½æ•°å‚æ•°åˆ—è¡¨ï¼Œåœ¨å‚æ•°ä¸­æºå¸¦é¢å¤–ä¿¡æ¯ï¼Œå°†è¿™ç§çº¦æŸä¼ é€’ç»™å­æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹ï¼Œè¿™ä¹Ÿæ˜¯äºŒå‰æœç´¢æ ‘ç®—æ³•çš„ä¸€ä¸ªå°æŠ€å·§å§ã€‚

```go
func isValidBST(root *TreeNode) bool {
    return isValid(root,nil,nil) // åˆšå¼€å§‹çš„rootä¸æ˜¯ä»»ä½•èŠ‚ç‚¹çš„å·¦å­æ ‘å’Œå³å­æ ‘ï¼Œæ‰€ä»¥ä¸å­˜åœ¨minå’ŒmaxèŠ‚ç‚¹
}

// éªŒè¯ root æ ‘ ä¸ æœ€å¤§èŠ‚ç‚¹å€¼å’Œæœ€å°èŠ‚ç‚¹å€¼
//  min <   rootæ ‘çš„èŠ‚ç‚¹å€¼  < max
func isValid(root *TreeNode, min *TreeNode,max *TreeNode) bool {
		// éªŒè¯èŠ‚ç‚¹å€¼
    if root == nil {
        return true
    }
		
  	// minæœ€å°å€¼ä¸ä¸ºç©ºï¼Œrootçš„å€¼ï¼Œå¦‚æœæ¯”æœ€å°å€¼è¿˜å°ï¼Œè¯´æ˜rootèŠ‚ç‚¹ä¸æ»¡è¶³ BSTæ€§è´¨
    if min != nil && root.Val <= min.Val{
        return false
    }
		// max æœ€å°å€¼ä¸ä¸ºç©ºï¼Œrootçš„å€¼ï¼Œå¦‚æœæ¯”æœ€å¤§å€¼è¿˜å¤§ï¼Œè¯´æ˜rootèŠ‚ç‚¹ä¸æ»¡è¶³ BSTæ€§è´¨
    if max != nil && root.Val >= max.Val {
        return false
    }
    // å·¦å­æ ‘çš„æœ€å¤§å€¼å°±æ˜¯rootèŠ‚ç‚¹
  	// å³å­æ ‘çš„æœ€å°å€¼å°±æ˜¯rootèŠ‚ç‚¹
    return isValid(root.Left,min,root) && isValid(root.Right,root,max)
}
```
## 221. æœ€å¤§æ­£æ–¹å½¢
åœ¨ä¸€ä¸ªç”± `'0'` å’Œ `'1'` ç»„æˆçš„äºŒç»´çŸ©é˜µå†…ï¼Œæ‰¾åˆ°åªåŒ…å« `'1'` çš„æœ€å¤§æ­£æ–¹å½¢ï¼Œå¹¶è¿”å›å…¶é¢ç§¯ã€‚
æ€è·¯ï¼š
åŠ¨æ€è§„åˆ’ï¼š

- `dp[i][j] `è¡¨ç¤º `matrix[i][j]`ä¸ºæ­£æ–¹å½¢å³ä¸‹è§’çš„**è¾¹é•¿**ï¼Œä¸Šè¾¹ï¼Œå·¦è¾¹ï¼Œå·¦ä¸Šçš„è¾¹é•¿ `>1`ï¼Œæ‰èƒ½ç»„æˆä¸€ä¸ªæ›´å¤§å®Œæ•´çš„æ­£æ–¹å½¢ï¼›
- é€’æ¨å…³ç³»ï¼šå¦‚æœ`matrx[i][j] == 0`ï¼Œè¯´æ˜æ— æ³•ç»„æˆåªåŒ…å« `'1'` çš„æ­£æ–¹å½¢ï¼Œ`dp[i][j] = 0`å³è¾¹é•¿ä¸º`0`
å¦‚æœ `matrx[i][j] == 1`ï¼Œçœ‹ä¸‹ä¸Šè¾¹ï¼Œå·¦è¾¹ï¼Œå·¦ä¸Š è¾¹é•¿ `> 1`ï¼Œæ‰èƒ½ç»„æˆä¸€ä¸ªæ›´å¤§çš„æ­£æ–¹å½¢ï¼Œæ‰€ä»¥ `dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1]) + 1`
![c52fe246-7b42-4eff-96a3-1a73f1526f94.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411709253-c52fe246-7b42-4eff-96a3-1a73f1526f94.png)


```go
func maximalSquare(matrix [][]byte) int {
	m, n := len(matrix), len(matrix[0])
  // å®šä¹‰ è¾¹é•¿ dp æ•°ç»„
	dp := make([][]int, m)
	for k, _ := range dp {
		dp[k] = make([]int, n)
	}
	// æœ€å¤§è¾¹é•¿
	length := 0

	for i := 0; i < m; i++ {
		for j := 0; j < n; j++ {
			// base case
			if i == 0 || j == 0 { // ç¬¬ä¸€è¡Œ or ç¬¬ä¸€åˆ—
				dp[i][j] = int(matrix[i][j] - '0')
			} else {

				if matrix[i][j] == '1' { // å½“ç­‰äº1çš„æ—¶å€™ï¼Œæ‰èƒ½ä½œä¸ºæ­£æ–¹å½¢çš„å³ä¸‹è§’ï¼Œæ±‚å–é•¿åº¦
					dp[i][j] = min(dp[i-1][j], min(dp[i][j-1], dp[i-1][j-1])) + 1
				}
			}
			// é¢˜ç›®è¦æ±‚æœ€å¤§æ­£æ–¹å½¢ï¼Œè¿™é‡Œè®°å½•æœ€å¤§è¾¹é•¿ length
			if dp[i][j] > length {
				length = dp[i][j]
			}
		}
	}
	// è¾¹é•¿*è¾¹é•¿ = æ­£æ–¹å½¢é¢ç§¯
	return length * length
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
```
## 34. åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªä½ç½®
ç»™ä½ ä¸€ä¸ªæŒ‰ç…§éé€’å‡é¡ºåºæ’åˆ—çš„æ•´æ•°æ•°ç»„ `nums`ï¼Œå’Œä¸€ä¸ªç›®æ ‡å€¼ `target`ã€‚è¯·ä½ æ‰¾å‡ºç»™å®šç›®æ ‡å€¼åœ¨æ•°ç»„ä¸­çš„å¼€å§‹ä½ç½®å’Œç»“æŸä½ç½®ã€‚
å¦‚æœæ•°ç»„ä¸­ä¸å­˜åœ¨ç›®æ ‡å€¼ `target`ï¼Œè¿”å› `[-1, -1]`ã€‚ä½ å¿…é¡»è®¾è®¡å¹¶å®ç°æ—¶é—´å¤æ‚åº¦ä¸º `O(log n)` çš„ç®—æ³•è§£å†³æ­¤é—®é¢˜ã€‚
æ€è·¯ï¼š
äºŒåˆ†æœç´¢çš„éš¾ç‚¹å°±åœ¨äºå¦‚ä½•æœç´¢å·¦ä¾§è¾¹ç•Œå’Œå³ä¾§è¾¹ç•Œï¼Œä»£ç çš„è¾¹ç•Œçš„æ§åˆ¶éå¸¸è€ƒéªŒä½ çš„å¾®æ“ï¼Œè¿™ä¹Ÿæ˜¯å¾ˆå¤šäººçŸ¥é“äºŒåˆ†æœç´¢åŸç†ä½†æ˜¯å¾ˆéš¾å†™å¯¹ä»£ç çš„åŸå› ã€‚å†™å¯¹äºŒåˆ†æœç´¢çš„å…³é”®åœ¨äºææ¸…æ¥šæœç´¢è¾¹ç•Œï¼Œåˆ°åº•åº”è¯¥å¾€å·¦ä¾§æ”¶æ•›è¿˜æ˜¯åº”è¯¥å¾€å³ä¾§æ”¶æ•›ï¼Ÿ
![b0a1462f-0ed0-4fdf-967c-a9bdc29bfc9a.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411709148-b0a1462f-0ed0-4fdf-967c-a9bdc29bfc9a.png)

![27236714-c195-4405-85db-ac887103b0e9.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411709316-27236714-c195-4405-85db-ac887103b0e9.png)


```go
func searchRange(nums []int, target int) []int {

    return []int{left_bound(nums,target),right_bound(nums,target)}
}

// æ±‚å·¦è¾¹ç•Œ
func left_bound(nums []int ,target int) int {

    left,right := 0,len(nums)-1
		// é—­åŒºé—´[left,right]
    for left <= right {
				// ä¸­é—´å€¼
        mid := left + (right-left)/2

        if nums[mid] == target { // ç›¸ç­‰çš„æ—¶å€™ï¼Œæ”¶ç¼©rightï¼›ã€å› ä¸ºæˆ‘ä»¬è¦æ±‚çš„æ˜¯å·¦è¾¹ç•Œã€‘
            right = mid -1
        } else if nums[mid] > target { // è¯´æ˜ targetå€¼ä½äºnums[mid]çš„å·¦ä¾§ï¼Œæ”¶ç¼©right
            right = mid -1
        } else if nums[mid] < target { // è¯´æ˜ target ä½äº nums[mid]çš„å³ä¾§ï¼Œæ”¶ç¼©left
            left = mid + 1
        }
    }
    
    // å½“æ‰€æœ‰çš„å€¼éƒ½æ¯”targetå°çš„æ—¶å€™ï¼Œleftä¼šè¶Šç•Œ
    // å½“æ‰€æœ‰çš„å€¼éƒ½æ¯”targetå¤§çš„æ—¶å€™ï¼Œleftæ­¤æ—¶æ˜¯ä¸ä¼šç§»åŠ¨ï¼Œæ‰€ä»¥è¦çœ‹ä¸‹leftæŒ‡å‘çš„å€¼æ˜¯å¦æ˜¯target
    if left >= len(nums) || nums[left] != target { // åšè¾¹ç•Œæ£€æµ‹
        return -1
    }
    return left
}

// æ±‚å³è¾¹ç•Œ
func right_bound(nums []int ,target int) int {

    left,right := 0,len(nums)-1

    for left <= right {
				// ä¸­é—´å€¼
        mid := left + (right-left)/2

        if nums[mid] == target { // æ±‚å³è¾¹ç•Œï¼Œå½“ç›¸ç­‰çš„æ—¶å€™ï¼Œæ”¶ç¼©å·¦è¾¹ç•Œ
            left = mid + 1
        } else if nums[mid] > target { // è¯´æ˜ targetå€¼ä½äºnums[mid]çš„å·¦ä¾§ï¼Œæ”¶ç¼©right
            right = mid - 1
        } else if nums[mid] < target { // è¯´æ˜ target ä½äº nums[mid]çš„å³ä¾§ï¼Œæ”¶ç¼©left
            left = mid + 1
        }
    }
    
    // å½“æ‰€æœ‰çš„æ•°éƒ½å¤§äºtargetçš„æ—¶å€™ï¼Œrightå°±ä¼šä¸€ç›´-1ï¼Œæœ€åä¼šè¶Šç•Œ
    // å½“æ‰€æœ‰çš„æ•°éƒ½å°äºtargetçš„æ—¶å€™ï¼Œrightä¿æŒä¸åŠ¨ï¼›æ‰€ä»¥è¦çœ‹ä¸‹rightæŒ‡å‘çš„å€¼æ˜¯å¦æ˜¯target
    if right < 0 || nums[right] != target { // åšè¾¹ç•Œæ£€æµ‹
        return -1
    }
    return right
}
```
## 394. å­—ç¬¦ä¸²è§£ç 
ç»™å®šä¸€ä¸ªç»è¿‡ç¼–ç çš„å­—ç¬¦ä¸²ï¼Œè¿”å›å®ƒè§£ç åçš„å­—ç¬¦ä¸²ã€‚
ç¼–ç è§„åˆ™ä¸º: `k[encoded_string]`ï¼Œè¡¨ç¤ºå…¶ä¸­æ–¹æ‹¬å·å†…éƒ¨çš„ `encoded_string` æ­£å¥½é‡å¤ `k` æ¬¡ã€‚æ³¨æ„ `k` ä¿è¯ä¸ºæ­£æ•´æ•°ã€‚ä½ å¯ä»¥è®¤ä¸ºè¾“å…¥å­—ç¬¦ä¸²æ€»æ˜¯æœ‰æ•ˆçš„ï¼›è¾“å…¥å­—ç¬¦ä¸²ä¸­æ²¡æœ‰é¢å¤–çš„ç©ºæ ¼ï¼Œä¸”è¾“å…¥çš„æ–¹æ‹¬å·æ€»æ˜¯ç¬¦åˆæ ¼å¼è¦æ±‚çš„ã€‚æ­¤å¤–ï¼Œä½ å¯ä»¥è®¤ä¸ºåŸå§‹æ•°æ®ä¸åŒ…å«æ•°å­—ï¼Œæ‰€æœ‰çš„æ•°å­—åªè¡¨ç¤ºé‡å¤çš„æ¬¡æ•° `k` ï¼Œä¾‹å¦‚ä¸ä¼šå‡ºç°åƒ `3a` æˆ– `2[4]` çš„è¾“å…¥ã€‚
æ€è·¯ï¼š
é¦–å…ˆè¦ç†è§£é¢˜ç›®çš„æ„æ€ï¼šæ¯”å¦‚`3[a]`è§£ç çš„ç»“æœä¸º`aaa`ã€‚ `3`è¡¨ç¤º `a`é‡å¤çš„æ¬¡æ•°ã€‚è¿™é¢˜å¦‚æœç¬¬ä¸€æ¬¡åšï¼Œè¿˜æ˜¯æŒºéš¾ï¼Œä¸€èˆ¬é‡åˆ°å­—ç¬¦ä¸²å¸¦æ‹¬å·çš„é—®é¢˜ï¼Œå°±è¦æƒ³åˆ°**æ ˆ**ã€‚åˆ©ç”¨æ ˆè®°å½•ä¸Šæ¬¡çš„è§£ç ç»“æœ
è¿™é‡Œä»¥ `a6[c]`ä¸ºä¾‹å­æ¼”ç¤ºä¸€ä¸‹ï¼š
![2a60b31e-d475-41ac-aec5-2e5fcb11e11c.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411709467-2a60b31e-d475-41ac-aec5-2e5fcb11e11c.png)


- ä»å·¦åˆ°å³éå†å­—ç¬¦ä¸²ï¼Œ `curStr`å’Œ`curNum` è®°å½•å½“å‰çš„å­—ç¬¦ä¸²å’Œæ•°å€¼
- é‡åˆ°`[ `å…¥æ ˆå½“å‰çš„`curStr`å’Œ`curNum`ï¼ˆç›®çš„æ˜¯ä¸ºäº†å­˜å‚¨ä¸Šæ¬¡çš„ç»“æœï¼‰åŒæ—¶æ¸…ç©ºå½“å‰`curStr`å’Œ`curNum`ï¼ˆç›®çš„æ˜¯ä¸ºäº†å¤ç”¨`curStr`å’Œ`curNum`ç”¨äº `[å¾…å¤„ç†å­—ç¬¦ä¸²]` ä¹‹é—´çš„ç¼–ç å­—ç¬¦ä¸²ï¼‰
- é‡åˆ°`] `å‡ºæ ˆ ï¼Œå‡ºæ ˆçš„å­—ç¬¦ä¸²ï¼ˆå‰ä¸€ä¸ªå­—ç¬¦ä¸²ï¼‰ + å‡ºæ ˆçš„`num`ï¼ˆè¡¨ç¤ºé‡å¤çš„æ¬¡æ•°ï¼‰å€¼å’Œå½“å‰çš„`curStr`ç»„åˆ = å½¢æˆæ–°çš„å­—ç¬¦ä¸²ï¼Œä¿å­˜åˆ° `curStr`ä¸­
```go
func decodeString(s string) string {
   
    curStr,strStack := "",[]string{} // curStr å½“å‰å­—ç¬¦ä¸²
    curNum,numStack := 0,[]int{} // curNum å½“å‰çš„æ•°å€¼

    for _,v := range s {
        if v >= '0' && v <= '9' { // å½“å‰çš„curNum
            curNum = curNum * 10 + int(v-'0')
        } else if v == '[' { // å…¥æ ˆï¼Œè®°å½•ä¸‹å½“å‰çš„curNumå’ŒcurStr
            strStack = append(strStack,curStr)
            numStack = append(numStack,curNum)
						// æ¸…ç©º
            curStr = ""
            curNum = 0

        } else if v == ']' { //å‡ºæ ˆï¼Œä¸Šæ¬¡è®°å½•ä¸‹æ¥çš„curNumå’ŒcurStr,ç›®çš„æ˜¯ä¸ºäº†å±•å¼€[]ä¹‹é—´çš„å­—ç¬¦ä¸²


            preStr := strStack[len(strStack)-1]
            preNum := numStack[len(numStack)-1] 

            // ä¾‹å¦‚ï¼ša2[c] , preStr = a   preNum = 2   curStr = cï¼Œç»“æœä¸º a+cc = acc
            curStr = preStr + strings.Repeat(curStr,preNum) // è¿™é‡Œå¯¹curStrè¿›è¡Œé‡å¤preNumæ¬¡
						// å‡ºæ ˆ
            strStack = strStack[:len(strStack)-1]
            numStack = numStack[:len(numStack)-1]

        }else { // å½“å‰çš„curStr
            curStr += string(v)
        }
    }
		// curSträ¸­è®°å½•è¿™æœ€ç»ˆçš„è§£ç ç»“æœ
    return curStr
}
```
## 240. æœç´¢äºŒç»´çŸ©é˜µII
ç¼–å†™ä¸€ä¸ªé«˜æ•ˆçš„ç®—æ³•æ¥æœç´¢ `m x n` çŸ©é˜µ `matrix` ä¸­çš„ä¸€ä¸ªç›®æ ‡å€¼ `target` ã€‚è¯¥çŸ©é˜µå…·æœ‰ä»¥ä¸‹ç‰¹æ€§ï¼š

- æ¯è¡Œçš„å…ƒç´ ä»å·¦åˆ°å³å‡åºæ’åˆ—ã€‚
- æ¯åˆ—çš„å…ƒç´ ä»ä¸Šåˆ°ä¸‹å‡åºæ’åˆ—ã€‚![a343de7c-872c-4b08-b626-86d8378912d3.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411709469-a343de7c-872c-4b08-b626-86d8378912d3.png)

æ€è·¯ï¼š
è¿™é“é¢˜è¯´ `matrix` ä»ä¸Šåˆ°ä¸‹é€’å¢ï¼Œä»å·¦åˆ°å³é€’å¢ï¼Œæ˜¾ç„¶å·¦ä¸Šè§’æ˜¯æœ€å°å…ƒç´ ï¼Œå³ä¸‹è§’æ˜¯æœ€å¤§å…ƒç´ ã€‚**æˆ‘ä»¬å¦‚æœæƒ³é«˜æ•ˆåœ¨ **`**matrix**`** ä¸­æœç´¢ä¸€ä¸ªå…ƒç´ ï¼Œè‚¯å®šéœ€è¦ä»æŸä¸ªè§’å¼€å§‹**ï¼Œæ¯”å¦‚è¯´ä»å·¦ä¸Šè§’å¼€å§‹ï¼Œç„¶åæ¯æ¬¡åªèƒ½å‘å³æˆ–å‘ä¸‹ç§»åŠ¨ï¼Œä¸è¦èµ°å›å¤´è·¯ã€‚
å¦‚æœçœŸä»å·¦ä¸Šè§’å¼€å§‹çš„è¯ï¼Œå°±ä¼šå‘ç°æ— è®ºå‘å³è¿˜æ˜¯å‘ä¸‹èµ°ï¼Œå…ƒç´ éƒ½ä¼šå¢åŠ ï¼Œé‚£ä¹ˆåˆ°åº•å‘å³è¿˜æ˜¯å‘ä¸‹ï¼Ÿä¸ç¡®å®š
ä½†å®é™…ä¸Šä¸ç”¨è¿™ä¹ˆéº»çƒ¦ï¼Œæˆ‘ä»¬ä¸è¦ä»å·¦ä¸Šè§’å¼€å§‹ï¼Œè€Œæ˜¯ä»å³ä¸Šè§’å¼€å§‹ï¼Œè§„å®šåªèƒ½å‘å·¦æˆ–å‘ä¸‹ç§»åŠ¨ã€‚
ä½ æ³¨æ„ï¼Œå¦‚æœå‘å·¦ç§»åŠ¨ï¼Œå…ƒç´ åœ¨å‡å°ï¼Œå¦‚æœå‘ä¸‹ç§»åŠ¨ï¼Œå…ƒç´ åœ¨å¢å¤§ï¼Œè¿™æ ·çš„è¯æˆ‘ä»¬å°±å¯ä»¥æ ¹æ®å½“å‰çš„å…ƒç´ å€¼å’Œ `target` çš„ç›¸å¯¹å¤§å°æ¥åˆ¤æ–­åº”è¯¥å¾€å“ªç§»åŠ¨ï¼Œä¸æ–­æ¥è¿‘ä»è€Œæ‰¾åˆ° `target` çš„ä½ç½®ã€‚
å½“ç„¶ï¼Œå¦‚æœä½ æƒ³ä»å·¦ä¸‹è§’å¼€å§‹ï¼Œè§„å®šåªèƒ½å‘å³æˆ–å‘ä¸Šç§»åŠ¨ä¹Ÿå¯ä»¥

```go
func searchMatrix(matrix [][]int, target int) bool {
    // ä¸€èˆ¬æ€è·¯ï¼šç›´æ¥éå†äºŒç»´çŸ©é˜µï¼›ä½†æ˜¯å¹¶æ²¡æœ‰å¾ˆå¥½çš„åˆ©ç”¨ï¼Œæ¯ä¸€è¡Œå’Œæ¯ä¸€åˆ—çš„å…ƒç´ éƒ½æ˜¯æœ‰åºçš„è¿™ä¸ªæ¡ä»¶ï¼›
    // è¿›é˜¶æ€è·¯ï¼šé‚£ä¹ˆå¦‚æœä»ã€å·¦ä¸Šè§’ã€‘å¼€å§‹æ¯”è¾ƒï¼Œå½“targetå¤§äºå·¦ä¸Šè§’çš„æ•°å€¼çš„æ—¶å€™ï¼Œæœ‰ä¸¤ä¸ªé€‰æ‹©ï¼Œã€å‘å³ã€‘æˆ–ã€å‘ä¸‹ã€‘,ä¸ç¡®å®šï¼Ÿï¼Ÿ
    // é‚£ä¹ˆå¦‚æœä»ã€å³ä¸Šè§’ã€‘å¼€å§‹æ¯”è¾ƒï¼Œå½“15 > targetçš„æ—¶å€™ï¼Œè¯´æ˜targetæ¯”è¾ƒå°ï¼Œé‚£ä¹ˆåªèƒ½å‘å·¦æŸ¥æ‰¾ï¼Œå› ä¸ºå¦‚æœå‘ä¸‹ï¼Œå…ƒç´ å€¼æ›´å¤§ï¼Œä¸ç¬¦åˆé¢˜æ„ï¼Œä¹Ÿå°±æ˜¯æ­¤æ—¶åªä¼šæœ‰ä¸€ç§é€‰æ‹©

    m := len(matrix)
    n := len(matrix[0])
		// å³ä¸Šè§’
    i := 0
    j := n-1

    for i < m && j >= 0 {
        if matrix[i][j] == target {
            return true
        } else if matrix[i][j] > target { // å‘å·¦ç§»åŠ¨,æ‰¾æ›´å°å€¼
            j--
        } else if matrix[i][j] < target { // å‘ä¸‹ç§»åŠ¨ï¼Œæ‰¾æ›´å¤§å€¼
            i++
        }
    }

    return false
}
```
## 64.æœ€å°è·¯å¾„å’Œ
ç»™å®šä¸€ä¸ªåŒ…å«éè´Ÿæ•´æ•°çš„ `m x n` ç½‘æ ¼ `grid` ï¼Œè¯·æ‰¾å‡ºä¸€æ¡ä»å·¦ä¸Šè§’åˆ°å³ä¸‹è§’çš„è·¯å¾„ï¼Œä½¿å¾—è·¯å¾„ä¸Šçš„æ•°å­—æ€»å’Œä¸ºæœ€å°ã€‚
**è¯´æ˜ï¼š**æ¯æ¬¡åªèƒ½å‘ä¸‹æˆ–è€…å‘å³ç§»åŠ¨ä¸€æ­¥ã€‚
æ€è·¯ï¼š
ä¸€èˆ¬æ¥è¯´ï¼Œè®©ä½ åœ¨äºŒç»´çŸ©é˜µä¸­æ±‚æœ€ä¼˜åŒ–é—®é¢˜ï¼ˆæœ€å¤§å€¼æˆ–è€…æœ€å°å€¼ï¼‰ï¼Œå°±è¦è€ƒè™‘åŠ¨æ€è§„åˆ’ã€‚å…ˆå®šä¹‰ `dp`æ•°ç»„ï¼Œç„¶åå¯»æ‰¾ç›¸é‚»`dp[i] dp[i-1]`ä¹‹é—´çš„å…³ç³»ã€‚

- `dp`æ•°ç»„å®šä¹‰ï¼šä»`[0,0]`åˆ° `[i,j]`çš„æœ€å°è·¯å¾„å’Œä¸º `dp[i][j]`
- é€’æ¨å…³ç³»ï¼šå› ä¸ºé¢˜ç›®è¯´ï¼šæ¯æ¬¡åªèƒ½å‘ä¸‹æˆ–è€…å‘å³ç§»åŠ¨ä¸€æ­¥ã€‚é‚£ä¹ˆåˆ°è¾¾ `[i,j]`ä½ç½®æœ‰ä¸¤ç§é€‰æ‹©
ä»`[i-1,j]`å‘ä¸‹ç§»åŠ¨ä¸€æ­¥
ä»`[i,j-1]`å‘å³ç§»åŠ¨ä¸€æ­¥
![87476989-7006-49c1-9ffb-8763a21b0616.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411709704-87476989-7006-49c1-9ffb-8763a21b0616.png)

`dp[i][j-1]`è¡¨ç¤º ä»`[0,0]`åˆ° `[i,j-1]`çš„æœ€å°è·¯å¾„å’Œ
`dp[i-1][j]`è¡¨ç¤º ä»`[0,0]`åˆ° `[i-1,j]`çš„æœ€å°è·¯å¾„å’Œ
å–ä¸¤ä¸ªä¸­çš„`min`æœ€å°å€¼ `+ grid[i][j]` å³ä¸ºä»`[0,0]`åˆ° `[i,j]`çš„æœ€å°è·¯å¾„å’Œ

```go
func minPathSum(grid [][]int) int {
  
    m := len(grid)
    n := len(grid[0])
		// å®šä¹‰ dp æ•°ç»„
    dp := make([][]int,m)
    for k := range dp {
        dp[k] = make([]int,n)
    }
   
    for i := 0;i < m;i++ {
        for j := 0;j < n;j++ {
            if i == 0 && j >= 1 { //base case ç¬¬ä¸€è¡Œï¼šåªèƒ½ä»å·¦å¾€å³ï¼Œæ‰€ä»¥ç¬¬ä¸€è¡Œå°±æ˜¯ç´¯åŠ 
                dp[i][j] = dp[i][j-1] + grid[i][j]
            } else if j == 0 && i >= 1 { // base case ç¬¬ä¸€åˆ—ï¼šåªèƒ½ä»ä¸Šå¾€ä¸‹ï¼Œæ‰€ä»¥ç¬¬ä¸€åˆ—å°±æ˜¯ç´¯åŠ 
            1     dp[i][j] = dp[i-1][j] + grid[i][j]
            } else if i == 0 && j == 0 {//base case å·¦ä¸Šè§’ç¬¬ä¸€ä¸ªå…ƒç´ 
                dp[0][0] = grid[0][0]
            } else { // ä»i=1 && j=1 å¼€å§‹ç¬¦åˆé€’æ¨å…¬å¼
                dp[i][j] = min(dp[i-1][j],dp[i][j-1])+ grid[i][j]
            }
        }
    }
  	// æœ€åè¿”å›,ä» [0,0] åˆ° [m-1,n-1] çš„æœ€å°è·¯å¾„å’Œ
    return dp[m-1][n-1]
}

func min(a,b int)int{
    if a < b {
        return a
    }
    return b
}
```
## 113. è·¯å¾„æ€»å’ŒII
ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` å’Œä¸€ä¸ªæ•´æ•°ç›®æ ‡å’Œ `targetSum` ï¼Œæ‰¾å‡ºæ‰€æœ‰ **ä»æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹** è·¯å¾„æ€»å’Œç­‰äºç»™å®šç›®æ ‡å’Œçš„è·¯å¾„ã€‚
**å¶å­èŠ‚ç‚¹** æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚
æ€è·¯ï¼š
äºŒå‰æ ‘é¢˜å‹ï¼Œå°±æ˜¯é€’å½’éå†é¢˜å‹ã€‚åªæ˜¯åœ¨éå†çš„è¿‡ç¨‹çš„ä¸­è¦å¯¹æ•°æ®è¿›è¡Œç›¸å…³å¤„ç†ï¼Œå¤„ç†çš„ä½ç½®æœ‰è®²ç©¶ï¼Œè¦ä¹ˆå‰åºä½ç½®ï¼Œè¦ä¹ˆä¸­åºä½ç½®ï¼Œè¦ä¹ˆååºä½ç½®ã€‚

```go
var result [][]int
func pathSum(root *TreeNode, targetSum int) [][]int {
		// æœ€ç»ˆç»“æœå­˜å‚¨
    result = [][]int{}
  	// è®°å½•è·¯å¾„
    trace := []int{}
  	// äºŒå‰æ ‘éå†
    traverse(root,trace,targetSum,0)
    return result
}

// traverseå‡½æ•°å®šä¹‰ï¼š éå† root æ ‘ï¼Œæ‰¾å‡ºç›®æ ‡è·¯å¾„å’Œ
func traverse( root *TreeNode, trace []int,targetSum int,sum int) {
    if root == nil {
        return
    }
		// å‰åºä½ç½®ï¼Œè®°å½•è·¯å¾„å’Œ
    trace = append(trace,root.Val) 
    sum += root.Val

    if root.Left == nil && root.Right == nil {//è¡¨ç¤ºrootæ˜¯å¶å­èŠ‚ç‚¹ï¼ˆä¸å­˜åœ¨å·¦å³å­æ ‘ï¼‰
        if sum == targetSum { // è·¯å¾„å’Œsum ç­‰äº targetSumï¼Œæ‰¾åˆ°ä¸€ä¸ªç»“æœ
            temp := make([]int,len(trace))
            copy(temp,trace)
            result = append(result,temp)
        }
        return
    }
		// ç»§ç»­å·¦æ ‘éå†
    traverse(root.Left,trace,targetSum,sum)
  	// ç»§ç»­å³æ ‘éå†
    traverse(root.Right,trace,targetSum,sum)
}
```
## 14. æœ€é•¿å…¬å…±å‰ç¼€
ç¼–å†™ä¸€ä¸ªå‡½æ•°æ¥æŸ¥æ‰¾å­—ç¬¦ä¸²æ•°ç»„ä¸­çš„æœ€é•¿å…¬å…±å‰ç¼€ã€‚å¦‚æœä¸å­˜åœ¨å…¬å…±å‰ç¼€ï¼Œè¿”å›ç©ºå­—ç¬¦ä¸² `""`ã€‚
æ€è·¯ï¼š
è¿™ä¸ªé¢˜æ²¡ä»€ä¹ˆéš¾åº¦ï¼Œä½ æŠŠå­—ç¬¦ä¸²åˆ—è¡¨çœ‹æˆä¸€ä¸ªäºŒç»´æ•°ç»„ï¼Œç„¶åç”¨ä¸€ä¸ªåµŒå¥— `for` å¾ªç¯è®¡ç®—è¿™ä¸ªäºŒç»´æ•°ç»„å‰é¢æœ‰å¤šå°‘åˆ—çš„å…ƒç´ å®Œå…¨ç›¸åŒå³å¯ã€‚

```go
func longestCommonPrefix(strs []string) string {
  	
  	m,n := len(strs),len(strs[0]) // mè¡Œ nåˆ—	( æ‹¿ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²ä½œä¸ºå¯¹æ¯”æ ‡å‡†ï¼ˆå…¶ä»–çš„å­—ç¬¦ä¸²éƒ½å’Œä»–æ¯”è¾ƒï¼‰)
		
    for col := 0; col < n; col++ { // colåˆ—
        for row := 1;row < m;row++ { // rowè¡Œ
            if col >= len(strs[row]) || strs[row][col] != strs[0][col] { // colçš„ç´¢å¼•ä½ç½®ï¼Œä¸èƒ½è¶…è¿‡ï¼Œæ¯ä¸ªå­—ç¬¦ä¸²çš„é•¿åº¦
                //è¯´æ˜colä½ç½®ï¼Œå°±æ˜¯å‡ºç°ä¸åŒçš„ä½ç½®ï¼Œä¸èƒ½åŒ…æ‹¬
                return string(strs[0][:col])
            }
        }
    }
		// ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²å°±æ˜¯æœ€é•¿çš„å…¬å…±å‰ç¼€
    return strs[0]
}
```
## 128. æœ€é•¿è¿ç»­åºåˆ—
ç»™å®šä¸€ä¸ªæœªæ’åºçš„æ•´æ•°æ•°ç»„ `nums` ï¼Œæ‰¾å‡ºæ•°å­—è¿ç»­çš„æœ€é•¿åºåˆ—ï¼ˆä¸è¦æ±‚åºåˆ—å…ƒç´ åœ¨åŸæ•°ç»„ä¸­è¿ç»­ï¼‰çš„é•¿åº¦ã€‚è¯·ä½ è®¾è®¡å¹¶å®ç°æ—¶é—´å¤æ‚åº¦ä¸º `O(n)` çš„ç®—æ³•è§£å†³æ­¤é—®é¢˜ã€‚
æ€è·¯ï¼š
è¿™é“é¢˜æœ€ç›´æ¥çš„æƒ³æ³•å°±æ˜¯æ’åºï¼Œæ’åºä¹‹åè¿ç»­çš„åºåˆ—å°±å¾ˆå®¹æ˜“æ‰¾åˆ°äº†ã€‚ä¸è¿‡æ’åºçš„æ—¶é—´å¤æ‚åº¦æ˜¯ `O(NlogN)`ï¼Œè€Œé¢˜ç›®è¦æ±‚æˆ‘ä»¬æ—¶é—´å¤æ‚åº¦ä¸º `O(N)`ï¼Œè¿™å°±å¾—å¦æƒ³åŠæ³•äº†ã€‚
æƒ³æ‰¾è¿ç»­åºåˆ—ï¼Œé¦–å…ˆè¦æ‰¾åˆ°è¿™ä¸ªè¿ç»­åºåˆ—çš„å¼€å¤´å…ƒç´ ï¼Œç„¶åé€’å¢ï¼Œçœ‹çœ‹ä¹‹åæœ‰å¤šå°‘ä¸ªå…ƒç´ è¿˜åœ¨ `nums` ä¸­ï¼Œå³å¯å¾—åˆ°æœ€é•¿è¿ç»­åºåˆ—çš„é•¿åº¦äº†ã€‚å¯ä»¥ç”¨ç©ºé—´æ¢æ—¶é—´çš„æ€è·¯ï¼ŒæŠŠæ•°ç»„å…ƒç´ æ”¾åˆ°å“ˆå¸Œé›†åˆé‡Œé¢ï¼Œç„¶åå»å¯»æ‰¾è¿ç»­åºåˆ—çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œå³å¯åœ¨ `O(N)` æ—¶é—´æ‰¾åˆ°ç­”æ¡ˆã€‚
è¿™é‡Œæœ‰ç–‘é—®ï¼Œä¸ºä»€ä¹ˆè¦æ‰¾è¿ç»­åºåˆ—**å¼€å¤´çš„å…ƒç´ **ï¼Œç„¶åè®°å½•é•¿åº¦ï¼Ÿ
æ¯”æ–¹è¯´ `nums = [8,4,9,1,3,2]`ï¼Œæˆ‘ä»¬å…ˆæ‰¾åˆ° 1ï¼Œç„¶åé€’å¢ï¼Œæ‰¾åˆ°äº† 2, 3, 4ï¼Œè¿™å°±æ˜¯ä¸€ä¸ªé•¿åº¦ä¸º 4 çš„åºåˆ—ã€‚
å¦‚æœï¼Œå…ˆæ‰¾åˆ°2ï¼Œç„¶åé€’å¢ï¼Œæ‰¾åˆ° 3,4 ï¼Œè¿™æ˜¯ä¸€ä¸ªé•¿åº¦ä¸º3çš„åºåˆ—ã€‚è‚¯å®šæ˜¯æ²¡æœ‰ä¸Šé¢çš„ä»1 å¼€å§‹çš„é•¿åº¦é•¿çš„ï¼Œä¹Ÿå°±æ˜¯å¹²äº†æ— æ•ˆçš„é•¿åº¦è®¡æ•°ã€‚æ‰€ä»¥ï¼Œè¦æ‰¾å¼€å¤´çš„å…ƒç´ ï¼Œå†æ¥è®¡æ•°ï¼Œæ‰æœ‰å®é™…æ„ä¹‰ã€‚
å†æ¯”å¦‚ï¼Œåˆæ‰¾åˆ° 8ï¼Œå¾€ä¸Šé€’å¢æ‰¾åˆ°äº† 9ï¼Œè¿™æ˜¯ä¸€ä¸ªé•¿åº¦ä¸º 2 çš„åºåˆ—ã€‚ 8 å°±æ˜¯è¿ç»­åºåˆ—å¼€å¤´çš„å…ƒç´ ï¼ˆå› ä¸ºæ²¡æœ‰æ¯”8æ›´å°çš„æ•°å­—7ï¼‰ï¼Œè¿™æ˜¯ä¸€ä¸ªæœ‰æ„çš„ç»“æœã€‚

```go
func longestConsecutive(nums []int) int {

    //1. å…ˆéå†numsæ•°ç»„æ”¾å…¥åˆ°mapä¸­
    m := make(map[int]struct{})
    for i :=0;i < len(nums);i++ {
        m[nums[i]] = struct{}{}
    }

    result := 0
    //2.éå†mapï¼Œåˆ¤æ–­å…ƒç´ æ˜¯å¦ã€æ•°å­—è¿ç»­ã€‘çš„å¼€å¤´å…ƒç´ ï¼Œä¸æ˜¯åˆ™è·³è¿‡ã€‚æ˜¯çš„è¯ï¼Œå°±å¯¹å…ƒç´ +1ï¼Œçœ‹è¿ç»­åºåˆ—çš„ä¸‹ä¸€ä¸ªå…ƒç´ åœ¨mapä¸­æ˜¯å¦å­˜åœ¨ï¼Œè®°å½•åºåˆ—é•¿åº¦ï¼›

    for k,_ := range m {
      
      	// é€šè¿‡ k-1çš„æ–¹å¼ï¼Œåˆ¤æ–­æœ‰æ²¡æœ‰å‰ç½®å…ƒç´ ï¼ˆä¹Ÿå°±æ˜¯kæ˜¯ä¸æ˜¯ã€å¼€å¤´å…ƒç´ ã€‘ï¼‰
      	// æ¯”å¦‚[100,4,200,1,3,2],å‡å¦‚k=3,k-1=2,æœ‰å‰ç½®çš„å…ƒç´ 2ï¼Œè¯´æ˜k=3ä¸æ˜¯æ•°å­—è¿ç»­çš„å¼€å¤´å…ƒç´ ï¼Œè·³è¿‡
        if _,ok := m[k-1];!ok { //!ok è¯´æ˜æ˜¯ç¬¬ä¸€ä¸ª
          
            //è¯´æ˜kæ˜¯æ•°å­—è¿ç»­çš„ç¬¬ä¸€ä¸ªå…ƒç´ 
            maxLen := 1
            
            for {
                k++ //åˆ¤æ–­è¿ç»­çš„ä¸‹ä¸€ä¸ªå…ƒç´ æ˜¯å¦å­˜åœ¨
                if _,ok := m[k];!ok {// ä¸å­˜åœ¨
                    break
                }else { //å­˜åœ¨
                    maxLen++
                }
            }
						// è®°å½•æœ€å¤§é•¿åº¦
            result = max(result,maxLen)
        }
    }
		// è¿”å›ç»“æœ
    return result
}

func max(a,b int)int{
    if a > b{
        return a
    }
    return b
}
```
## 112. è·¯å¾„æ€»å’Œ
ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` å’Œä¸€ä¸ªè¡¨ç¤ºç›®æ ‡å’Œçš„æ•´æ•° `targetSum` ã€‚åˆ¤æ–­è¯¥æ ‘ä¸­æ˜¯å¦å­˜åœ¨ **æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹** çš„è·¯å¾„ï¼Œè¿™æ¡è·¯å¾„ä¸Šæ‰€æœ‰èŠ‚ç‚¹å€¼ç›¸åŠ ç­‰äºç›®æ ‡å’Œ `targetSum` ã€‚å¦‚æœå­˜åœ¨ï¼Œè¿”å› `true` ï¼›å¦åˆ™ï¼Œè¿”å› `false` ã€‚
**å¶å­èŠ‚ç‚¹** æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚
æ€è·¯ï¼š
è¿™é¢˜å’Œä¸Šé¢çš„ **113. è·¯å¾„æ€»å’ŒII**ç±»ä¼¼çš„ï¼Œåªæ˜¯æœ¬é¢˜åªéœ€è¦æ‰¾åˆ°ä¸€ä¸ªæ»¡è¶³çš„è·¯å¾„å³å¯ï¼ˆè€Œä¸”ä¹Ÿä¸ç”¨è®°å½•ä¸‹æ¥è·¯å¾„å€¼ï¼‰

```go
func hasPathSum(root *TreeNode, targetSum int) bool {
    return PathSum(root,targetSum,0)
}

// PathSumå‡½æ•°å®šä¹‰ï¼š rootæ ‘æ˜¯å¦å­˜åœ¨ä»æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„å’Œ ç­‰äº targetSum
func PathSum(root *TreeNode,targetSum int,sum int) bool {
  	// root ä¸ºnilï¼Œä¸å­˜åœ¨
    if root == nil {
        return false
    }
  	// å‰åºä½ç½®ï¼Œç´¯åŠ è·¯å¾„å’Œ
    sum += root.Val
    if root.Left == nil && root.Right == nil { // è¯´æ˜ root æ˜¯å¶å­èŠ‚ç‚¹
        
        if sum == targetSum { // æ‰¾åˆ°è·¯å¾„å’Œ
            return true
        }
        return false
    }
		// åˆ¤æ–­å·¦å­æ ‘ æˆ–è€… å³å­æ ‘ æ˜¯æœ‰æœ‰æ»¡è¶³çš„è·¯å¾„å’Œï¼ˆæ³¨æ„ï¼šæ˜¯æˆ–çš„å…³ç³»ï¼Œå¹¶ä¸éœ€è¦åŒæ—¶æ»¡è¶³ï¼‰
    return PathSum(root.Left,targetSum,sum) || PathSum(root.Right,targetSum,sum)
}
```
## 662. äºŒå‰æ ‘æœ€å¤§å®½åº¦
ç»™ä½ ä¸€æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œè¿”å›æ ‘çš„ **æœ€å¤§å®½åº¦** ã€‚æ ‘çš„ **æœ€å¤§å®½åº¦** æ˜¯æ‰€æœ‰å±‚ä¸­æœ€å¤§çš„ **å®½åº¦** ã€‚
æ¯ä¸€å±‚çš„ **å®½åº¦** è¢«å®šä¹‰ä¸ºè¯¥å±‚æœ€å·¦å’Œæœ€å³çš„éç©ºèŠ‚ç‚¹ï¼ˆå³ï¼Œä¸¤ä¸ªç«¯ç‚¹ï¼‰ä¹‹é—´çš„é•¿åº¦ã€‚å°†è¿™ä¸ªäºŒå‰æ ‘è§†ä½œä¸æ»¡äºŒå‰æ ‘ç»“æ„ç›¸åŒï¼Œä¸¤ç«¯ç‚¹é—´ä¼šå‡ºç°ä¸€äº›å»¶ä¼¸åˆ°è¿™ä¸€å±‚çš„ `null` èŠ‚ç‚¹ï¼Œè¿™äº› `null` èŠ‚ç‚¹ä¹Ÿè®¡å…¥é•¿åº¦ã€‚
é¢˜ç›®æ•°æ®ä¿è¯ç­”æ¡ˆå°†ä¼šåœ¨ **32 ä½** å¸¦ç¬¦å·æ•´æ•°èŒƒå›´å†…ã€‚
æ€è·¯ï¼š
è¿™é¢˜æ˜¯å±‚åºéå†çš„ä¸€ä¸ªåº”ç”¨ã€‚æˆ‘ä»¬éœ€è¦ç»™èŠ‚ç‚¹ç¼–å·ï¼Œæ¯ä¸€å±‚çš„æœ€å·¦è¾¹èŠ‚ç‚¹å’Œæœ€å³è¾¹èŠ‚ç‚¹ç¼–å·çš„ã€å·®å€¼ã€‘ï¼Œå³ä¸ºè¯¥å±‚çš„å®½åº¦ã€‚é¢˜ç›®è¦æ±‚æœ€å¤§å®½åº¦ï¼Œé‚£ç”¨ä¸€ä¸ªå˜é‡`result`è®°å½•ä¸‹æ¥æœ€å€¼å³å¯ã€‚

```go
func widthOfBinaryTree(root *TreeNode) int {
    ///ï¼ï¼ï¼å±‚åºéå†ï¼šæ¯ä¸€å±‚çš„æœ€å³è¾¹èŠ‚ç‚¹ç¼–å· - æœ€å·¦è¾¹èŠ‚ç‚¹çš„ç¼–å· + 1 ï¼Œè¡¨ç¤ºå½“å‰å±‚çš„å®½åº¦
    if root == nil {
        return 0
    }
    type pair struct { //ç”¨æ¥è®°å½•èŠ‚ç‚¹å’ŒèŠ‚ç‚¹ç¼–å·
        node *TreeNode
        uid int
    }
  	
    q := []*pair{}
  	// ä»æ ¹èŠ‚ç‚¹rootå¼€å§‹ï¼Œç¼–å·ä¸º 1
    q = append(q,&pair{root,1})
    result := 0
    leftId, rightId := 0,0 //æ¯ä¸€å±‚çš„æœ€å·¦å’Œæœ€å³èŠ‚ç‚¹ç¼–å·
    for len(q) != 0 {
        size := len(q)

        for i := 0;i < size;i++ {
            if i == 0 {
                leftId = q[i].uid //æœ€å·¦è¾¹èŠ‚ç‚¹
            }
            if i == size-1 { //æœ€å³è¾¹èŠ‚ç‚¹
                rightId = q[i].uid
            }

            //åˆ¤æ–­å·¦èŠ‚ç‚¹æ˜¯å¦å­˜åœ¨
            if q[i].node.Left != nil {
                q = append(q,&pair{q[i].node.Left,2 * q[i].uid}) //ç¼–å·ä¸º 2*uid
            }
            //åˆ¤æ–­å³èŠ‚ç‚¹æ˜¯å¦å­˜åœ¨
            if q[i].node.Right != nil {
                q = append(q,&pair{q[i].node.Right,2 * q[i].uid + 1}) //ç¼–å·ä¸º 2*uid+1
            }
        }
        ///å»æ‰qå¤´éƒ¨çš„sizeä¸ªå…ƒç´ 
        q = q[size:]
				// rightId-leftId+1 è®¡ç®—æœ¬å±‚å®½åº¦ï¼Œ resultè®°å½•æ‰€æœ‰å±‚çš„æœ€å¤§å€¼
        result = max(result,rightId-leftId+1)
    }
    return result
}

func max ( a, b int) int{
    if a > b {
        return a
    }
    return b
}
```
## 695. å²›å±¿çš„æœ€å¤§é¢ç§¯
ç»™ä½ ä¸€ä¸ªå¤§å°ä¸º `m x n` çš„äºŒè¿›åˆ¶çŸ©é˜µ `grid` ã€‚
**å²›å±¿** æ˜¯ç”±ä¸€äº›ç›¸é‚»çš„ `1` (ä»£è¡¨åœŸåœ°) æ„æˆçš„ç»„åˆï¼Œè¿™é‡Œçš„ã€Œç›¸é‚»ã€è¦æ±‚ä¸¤ä¸ª `1` å¿…é¡»åœ¨ **æ°´å¹³æˆ–è€…ç«–ç›´çš„å››ä¸ªæ–¹å‘ä¸Š** ç›¸é‚»ã€‚ä½ å¯ä»¥å‡è®¾ `grid` çš„å››ä¸ªè¾¹ç¼˜éƒ½è¢« `0`ï¼ˆä»£è¡¨æ°´ï¼‰åŒ…å›´ç€ã€‚
å²›å±¿çš„é¢ç§¯æ˜¯å²›ä¸Šå€¼ä¸º `1` çš„å•å…ƒæ ¼çš„æ•°ç›®ã€‚
è®¡ç®—å¹¶è¿”å› `grid` ä¸­æœ€å¤§çš„å²›å±¿é¢ç§¯ã€‚å¦‚æœæ²¡æœ‰å²›å±¿ï¼Œåˆ™è¿”å›é¢ç§¯ä¸º `0` ã€‚
æ€è·¯ï¼š
è¿™é¢˜å’Œ **200.å²›å±¿æ•°é‡**ï¼Œç±»ä¼¼çš„é¢˜ç›®ã€‚è®¡ç®—å²›å±¿é¢ç§¯ï¼Œå…¶å®å°±æ˜¯åœ¨è®¡ç®—ç›¸é‚»çš„`1`çš„ä¸ªæ•°ã€‚é‡‡ç”¨æ·±åº¦éå†`DFS`çš„æ–¹å¼æ·¹æ²¡å²›å±¿çš„åŒæ—¶ï¼Œè¿˜åº”è¯¥æƒ³åŠæ³•è®°å½•è¿™ä¸ªå²›å±¿çš„é¢ç§¯ã€‚
è¿™é‡Œé€šè¿‡å½¢å‚ `val *int`è®°å½•é¢ç§¯

```go
func maxAreaOfIsland(grid [][]int) int {
	m, n := len(grid), len(grid[0])

	maxVal := 0
	for i := 0; i < m; i++ {
		for j := 0; j < n; j++ {
			if grid[i][j] == 1 { // æ‰¾åˆ°é™†åœ°
				val := 0 // ç´¯è®¡é™†åœ°çš„é¢ç§¯
				dfs(grid, i, j, &val) 
       	// è®°å½•æœ€å¤§å€¼
				maxVal = max(maxVal, val)
			}
		}
	}
	return maxVal
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func dfs(grid [][]int, i, j int, val *int) {
	m := len(grid)
	n := len(grid[0])

	if i < 0 || i >= m || j < 0 || j >= n { //è¶Šç•Œ
		return
	}
	
	if grid[i][j] == 0 { // å½“å‰æ˜¯æ°´é¢
		return
	}
	// æ‰§è¡Œåˆ°è¿™é‡Œï¼Œè¯´æ˜æ˜¯é™†åœ°
	(*val)++ //ç´¯è®¡é¢ç§¯
	grid[i][j] = 0	// æ·¹æ²¡é™†åœ°ï¼ˆé¿å…äº†é‡å¤è®¡ç®—ï¼‰
	
 	// å‘å‘¨å›´æ‰©æ•£ï¼ˆçœ‹ä¸‹å‘¨å›´è¿˜æœ‰æ²¡æœ‰é™†åœ°ï¼‰
	dfs(grid, i+1, j, val)
	dfs(grid, i-1, j, val)
	dfs(grid, i, j+1, val)
	dfs(grid, i, j-1, val)
}
```
## 234. å›æ–‡é“¾è¡¨
ç»™ä½ ä¸€ä¸ªå•é“¾è¡¨çš„å¤´èŠ‚ç‚¹ `head` ï¼Œè¯·ä½ åˆ¤æ–­è¯¥é“¾è¡¨æ˜¯å¦ä¸ºå›æ–‡é“¾è¡¨ã€‚å¦‚æœæ˜¯ï¼Œè¿”å› `true` ï¼›å¦åˆ™ï¼Œè¿”å› `false` ã€‚
æ€è·¯ï¼š
![692ee116-c81e-4d23-aa62-4262dd8dd6e0.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411709853-692ee116-c81e-4d23-aa62-4262dd8dd6e0.png)

å¦‚æœ `fast != nil`ï¼Œè¯´æ˜èŠ‚ç‚¹ä¸ªæ•°ä¸º**å¥‡æ•°**ï¼Œ`slow`è¿˜éœ€è¦å†ç§»åŠ¨ä¸€æ­¥
![df224229-40f7-4810-8271-35764d5a10b4.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411709884-df224229-40f7-4810-8271-35764d5a10b4.png)

ä» `slow` å¼€å§‹åè½¬åé¢çš„é“¾è¡¨ï¼Œç°åœ¨å°±å¯ä»¥å¼€å§‹æ¯”è¾ƒå›æ–‡ä¸²äº†ï¼š
![3898ee38-f795-4f1d-872c-0c0242953214.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411710036-3898ee38-f795-4f1d-872c-0c0242953214.png)


```go
func isPalindrome(head *ListNode) bool {
    //1.å…ˆæ‰¾åˆ°é“¾è¡¨çš„ä¸­ç‚¹
   
    fast,slow := head,head

    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
    }

    if fast != nil { //è¯´æ˜èŠ‚ç‚¹æ•°ä¸ºå¥‡æ•°ä¸ª
        slow = slow.Next
    }
		
  	// left é“¾è¡¨
    left := head
  	// right é“¾è¡¨
    right := reverse(slow)

    for right != nil {
        if right.Val != left.Val { // å€¼ä¸ç›¸åŒï¼Œä¸æ˜¯å›æ–‡
            return false
        }
        right = right.Next
        left = left.Next
    }
    return true
}

//ç¿»è½¬é“¾è¡¨ï¼ˆé€’å½’æ–¹å¼ï¼‰ reverseå‡½æ•°å®šä¹‰ï¼šåè½¬rooté“¾è¡¨ï¼Œå¹¶è¿”å›åè½¬åçš„å¤´èŠ‚ç‚¹
func reverse(root *ListNode) *ListNode {
    if root == nil || root.Next == nil {
        return root
    }
  
    head := reverse(root.Next) 
    root.Next.Next = root 
    root.Next = nil
    return head
}

//ç¿»è½¬é“¾è¡¨ï¼ˆè¿­ä»£æ–¹å¼ï¼‰
func reverse1(root *ListNode) *ListNode {
    cur := root
    var pre *ListNode = nil
    for cur != nil {
        temp := cur.Next //è®°å½•ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
        cur.Next = pre //æŒ‡å‘pre
        pre = cur //å½“å‰curå˜æˆäº†preä¸€ä¸ªäº†
        cur = temp //ç»§ç»­ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
    }
    return pre
}
```
## 122. ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºII
ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `prices` ï¼Œå…¶ä¸­ `prices[i]` è¡¨ç¤ºæŸæ”¯è‚¡ç¥¨ç¬¬ `i` å¤©çš„ä»·æ ¼ã€‚
åœ¨æ¯ä¸€å¤©ï¼Œä½ å¯ä»¥å†³å®šæ˜¯å¦è´­ä¹°å’Œ/æˆ–å‡ºå”®è‚¡ç¥¨ã€‚ä½ åœ¨ä»»ä½•æ—¶å€™ **æœ€å¤š** åªèƒ½æŒæœ‰ **ä¸€è‚¡** è‚¡ç¥¨ã€‚ä½ ä¹Ÿå¯ä»¥å…ˆè´­ä¹°ï¼Œç„¶ååœ¨ **åŒä¸€å¤©** å‡ºå”®ã€‚
è¿”å› *ä½ èƒ½è·å¾—çš„ ****æœ€å¤§**** åˆ©æ¶¦* ã€‚
æ€è·¯ï¼š
ä¹°å–è‚¡ç¥¨ç±»çš„é¢˜ç›®æœ‰ä¸€å¥—**é€šç”¨çš„è§£é¢˜æ–¹æ¡ˆ**ï¼š

- `dp`æ•°ç»„å®šä¹‰ï¼š> `dp[i][k][0 or 1]`
`0 <= i <= n - 1, 1 <= k <= K`
n ä¸ºå¤©æ•°ï¼Œå¤§ K ä¸ºå®Œæˆäº¤æ˜“æ•°çš„ä¸Šé™ï¼Œ0 å’Œ 1 ä»£è¡¨æ˜¯å¦æŒæœ‰è‚¡ç¥¨

æ‰€ä»¥ï¼Œ`dp[i][k][0 or 1]` çš„å«ä¹‰å°±æ˜¯ï¼šåœ¨ä» `0`åˆ° `i`å¤©ï¼Œå®Œæˆäº†`k`ç¬”äº¤æ˜“ï¼Œä¸æŒæœ‰`0` or æŒæœ‰ `1`è‚¡ç¥¨ï¼Œèƒ½è·å–çš„æœ€å¤§åˆ©æ¶¦

- `dp`çš„é€’æ¨å…³ç³»å®šä¹‰ï¼š
```go
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
//dp[i][k][0] è¡¨ç¤º ä» 0 åˆ° ç¬¬iå¤©ï¼Œå®Œæˆkç¬”äº¤æ˜“ï¼Œä¸æŒæœ‰è‚¡ç¥¨ï¼Œèƒ½è·å–çš„æœ€å¤§åˆ©æ¶¦
åˆ†æˆä¸¤ç§æƒ…å†µï¼š
// dp[i-1][k][0] 								è¡¨ç¤º ä» 0 åˆ°i-1å¤©ï¼ˆä¹Ÿå°±æ˜¯å‰ä¸€å¤©ï¼‰ï¼Œä¹Ÿæ²¡æœ‰æŒæœ‰è‚¡ç¥¨
// dp[i-1][k][1] + prices[i]  	è¡¨ç¤º ä» 0 åˆ°i-1å¤©ï¼ˆä¹Ÿå°±æ˜¯å‰ä¸€å¤©ï¼‰ï¼ŒæŒæœ‰äº†è‚¡ç¥¨ï¼Œä½†æ˜¯ä»Šå¤©é€‰æ‹©å–å‡ºï¼Œé‚£ä¹ˆä»Šå¤©ä¸å°±ä¸æŒæœ‰è‚¡ç¥¨äº†


dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
// dp[i][k][1]  è¡¨ç¤ºä» 0 åˆ°ç¬¬iå¤©ï¼Œå®Œæˆkç¬”äº¤æ˜“ï¼ŒæŒæœ‰è‚¡ç¥¨ï¼Œèƒ½è·å–çš„æœ€å¤§åˆ©æ¶¦
åˆ†æˆä¸¤ç§æƒ…å†µï¼š
// dp[i-1][k][1] 							 	è¡¨ç¤ºä» 0 åˆ° i-1å¤©ï¼ˆä¹Ÿå°±æ˜¯å‰ä¸€å¤©ï¼‰ï¼Œä¹ŸæŒæœ‰è‚¡ç¥¨
// dp[i-1][k-1][0] - prices[i] 	è¡¨ç¤ºä» 0 åˆ° i-1å¤©ï¼ˆä¹Ÿå°±æ˜¯å‰ä¸€å¤©ï¼‰ï¼ŒæœªæŒæœ‰äº†è‚¡ç¥¨ï¼Œä½†æ˜¯ä»Šå¤©é€‰æ‹©ä¹°å…¥ï¼Œé‚£ä¹ˆä¸å°±æŒæœ‰è‚¡ç¥¨äº†ã€‚å› ä¸ºæ˜¯ä»Šå¤©ä¹°å…¥è‚¡ç¥¨ï¼Œå®Œæˆäº†ä¸€ç¬”äº¤æ˜“ï¼Œä»Šå¤©çš„äº¤æ˜“æ¬¡æ•°æ˜¯kçš„å‰æä¸‹ï¼Œé‚£ä¹ˆå‰ä¸€å¤©çš„äº¤æ˜“æ¬¡æ•°å°±æ˜¯ k-1


æœ€ç»ˆç­”æ¡ˆï¼šå› ä¸ºè¦æ±‚æœ€å¤§åˆ©æ¶¦ï¼Œé‚£åªæœ‰ä¸æŒæœ‰è‚¡ç¥¨çš„åˆ©æ¶¦æœ€å¤§ dp[n-1][k][0] ï¼ˆä» 0åˆ° n-1ï¼Œå®Œæˆäº†kç¬”äº¤æ˜“åï¼Œä¸æŒæœ‰è‚¡ç¥¨ï¼‰
```
æœ¬é¢˜ç­”æ¡ˆï¼š
æ³¨æ„ï¼šæœ¬é¢˜æ˜¯æ¯ä¸€å¤©éƒ½å¯ä»¥è¿›è¡Œäº¤æ˜“ï¼ˆå¯ä»¥å®Œæˆæ— æ•°æ¬¡äº¤æ˜“ ï¼‰ã€‚è€Œ 121é¢˜åªèƒ½åœ¨æŸä¸€å¤©äº¤æ˜“ï¼Œå¦å¤–ä¸€å¤©å–å‡ºï¼ˆä¹Ÿå°±æ˜¯åªèƒ½å®Œæˆä¸€æ¬¡äº¤æ˜“ï¼‰

- å¯¹äºæœ¬é¢˜ï¼Œå»æ‰`k`è¿™ä¸ªé™å®šï¼Œå› ä¸ºå¯ä»¥è¿›è¡Œæ— æ•°æ¬¡ï¼ˆæ²¡æœ‰äº¤æ˜“æ¬¡æ•°ä¸Šé™ï¼‰
- æœ€ç»ˆçš„åœ°æ¨å…³ç³»ä¸ºï¼š
```go
dp[i][0] = max(dp[i-1][0],dp[i-1][1] + prices[i])
dp[i][1] = max(dp[i-1][1],dp[i-1][0] - prices[i])
```
æœ€ç»ˆé¢˜è§£ä¸ºï¼š

```go
func maxProfit(prices []int) int {

    n := len(prices)

    dp := make([][]int,n) // æ„é€ dpæ•°ç»„
    for k,_ := range dp {
        dp[k] = make([]int,2)
    }

    for i := 0;i < len(prices);i++ {
				
        if i-1 < 0 { // base case
            dp[i][0] = 0
            dp[i][1] = -prices[i]
        } else { // ä¸€èˆ¬é€’æ¨å…³ç³»
            dp[i][0] = max(dp[i-1][0],dp[i-1][1] + prices[i])
            dp[i][1] = max(dp[i-1][1],dp[i-1][0] - prices[i])
        }
    }
		// åœ¨ç¬¬ n-1å¤©ä¸æŒæœ‰è‚¡ç¥¨çš„æœ€å¤§åˆ©æ¶¦
    return dp[n-1][0]
}

func max(a,b int) int {
    if a > b {
        return a
    }
    return b
}
```
## 152. ä¹˜ç§¯æœ€å¤§å­æ•°ç»„
ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums` ï¼Œè¯·ä½ æ‰¾å‡ºæ•°ç»„ä¸­ä¹˜ç§¯æœ€å¤§çš„éç©ºè¿ç»­ å­æ•°ç»„ï¼ˆè¯¥å­æ•°ç»„ä¸­è‡³å°‘åŒ…å«ä¸€ä¸ªæ•°å­—ï¼‰ï¼Œå¹¶è¿”å›è¯¥å­æ•°ç»„æ‰€å¯¹åº”çš„ä¹˜ç§¯ã€‚
æµ‹è¯•ç”¨ä¾‹çš„ç­”æ¡ˆæ˜¯ä¸€ä¸ª **32-ä½** æ•´æ•°ã€‚
æ€è·¯ï¼š
è¿™é¢˜å’Œæœ€å¤§å­æ•°ç»„å’Œç±»ä¼¼ï¼ˆåªéœ€è¦å®šä¹‰æœ€å¤§å­æ•°ç»„å’Œï¼‰ï¼Œä½†æ˜¯æœ¬é¢˜éœ€è¦å®šä¹‰æœ€å¤§å­æ•°ç»„ä¹˜ç§¯å’Œæœ€å°å­æ•°ç»„ä¹˜ç§¯ã€‚

- `dpMax`æ•°ç»„å®šä¹‰ï¼šä»¥`i`ä¸ºç»“å°¾çš„æœ€å¤§ä¹˜ç§¯
- `dpMin`æ•°ç»„å®šä¹‰ï¼šä»¥`i`ä¸ºç»“å°¾çš„æœ€å°ä¹˜ç§¯![fa7a62a9-efd3-4674-b7e5-0ba782646d00.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411710028-fa7a62a9-efd3-4674-b7e5-0ba782646d00.png)

![7d67fb63-1ff7-4716-936b-5ecade35291b.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411710384-7d67fb63-1ff7-4716-936b-5ecade35291b.png)

å› ä¸ºå½“å‰`nums`æ˜¯`-3`,ä¹˜ä¸Šä¸€ä¸ªæ­£æ•° `2`ï¼Œåªä¼šè®©ç»“æœæ›´å°ã€‚é‚£å¦‚æœä¹˜ä¸Šçš„æ˜¯ä¸ªè´Ÿæ•°å‘¢ï¼Ÿè´Ÿè´Ÿå¾—æ­£ï¼Œé‚£ç»“æœä¸å°±æ˜¯å˜å¤§äº†ã€‚é‚£å°±è¦æƒ³åˆ°è´Ÿæ•°è‚¯å®šä¸æ˜¯ä¸€ä¸ªæœ€å¤§å€¼ï¼Œé‚£å°±æ˜¯ä¸€ä¸ªæœ€å°å€¼ã€‚æ‰€ä»¥é¢å¤–å®šä¹‰ä¸€ä¸ªæœ€å°å€¼çš„æ•°ç»„ä¹˜ç§¯
![8acef025-a5ab-4b97-81a6-c1e22e03183a.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411710447-8acef025-a5ab-4b97-81a6-c1e22e03183a.png)


```go
func maxProduct(nums []int) int {
  
		// å®šä¹‰ dp æ•°ç»„
    dpMax := make([]int,len(nums))
    dpMin := make([]int,len(nums))


    for i := 0;i < len(nums);i++ { //æ¯ä¸ªå…ƒç´ å€¼ï¼ˆå°±æ˜¯ä¸€ä¸ªå­æ•°ç»„ï¼‰ï¼Œå°±æ˜¯åˆå§‹å€¼
        dpMax[i] = nums[i]
        dpMin[i] = nums[i]
    }

    
    for i := 1;i < len(nums);i++ {
      	// ç”¨ nums[i] * å‰ä¸€ä¸ªæœ€å¤§oræœ€å°å­æ•°ç»„ä¹˜ç§¯
        maxVal := nums[i]*dpMax[i-1]
        minVal := nums[i]*dpMin[i-1]
      	// å–æœ€å¤§å€¼ä½œä¸º dpMax
        dpMax[i] = max(dpMax[i], maxVal,minVal )
      	// å–æœ€å°å€¼ä½œä¸º dpMin
        dpMin[i] = min(dpMin[i], maxVal,minVal)
    }
    
    res := math.MinInt
		// å†éå†ä¸€éï¼ŒdpMaxæ•°ç»„ï¼Œæ‰¾å‡ºæœ€å€¼ï¼Œè¿”å›
    for i := 0;i < len(dpMax);i++ {
        res = max1(res,dpMax[i])
    }
    return res
}

func max1(a,b int) int{
    if a > b{
        return a
    }
    return b
}

func max(a,b ,c int) int{
    if a < b{
        a = b
    }
    if a > c {
        return a
    }
    return c
}

func min(a,b,c int) int{
    if a > b{
        a = b
    }

    if a > c {
        return c
    }
    return a
}
```
## 179. æœ€å¤§æ•°
ç»™å®šä¸€ç»„éè´Ÿæ•´æ•° `nums`ï¼Œé‡æ–°æ’åˆ—æ¯ä¸ªæ•°çš„é¡ºåºï¼ˆæ¯ä¸ªæ•°ä¸å¯æ‹†åˆ†ï¼‰ä½¿ä¹‹ç»„æˆä¸€ä¸ªæœ€å¤§çš„æ•´æ•°ã€‚
**æ³¨æ„ï¼š**è¾“å‡ºç»“æœå¯èƒ½éå¸¸å¤§ï¼Œæ‰€ä»¥ä½ éœ€è¦è¿”å›ä¸€ä¸ªå­—ç¬¦ä¸²è€Œä¸æ˜¯æ•´æ•°ã€‚
æ€è·¯ï¼š

```go
func largestNumber(nums []int) string {
    // è¿™é¢˜çš„æ€è·¯å°±æ˜¯æ’åºï¼šæŒ‰ç…§ç›¸é‚»çš„ä¸¤ä¸ªæ•°å­—ï¼Œå¸Œæœ›ç»„æˆæœ€å¤§çš„æ•°å€¼ï¼Œæ¯”å¦‚ 3å’Œ30ï¼›å¯ä»¥ç»„æˆ330å’Œ303ï¼Œç¬¦åˆé¢˜ç›®çš„ç»“æœä¸º330ï¼›

    // 1.å…ˆå°†intè½¬æˆå­—ç¬¦ä¸²ä¿å­˜èµ·æ¥
    strSlice := make([]string,len(nums),len(nums))

    for k, v := range nums {
        strSlice[k] = strconv.Itoa(v)
    }

    // 2.ç„¶åå¯¹å­—ç¬¦ä¸²æ•°ç»„æ’åº
    sort.Slice(strSlice,func(i,j int)bool {
      
        // æ¯”å¦‚3å’Œ30ï¼Œé‚£å°±æ‹¼æ¥ä¸ºï¼š330å’Œ303 è¿›è¡Œæ¯”è¾ƒ
        return strSlice[i] + strSlice[j] > strSlice[j] + strSlice[j]
    })

    // 3.corner case å¦‚æœæ•°ç»„ä¸­éƒ½æ˜¯0ï¼Œç‰¹æ®Šæƒ…å†µçš„é¦–å­—ç¬¦ï¼Œæ˜¯0

    if strSlice[0][0] == '0' {
        return "0"
    }

    return strings.Join(strSlice,"")
}
```
## 169. å¤šæ•°å…ƒç´ 
ç»™å®šä¸€ä¸ªå¤§å°ä¸º `n` çš„æ•°ç»„ `nums` ï¼Œè¿”å›å…¶ä¸­çš„å¤šæ•°å…ƒç´ ã€‚å¤šæ•°å…ƒç´ æ˜¯æŒ‡åœ¨æ•°ç»„ä¸­å‡ºç°æ¬¡æ•° **å¤§äº**`âŒŠ n/2 âŒ‹` çš„å…ƒç´ ã€‚
ä½ å¯ä»¥å‡è®¾æ•°ç»„æ˜¯éç©ºçš„ï¼Œå¹¶ä¸”ç»™å®šçš„æ•°ç»„æ€»æ˜¯å­˜åœ¨å¤šæ•°å…ƒç´ ã€‚
æ€è·¯ï¼š
è¿™é“é¢˜çš„æ ‡å‡†è§£æ³•è‚¯å®šæ˜¯ç”¨ä¸€ä¸ªå“ˆå¸Œè¡¨ä½œä¸ºè®¡æ•°å™¨è®°å½•æ¯ä¸ªå…ƒç´ å‡ºç°çš„æ¬¡æ•°ï¼Œç„¶åå¯»æ‰¾å‡ºç°æ¬¡æ•°æœ€å¤šçš„é‚£ä¸ªå…ƒç´ ï¼Œæ—¶é—´å’Œç©ºé—´å¤æ‚åº¦éƒ½æ˜¯ `O(N)`ã€‚
ä½†æ˜¯ç”±äºé¢˜ç›®è¯´äº†è¿™ä¸ªç›®æ ‡å…ƒç´ ï¼ˆä¼—æ•°ï¼‰å‡ºç°çš„æ¬¡æ•°**è¿‡åŠ**ï¼Œè¿™å°±æœ‰æ„æ€äº†ï¼Œå…¶å®æˆ‘ä»¬ä¸éœ€è¦ç”¨å“ˆå¸Œè¡¨æ¥åšè®¡æ•°å™¨å°±èƒ½æŠŠè¿™ä¸ªä¼—æ•°æ‰¾å‡ºæ¥ã€‚
æ¯”æ–¹è¯´ä¸€ç¾¤å¸¦æ­£ç”µçš„ç²’å­å’Œä¸€ç¾¤å¸¦è´Ÿç”µçš„ç²’å­ï¼ŒæŠŠå®ƒä»¬æ··åˆèµ·æ¥ï¼Œå¾—åˆ°çš„è¿™ç¾¤æ··åˆç²’å­çš„å¸¦ç”µæ€§è´¨æ˜¯ä»€ä¹ˆï¼Ÿè¿™å–å†³äºæ­£ç”µç¦»å­å¤šè¿˜æ˜¯è´Ÿç”µç¦»å­å¤šï¼Œå¦‚æœæ­£è´Ÿç²’å­æ•°é‡æ°å¥½ç›¸ç­‰ï¼Œåˆ™å‘ˆç”µä¸­æ€§ã€‚
å›åˆ°è¿™é“é¢˜ï¼Œé¢˜ç›®å‘Šè¯‰ä½ ä¸€å®šå­˜åœ¨ä¸€ä¸ªä¼—æ•°ï¼Œå®ƒå‡ºç°çš„æ¬¡æ•°è¿‡åŠï¼Œé‚£ä¹ˆå¦‚æœä½ æŠŠè¿™ä¸ªä¼—æ•°å…ƒç´ æƒ³è±¡æˆæ­£ç”µç²’å­ï¼Œå…¶ä»–çš„æ‰€æœ‰å…ƒç´ éƒ½æƒ³è±¡æˆè´Ÿç”µç²’å­ï¼Œé‚£ä¹ˆå®ƒä»¬æ··åˆèµ·æ¥ä¼šæ€æ ·ï¼Ÿ
**åœ¨æ­£è´Ÿç²’å­æ··åˆçš„è¿‡ç¨‹ä¸­ï¼Œæ•´ä½“çš„å¸¦ç”µæ€§å¯èƒ½åœ¨æ­£è´Ÿé—´æ³¢åŠ¨ï¼Œä½†æœ€ç»ˆçš„ç»“æœä¸€å®šæ˜¯æ­£ç”µ**ã€‚

```go
func majorityElement(nums []int) int {
	
	target := 0
	count := 0 // è¿™é‡Œçš„countå¯ä»¥æƒ³è±¡ã€ç”µå­å®¹å™¨ã€‘çš„ç”µæ€§æ˜¯ä¸­æ€§çš„
	for i := 0; i < len(nums); i++ {
		if count == 0 {
			target = nums[i] // count = 0 è¡¨ç¤ºä¸­æ€§çš„ï¼Œå°† nums[i] ä½œä¸ºç¬¬ä¸€ä¸ªç”µå­ï¼Œæ”¾åˆ°å®¹å™¨ä¸­
			count++ // å®¹å™¨ç”µæ€§+1
		} else if target == nums[i] { //å‘ç°äº†targetç”µå­ç›¸åŒï¼Œç”µæ€§++
			count++
		} else { //å¦åˆ™ç”µæ€§--
			count--
		}
	}
	return target
}
```
## 62. ä¸åŒè·¯å¾„
ä¸€ä¸ªæœºå™¨äººä½äºä¸€ä¸ª `m x n` ç½‘æ ¼çš„å·¦ä¸Šè§’ ï¼ˆèµ·å§‹ç‚¹åœ¨ä¸‹å›¾ä¸­æ ‡è®°ä¸º â€œStartâ€ ï¼‰ã€‚
æœºå™¨äººæ¯æ¬¡åªèƒ½å‘ä¸‹æˆ–è€…å‘å³ç§»åŠ¨ä¸€æ­¥ã€‚æœºå™¨äººè¯•å›¾è¾¾åˆ°ç½‘æ ¼çš„å³ä¸‹è§’ï¼ˆåœ¨ä¸‹å›¾ä¸­æ ‡è®°ä¸º â€œFinishâ€ ï¼‰ã€‚
é—®æ€»å…±æœ‰å¤šå°‘æ¡ä¸åŒçš„è·¯å¾„ï¼Ÿ
æ€è·¯ï¼š
æœ¬é¢˜å’Œ**64.æœ€å°è·¯å¾„å’Œ**è¿™é¢˜æœ‰ç±»ä¼¼ä¹‹å¤„ï¼Œéƒ½æ˜¯åªèƒ½å‘ä¸‹ã€å‘å³ç§»åŠ¨ï¼Œä¸€ä¸ªæ˜¯è®¡ç®—è·¯å¾„æ•°ï¼Œä¸€ä¸ªæ˜¯è®¡ç®—æœ€å°è·¯å¾„ã€‚æ‰€ä»¥ï¼Œæˆ‘ä»¬åªéœ€è¦ä¿®æ”¹ä¸‹ `dp`æ•°ç»„çš„å®šä¹‰å³å¯ã€‚
![0600c3b1-2821-4b64-89d8-8a63762e2076.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411710374-0600c3b1-2821-4b64-89d8-8a63762e2076.png)


```go
func uniquePaths(m int, n int) int {
   
		// å®šä¹‰ dp æ•°ç»„
    dp := make([][]int,m)
    for i := 0;i < m;i++ {
        dp[i] = make([]int,n)
    }


    for i := 0;i < m;i++ {
        for j := 0;j < n;j++ {
            if i == 0 { // base case ç¬¬ä¸€è¡Œ å› ä¸ºåªèƒ½å‘å³ç§»åŠ¨
                dp[i][j] = 1
            } else if j == 0 { //base case  ç¬¬ä¸€åˆ— å› ä¸ºåªèƒ½å‘ä¸‹ç§»åŠ¨
                dp[i][j] = 1
            } else { // é€’æ¨å…³ç³»
                dp[i][j] = dp[i-1][j] + dp[i][j-1]
            }
        }
    }
  	// æœ€ç»ˆä½ç½®[m-1,n-1]
    return dp[m-1][n-1]
}
```
## 227. åŸºæœ¬è®¡ç®—å™¨II
ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸²è¡¨è¾¾å¼ `s` ï¼Œè¯·ä½ å®ç°ä¸€ä¸ªåŸºæœ¬è®¡ç®—å™¨æ¥è®¡ç®—å¹¶è¿”å›å®ƒçš„å€¼ã€‚æ•´æ•°é™¤æ³•ä»…ä¿ç•™æ•´æ•°éƒ¨åˆ†ã€‚ä½ å¯ä»¥å‡è®¾ç»™å®šçš„è¡¨è¾¾å¼æ€»æ˜¯æœ‰æ•ˆçš„ã€‚æ‰€æœ‰ä¸­é—´ç»“æœå°†åœ¨ `[-231, 231 - 1]` çš„èŒƒå›´å†…ã€‚
**æ³¨æ„ï¼š**ä¸å…è®¸ä½¿ç”¨ä»»ä½•å°†å­—ç¬¦ä¸²ä½œä¸ºæ•°å­¦è¡¨è¾¾å¼è®¡ç®—çš„å†…ç½®å‡½æ•°ï¼Œæ¯”å¦‚ `eval()` ã€‚
æ€è·¯ï¼š
ç¬¬ä¸€æ¬¡åšï¼Œè¿™é¢˜æŒºéš¾æƒ³åˆ°ï¼Œåˆ©ç”¨æ ˆï¼Œæ¨¡æ‹Ÿè®¡ç®—è¿‡ç¨‹ï¼ˆä¸€å›ç”ŸäºŒå›ç†Ÿï¼Œå¤šçœ‹å‡ æ¬¡å°±è®°ä½äº†ï¼‰

- åˆ©ç”¨ä¸¤ä¸ªæ ˆå®ç°ï¼Œä¸€ä¸ªå­˜å‚¨æ•°å€¼ï¼Œä¸€ä¸ªå­˜å‚¨ç¬¦å·
- é‡åˆ°æ•°å€¼ç›´æ¥å…¥æ ˆ
- é‡åˆ°ç¬¦å·ï¼šéœ€è¦åˆ¤æ–­ï¼ˆåœ¨æ ˆä¸ä¸ºç©ºçš„æƒ…å†µä¸‹ï¼‰ï¼Œå½“å‰ç¬¦å·ä¼˜å…ˆçº§ <= æ ˆé¡¶ç¬¦å·ä¼˜å…ˆçº§ï¼ˆ**ä¹Ÿå°±æ˜¯æ ˆä¸­çš„ç¬¦å·çš„ä¼˜å…ˆçº§æ¯”è¾ƒé«˜**ï¼‰
- é‚£ä¹ˆï¼Œå‡ºæ ˆä¸¤ä¸ªæ•°å€¼ï¼Œå’Œå‡ºæ ˆä¸€ä¸ªç¬¦å·ï¼Œè®¡ç®—ç»“æœï¼ŒæŠŠç»“æœå­˜å…¥ã€æ ˆä¸­ã€‘
- ç»§ç»­æ¯”è¾ƒï¼Œæ˜¯å¦ç¬¦åˆï¼ˆå½“å‰ç¬¦å·ä¼˜å…ˆçº§ <= æ ˆé¡¶ï¼ˆä¸”æ ˆä¸ä¸ºç©ºï¼‰ï¼‰ï¼Œå¦åˆ™ç¬¦å·ç›´æ¥å…¥æ ˆï¼›
```go
func calculate(s string) int {
    
		// ä¸¤ä¸ªæ ˆ
    operands := make([]int,0) //æ“ä½œæ•°
    operators := make([]byte,0)//æ“ä½œç¬¦
    var result int
  	// index ä½œä¸ºç´¢å¼•ï¼Œç”¨æ¥éå†æ¯ä¸€ä¸ªå­—ç¬¦
    index := 0
    for index < len(s) {
        if isDigit(s[index]) { //åˆ¤æ–­å­—ç¬¦æ˜¯å¦æ˜¯æ•°å­—
          	// è¿ç»­å–å‡ºå¤šä¸ªå­—ç¬¦ï¼Œä½œä¸ºä¸€ä¸ªå®Œæ•´çš„æ•´æ•°
            digit := 0
            for index < len(s) && isDigit(s[index]) {
                digit = 10*digit + int((s[index]-'0'))
                index++
            }
          	// ä¿å­˜åˆ°æ ˆä¸­
            operands = append(operands,digit)
        } else if s[index] == ' ' { //ç©ºæ ¼ï¼Œè·³è¿‡
            index++
        } else {
          	// operators æ ˆä¸ä¸ºç©ºï¼Œå¹¶ä¸”æ ˆé¡¶çš„ç¬¦å·ä¼˜å…ˆçº§é«˜ï¼ˆå…ˆè®¡ç®—æ ˆä¸­çš„ç¬¦å·ï¼‰
            for len(operators) != 0 && priority(operators[len(operators)-1],s[index] ) { //æ ˆé¡¶ä¼˜å…ˆçº§ >= s[i]
                //å‡ºæ ˆå¹¶è¿ç®— -- è¿ç®—å®Œæˆåï¼Œç»§ç»­çœ‹ä¸‹ä¸€ä¸ªæ“ä½œç¬¦å·
                if operators[len(operators)-1] == '+' {
                    result =  operands[len(operands)-2] + operands[len(operands)-1]
                }else if operators[len(operators)-1] == '-' {
                    result =  operands[len(operands)-2] - operands[len(operands)-1]
                }else if operators[len(operators)-1] == '*' {
                    result =  operands[len(operands)-2] * operands[len(operands)-1]
                }else if operators[len(operators)-1] == '/' {
                    result =  operands[len(operands)-2] / operands[len(operands)-1]
                }
               
               //å‡ºæ ˆæ•°å€¼
               operands = operands[:len(operands)-2]
               operands = append(operands,result) //å…¥æ ˆresultç»“æœ
               //å‡ºæ ˆç¬¦å·
               operators = operators[:len(operators)-1]
            }

            //ç›´åˆ°æ“ä½œç¬¦å·ä¸ºç©ºï¼Œæˆ–è€…ï¼Œä¸æ»¡è¶³ä¼˜å…ˆçº§å…³ç³»ï¼Œå…¥æ ˆæ“ä½œç¬¦
            operators = append(operators,s[index])
            index++ //ç»§ç»­ä¸‹ä¸€ä¸ªå­—ç¬¦
        }
    }
  
  	//å¦‚æœè¿˜æœ‰è¿ç®—ç¬¦å·ï¼Œè¯´æ˜è¿˜éœ€è¦åšæœ€åçš„è¿ç®—
    for len(operators) != 0  { 
        //å‡ºæ ˆå¹¶è¿ç®—
        if operators[len(operators)-1] == '+' {
            result =  operands[len(operands)-2] + operands[len(operands)-1]
        }else if operators[len(operators)-1] == '-' {
            result =  operands[len(operands)-2] - operands[len(operands)-1]
        }else if operators[len(operators)-1] == '*' {
            result =  operands[len(operands)-2] * operands[len(operands)-1]
        }else if operators[len(operators)-1] == '/' {
            result =  operands[len(operands)-2] / operands[len(operands)-1]
        }
        
        //å‡ºæ ˆæ•°å€¼
        operands = operands[:len(operands)-2]
        operands = append(operands,result) //å…¥æ ˆresultç»“æœ
        //å‡ºæ ˆç¬¦å·
        operators = operators[:len(operators)-1]
    }
    // æœ€åoperandsæ ˆä¸­ä¿å­˜çš„å°±æ˜¯ç»“æœ
    return operands[0]
}

func priority( a, b byte) bool {
    if a == '*' || a == '/' {
        return true
    } else if b == '+' || b== '-' {
        return true
    }
    return false
}

func isDigit( c byte)bool{
    if c >= '0' && c <= '9' {
        return true
    }
    return false
}
```
## 718. æœ€é•¿é‡å¤å­æ•°ç»„
ç»™ä¸¤ä¸ªæ•´æ•°æ•°ç»„ `nums1` å’Œ `nums2` ï¼Œè¿”å› *ä¸¤ä¸ªæ•°ç»„ä¸­ ****å…¬å…±çš„**** ã€é•¿åº¦æœ€é•¿çš„å­æ•°ç»„çš„é•¿åº¦* ã€‚
æ€è·¯ï¼š

- `dp`æ•°ç»„å®šä¹‰ï¼š`dp[i][j] ` è¡¨ç¤ºå¿…é¡»ä»¥ `i`ç»“å°¾çš„å­æ•°ç»„å’Œ å¿…é¡»ä»¥`j`ç»“å°¾å­æ•°ç»„çš„å…¬å…±é•¿åº¦ï¼ˆæ³¨æ„ï¼š"å¿…é¡»"çš„å«ä¹‰ï¼‰
- é€’æ¨å…³ç³»ï¼šå¦‚æœ`nums1[i] == nums2[j]`ï¼Œè¡¨ç¤ºä¸¤ä¸ªå­æ•°ç»„ç»“å°¾çš„æ•°å€¼ç›¸åŒ `dp[i][j] = dp[i-1][j-1] + 1`
å¦‚æœ `nums1[i] != nums2[j]`ï¼Œè¡¨ç¤ºä¸¤ä¸ªå­æ•°ç»„ç»“å°¾çš„æ•°å€¼ä¸ç›¸åŒï¼Œä¹Ÿå°±æ˜¯è¯´å¿…é¡»ä»¥ `i`ç»“å°¾çš„å­æ•°ç»„å’Œ å¿…é¡»ä»¥`j`ç»“å°¾å­æ•°ç»„çš„å…¬å…±é•¿åº¦ä¸º`0`
![ae080b88-6dbe-401a-b64d-d7d5f45d3a7c.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411710611-ae080b88-6dbe-401a-b64d-d7d5f45d3a7c.png)


```go
func findLength(nums1 []int, nums2 []int) int {
    // dp æ•°ç»„å®šä¹‰
    m,n := len(nums1),len(nums2)
    dp := make([][]int,m)
    for k,_ := range dp {
        dp[k] = make([]int,n)
    }

    result := 0
    for i := 0;i < m;i++ {
        for j := 0;j< n;j++ {
            if  i == 0  ||  j == 0 { // base case å½“iå­æ•°ç»„åªæœ‰ä¸€ä¸ªå…ƒç´  or jå­æ•°ç»„åªæœ‰ä¸€ä¸ªå…ƒç´ 
                if nums1[i] == nums2[j] {
                    dp[i][j] = 1
                }
            } else if nums1[i] == nums2[j] { // ä¸€èˆ¬é€’æ¨å…³ç³»
                dp[i][j] = dp[i-1][j-1] + 1
            }
						// é¢˜ç›®è¦æ±‚æœ€å¤§é•¿åº¦ï¼Œdp[i][j]åªæ˜¯è®°å½•çš„æ¯ä¸€ä¸ªçš„å­æ•°ç»„çš„å…¬å…±é•¿åº¦
            if dp[i][j] > result {
                result = dp[i][j]
            }
        }
    }
    return result
}
```
## 198. æ‰“å®¶åŠ«èˆ
ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„å°å·ï¼Œè®¡åˆ’å·çªƒæ²¿è¡—çš„æˆ¿å±‹ã€‚æ¯é—´æˆ¿å†…éƒ½è—æœ‰ä¸€å®šçš„ç°é‡‘ï¼Œå½±å“ä½ å·çªƒçš„å”¯ä¸€åˆ¶çº¦å› ç´ å°±æ˜¯ç›¸é‚»çš„æˆ¿å±‹è£…æœ‰ç›¸äº’è¿é€šçš„é˜²ç›—ç³»ç»Ÿï¼Œ**å¦‚æœä¸¤é—´ç›¸é‚»çš„æˆ¿å±‹åœ¨åŒä¸€æ™šä¸Šè¢«å°å·é—¯å…¥ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨æŠ¥è­¦**ã€‚
ç»™å®šä¸€ä¸ªä»£è¡¨æ¯ä¸ªæˆ¿å±‹å­˜æ”¾é‡‘é¢çš„éè´Ÿæ•´æ•°æ•°ç»„ï¼Œè®¡ç®—ä½  **ä¸è§¦åŠ¨è­¦æŠ¥è£…ç½®çš„æƒ…å†µä¸‹** ï¼Œä¸€å¤œä¹‹å†…èƒ½å¤Ÿå·çªƒåˆ°çš„æœ€é«˜é‡‘é¢ã€‚
æ€è·¯ï¼š
![686355b7-3a91-4f22-ae09-bfc05336e7c3.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411710538-686355b7-3a91-4f22-ae09-bfc05336e7c3.png)

åœ¨æ¯é—´æˆ¿å­å‰éƒ½æœ‰ä¸¤ç§**é€‰æ‹©**ï¼šæŠ¢æˆ–è€…ä¸æŠ¢ã€‚
åœ¨`i`ä½ç½®å¤„ï¼Œæˆ‘ä»¬å¦‚æœä¸å·çªƒï¼Œ`dp[i] = dp[i-1]`
åœ¨`i`ä½ç½®å¤„ï¼Œå¦‚æœå·ï¼Œ`dp[i] = dp[i-2] + nums[i]`
æ‰€ä»¥ï¼Œæˆ‘ä»¬çš„æœ€å¤§é‡‘é¢ä¸ºï¼š `dp[i] = max(dp[i-1],dp[i-2]+nums[i])`
![17249c7e-c05d-4be4-a022-ae0b606fc66b.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411711072-17249c7e-c05d-4be4-a022-ae0b606fc66b.png)


```go
func rob(nums []int) int {
   
		// å®šä¹‰ dp æ•°ç»„
    dp := make([]int ,len(nums))
   
    for i := 0; i < len(nums);i++ {
        if i == 0 { // base case åªæœ‰ä¸€ä¸ªæˆ¿é—´
            dp[i] = nums[0]
        } else if i == 1 { // base æœ‰ä¸¤ä¸ªæˆ¿é—´
            dp[i] = max(nums[0],nums[1])
        } else { // ä¸€èˆ¬é€’æ¨å…³ç³»
            dp[i] = max(dp[i-1],nums[i]+ dp[i-2])
        }
    }
  	// æœ€åï¼Œ dp[len(nums)-1] è¡¨ç¤ºä»[0...len(nums)-1]èƒ½å·çªƒçš„æœ€å¤§é‡‘é¢ï¼ˆä¸ç†è§£çš„è¯ï¼Œçœ‹ä¸‹dpæ•°ç»„çš„å®šä¹‰ï¼‰
    return dp[len(nums)-1]
}

func max(a,b int) int{
    if a > b {
        return a
    }
    return b
}
```
## 83. åˆ é™¤æ’åºé“¾è¡¨ä¸­çš„é‡å¤å…ƒç´ 
ç»™å®šä¸€ä¸ªå·²æ’åºçš„é“¾è¡¨çš„å¤´ `head` ï¼Œ *åˆ é™¤æ‰€æœ‰é‡å¤çš„å…ƒç´ ï¼Œä½¿æ¯ä¸ªå…ƒç´ åªå‡ºç°ä¸€æ¬¡* ã€‚è¿”å› *å·²æ’åºçš„é“¾è¡¨* ã€‚
æ€è·¯ï¼š

```go
func deleteDuplicates(head *ListNode) *ListNode {

    p := head
    
    for head != nil {
      	// å›ºå®šleft
        left := head
				// è®© head ç§»åŠ¨ï¼Œä¿è¯ [left,head]ä¹‹é—´çš„å…ƒç´ ç›¸åŒ
        for head.Next != nil && left.Val == head.Next.Val {
            head = head.Next
        }

        // [left,head] å°±æ˜¯é‡å¤çš„å…ƒç´ ï¼Œä¿ç•™ä¸€ä¸ª
        if left != head {
            left.Next = head.Next
        }
        head = head.Next // åŒæ—¶ head æŒ‡å‘æ–°çš„ä¸€è½®é“¾è¡¨çš„èµ·å§‹ä½ç½®
    }
    return p
}
```
![79b15b83-e24f-46d4-86a8-90fcac204c4a.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411711130-79b15b83-e24f-46d4-86a8-90fcac204c4a.png)

![f30bdfb8-480f-43fa-924d-0b625bd479f3.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411711095-f30bdfb8-480f-43fa-924d-0b625bd479f3.png)

## 226. ç¿»è½¬äºŒå‰æ ‘
ç»™ä½ ä¸€æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œç¿»è½¬è¿™æ£µäºŒå‰æ ‘ï¼Œå¹¶è¿”å›å…¶æ ¹èŠ‚ç‚¹ã€‚
æ€è·¯ï¼š
è¿™é¢˜å’Œ**101. å¯¹ç§°äºŒå‰æ ‘**å¯ä»¥å¯¹æ¯”çœ‹ä¸‹ï¼Œéƒ½æ˜¯å‰åºä½ç½®è¿›è¡Œå¤„ç†ã€‚äºŒå‰æ ‘çš„å¤„ç†ï¼Œæ—¢è¦ä»¥`root`æ ‘çš„æ•´ä½“è§’åº¦æ€è€ƒï¼Œä¹Ÿè¦ä»å…·ä½“çš„ä¸€ä¸ª`root`èŠ‚ç‚¹æ€è€ƒã€‚
å¦‚ä½•ç¿»è½¬äºŒå‰æ ‘ï¼Ÿå…¶å®å°±æ˜¯æŠŠäºŒå‰æ ‘ä¸Šçš„æ¯ä¸ªèŠ‚ç‚¹çš„å·¦å³å­èŠ‚ç‚¹éƒ½äº¤æ¢ä¸€ä¸‹

```go
// invertTreeå‡½æ•°å®šä¹‰ï¼šç¿»è½¬rootäºŒå‰æ ‘
func invertTree(root *TreeNode) *TreeNode {
    if root == nil {
        return root
    }

    //å¯¹rootèŠ‚ç‚¹ï¼Œå·¦å³å­èŠ‚ç‚¹äº¤æ¢
    root.Left,root.Right = root.Right,root.Left
  	// ç¿»è½¬root.Leftå·¦æ ‘
    invertTree(root.Left)
  	// ç¿»è½¬root.Rightå³æ ‘
    invertTree(root.Right)
    return root
}
```
## 139. å•è¯æ‹†åˆ†
ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² `s` å’Œä¸€ä¸ªå­—ç¬¦ä¸²åˆ—è¡¨ `wordDict` ä½œä¸ºå­—å…¸ã€‚å¦‚æœå¯ä»¥åˆ©ç”¨å­—å…¸ä¸­å‡ºç°çš„ä¸€ä¸ªæˆ–å¤šä¸ªå•è¯æ‹¼æ¥å‡º `s` åˆ™è¿”å› `true`ã€‚
**æ³¨æ„ï¼š**ä¸è¦æ±‚å­—å…¸ä¸­å‡ºç°çš„å•è¯å…¨éƒ¨éƒ½ä½¿ç”¨ï¼Œå¹¶ä¸”å­—å…¸ä¸­çš„å•è¯å¯ä»¥é‡å¤ä½¿ç”¨ã€‚
æ€è·¯ï¼š
åŠ¨æ€è§„åˆ’
![é™„ä»¶ä¸‹è½½å¤±è´¥](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/)

è¿™é‡Œå…¶å®æœ‰ä¸¤ä¸ªå­—ç¬¦ä¸²`apple å’Œ pen`ä¾›é€‰æ‹©ã€‚
å¦‚æœé€‰æ‹© `apple`é‚£ä¹ˆ `dp[i]`çš„ç»„æˆå°±å–å†³äº`dp[i-5]`
å¦‚æœé€‰æ‹© `pen`é‚£ä¹ˆ `dp[i]`çš„ç»„æˆå°±å–å†³äº`dp[i-3]`
è¿™ä¸¤ç§æƒ…å†µåªè¦æœ‰ä¸€ä¸ªæ»¡è¶³å³å¯ï¼Œæ‰€ä»¥`dp[i]`éœ€è¦ç”¨ `||`æ¥ç»¼åˆ`dp[i-5] dp[i-3]`çš„ç»“æœã€‚
å¾ˆæ˜¾ç„¶ï¼Œè¿™é‡Œåªæœ‰ `apple`å’Œ`applepenapple`å°¾éƒ¨åŒ¹é…
ä¸‹å›¾æ¼”ç¤ºäº†ï¼Œå–`apple`çš„æƒ…å†µä¸‹ï¼Œèƒ½å¦ç»„æˆçš„ç»“æœï¼Œä¿å­˜åˆ° `dp[i] `ä¸­
![12c39bf8-98c3-4831-b630-3726b5b1caab.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411711186-12c39bf8-98c3-4831-b630-3726b5b1caab.png)

![fa381e12-3961-4795-bcb3-688b45238292.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411711564-fa381e12-3961-4795-bcb3-688b45238292.png)

![b36e57e6-4ac1-4f07-9623-b74369baad26.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411711988-b36e57e6-4ac1-4f07-9623-b74369baad26.png)

`dp[i] = dp[i] || dp[i-len(word)] ` è¿™ä¸ªå¦‚æœä¸ç†è§£ï¼Œå¯ä»¥çœ‹ä¸‹è¿™ä¸ªèŒƒä¾‹ï¼š
æ¯”å¦‚å­—ç¬¦ä¸²`dogs` å’Œå­—ç¬¦ä¸²åˆ—è¡¨` [dog,gs,s]`
èƒ½å’Œ`dogs`å°¾éƒ¨åŒ¹é…çš„å­—ç¬¦ä¸²ï¼ŒåŒ…æ‹¬ `gs å’Œ s`ä¸¤ç§æƒ…å†µ

- å¦‚æœé€‰æ‹©`gs`ï¼Œé‚£ä¹ˆ`dp[i]`çš„ç»“æœå°±å–å†³äº`dp[i-2]`ï¼Œ` dp[i] = dp[i] || dp[i-2]` å°†ç»“æœä¿å­˜åˆ° `dp[i]`ä¸­
- å¦‚æœé€‰æ‹©`s`ï¼Œé‚£ä¹ˆ`dp[i]`çš„ç»“æœå°±å–å†³äº`dp[i-1]`ï¼Œ` dp[i] = dp[i] || dp[i-1]` å°†ç»“æœä¿å­˜åˆ° `dp[i]`ä¸­æ‰€ä»¥`dp[i]`å¾—æœ€ç»ˆç»“æœå°±å–å†³äº`dp[i-2] æˆ–è€… dp[i-1]`ã€‚

```go
func wordBreak(s string, wordDict []string) bool {

    // å®šä¹‰ dp[i] è¡¨ç¤º [0...i] èƒ½å¦ç”¨å­—ç¬¦ä¸²åˆ—è¡¨wordDictæ‹¼æ¥å‡ºæ¥
    dp := make([]bool,len(s))

    for i := 0; i < len(s);i++ {
			
        for _,word := range wordDict {
            // å­—ç¬¦ä¸²é•¿åº¦ >= word å¹¶ä¸” å°¾éƒ¨çš„å­—ç¬¦ä¸²å’Œ wordç›¸ç­‰
            if i + 1 >= len(word) && s[i+1-len(word):i+1] == word {
             	 if i - len(word) >= 0 { //æ²¡æœ‰è¶Šç•Œï¼Œéœ€è¦è€ƒè™‘å‰é¢çš„ç»“æœdp[i-len(word)]
                     dp[i] = dp[i] || dp[i-len(word)] // è¿™é‡Œç”¨ || è¡¨ç¤ºè¦ç»¼åˆè€ƒè™‘å­—ç¬¦ä¸²å°¾éƒ¨ï¼Œå’ŒwordDictçš„å¤šä¸ªå­—ç¬¦ä¸²éƒ½åŒ¹é…çš„æ—¶å€™çš„ç»“æœã€‚
                } else {
                    dp[i] = true // å¦‚æœè¶Šç•Œï¼Œè¯´æ˜æ­£å¥½åŒ¹é…å®Œæˆ
                } 
            }
        }
    }
    return dp[len(s)-1]
}
```
## 209. é•¿åº¦æœ€å°çš„å­æ•°ç»„
ç»™å®šä¸€ä¸ªå«æœ‰ `n` ä¸ªæ­£æ•´æ•°çš„æ•°ç»„å’Œä¸€ä¸ªæ­£æ•´æ•° `target`**ã€‚**
æ‰¾å‡ºè¯¥æ•°ç»„ä¸­æ»¡è¶³å…¶æ€»å’Œå¤§äºç­‰äº `target` çš„é•¿åº¦æœ€å°çš„ **å­æ•°ç»„**`[numsl, numsl+1, ..., numsr-1, numsr]` ï¼Œå¹¶è¿”å›å…¶é•¿åº¦**ã€‚**å¦‚æœä¸å­˜åœ¨ç¬¦åˆæ¡ä»¶çš„å­æ•°ç»„ï¼Œè¿”å› `0` ã€‚
**ç¤ºä¾‹ 1ï¼š**

```go
è¾“å…¥ï¼štarget = 7, nums = [2,3,1,2,4,3]
è¾“å‡ºï¼š2
è§£é‡Šï¼šå­æ•°ç»„ [4,3] æ˜¯è¯¥æ¡ä»¶ä¸‹çš„é•¿åº¦æœ€å°çš„å­æ•°ç»„ã€‚
```
æ€è·¯ï¼š

- è¦å…ˆç†è§£å­æ•°ç»„çš„å«ä¹‰ï¼š**å­æ•°ç»„****æ˜¯æ•°ç»„ä¸­è¿ç»­çš„****éç©º****å…ƒç´ åºåˆ—** ã€‚æ¯”å¦‚ä¸Šé¢çš„ç¤ºä¾‹ï¼Œ`[2,3,1]`æ˜¯å­æ•°ç»„ï¼Œ`[2,1]`å°±ä¸æ˜¯å­æ•°ç»„
- è¿™é¢˜çš„è§£æ³•é‡‡ç”¨æ»‘åŠ¨çª—å£ï¼šåˆ©ç”¨`left,right`æŒ‡é’ˆï¼Œæ¡†ä½ä¸€ç‰‡è¿ç»­åŒºåŸŸï¼›
ç§»åŠ¨`right`ä¿è¯çª—å£å†…çš„å­æ•°ç»„ä¹‹å’Œå¤§äºç­‰äº`target`ï¼›
ç§»åŠ¨`left`ä¿è¯çª—å£å†…çš„å­æ•°ç»„ä¹‹å’Œå¤§äºç­‰äº`target`çš„å‰æä¸‹ï¼Œçª—å£çš„é•¿åº¦å‡å°ï¼Œå¯»æ‰¾æœ€å°é•¿åº¦

```go
func minSubArrayLen(target int, nums []int) int {
    // æ»‘åŠ¨çª—å£
    n := len(nums)
  	// left right çª—å£çš„å·¦å³æŒ‡é’ˆ
    left,right := 0,0

    winSum := 0 // è®°å½•çª—å£å†…çš„æ€»å’Œ
    result := math.MaxInt // è®¾å®šä¸ºæœ€å¤§å€¼ï¼ˆå› ä¸ºè¦æ±‚æœ€å°å€¼ï¼‰

    for right < n {
				// ç§»åŠ¨å³è¾¹ç•Œ right
        rightVal := nums[right]
        right++
				// è®°å½•çª—å£å†…å­æ•°ç»„å’Œ
        winSum += rightVal

        for winSum >= target { // ä¿è¯çª—å£çš„æ€»å’Œ >= targetå‰æä¸‹ï¼Œå¯»æ‰¾æœ€å°æ•°ç»„é•¿åº¦
            result = min(result,right-left)
          	// ç§»åŠ¨å·¦è¾¹ç•Œ left
            leftVal := nums[left]
            left++
            winSum -= leftVal
        }
    }
    // è¡¨ç¤ºä¸å­˜åœ¨
    if result == math.MaxInt {
        result = 0
    }
    return result
}

func min(a,b int) int{
    if a < b{
        return a
    }
    return b
}
```
## 560. å’Œä¸ºKçš„å­æ•°ç»„
ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums` å’Œä¸€ä¸ªæ•´æ•° `k` ï¼Œè¯·ä½ ç»Ÿè®¡å¹¶è¿”å› *è¯¥æ•°ç»„ä¸­å’Œä¸º *`*k*`* çš„å­æ•°ç»„çš„ä¸ªæ•°* ã€‚
å­æ•°ç»„æ˜¯æ•°ç»„ä¸­å…ƒç´ çš„è¿ç»­éç©ºåºåˆ—ã€‚
**ç¤ºä¾‹ 1ï¼š**

```go
è¾“å…¥ï¼šnums = [1,1,1], k = 2
è¾“å‡ºï¼š2
```
**ç¤ºä¾‹ 2ï¼š**

```go
è¾“å…¥ï¼šnums = [1,2,3], k = 3
è¾“å‡ºï¼š2
```
æ€è·¯ï¼š
![1efd8b6b-503f-474c-b5c0-17a110345a6f.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411711945-1efd8b6b-503f-474c-b5c0-17a110345a6f.png)

ç”±ä¸Šå›¾å¯ä»¥å¾—çŸ¥ï¼Œè¿™ä¹ˆä¸€ä¸ªå…¬å¼` å‰ç¼€å’Œ X = å‰ç¼€å’ŒY + targetï¼ˆæ•°å€¼ç­‰äºtargetå­æ•°ç»„ï¼‰`ï¼Œä¹Ÿå°±æ˜¯ `å‰ç¼€å’Œ Y = å‰ç¼€å’ŒX - targetï¼ˆæ•°å€¼ç­‰äºtargetå­æ•°ç»„ï¼‰`ã€‚ç”±æ­¤å¯çŸ¥ï¼Œæˆ‘ä»¬åªéœ€è¦ç”¨å½“å‰çš„å‰ç¼€å’Œ `X - target` ï¼Œçœ‹ä¸‹æ˜¯å¦å­˜åœ¨å‰ç¼€å’Œ`Y` ï¼Œå¦‚æœå­˜åœ¨ï¼Œè¯´æ˜å°±å¯ä»¥æ‰¾åˆ°ä¸€ä¸ªæ»¡è¶³æ¡ä»¶çš„å­æ•°ç»„ï¼Œå’Œ `Y`ä¸€èµ·ï¼Œç»„æˆ`X`çš„å€¼ã€‚
è¿™é‡Œçš„`Y`çš„å€¼å¯èƒ½ä¼šé‡å¤å¤šæ¬¡
![553aed2a-d0ea-4996-837c-eca8c9468d5e.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411711961-553aed2a-d0ea-4996-837c-eca8c9468d5e.png)

åœ¨ `index= 3`çš„ä½ç½®ï¼Œå‰ç¼€å’Œ`6`ï¼Œå¯ä»¥ç”±å‰é¢çš„ä¸€ä¸ªå‰ç¼€å’Œ`3 + [0,3]`ç»„æˆï¼Œä¹Ÿå¯ä»¥æ˜¯åé¢çš„ä¸€ä¸ªå‰ç¼€å’Œ`3 + [3]`ç»„æˆï¼Œä¹Ÿå°±æ˜¯è¿™é‡Œçš„`å‰ç¼€å’ŒY=3`å‡ºç°äº†ä¸¤æ¬¡ï¼ˆä»£è¡¨å­æ•°ç»„ä¹Ÿæœ‰ä¸¤ç§æ–¹æ¡ˆï¼‰
æœ€ç»ˆå®ç°ä»£ç å¦‚ä¸‹ï¼š`map`ç”¨æ¥è®°å½•å‰ç¼€å’Œ + å‡ºç°çš„æ¬¡æ•°

```go
func subarraySum(nums []int, k int) int {
    // ç”¨mapè®°å½•å‰ç¼€å’Œ + å‡ºç°æ¬¡æ•°

    m := make(map[int]int)

		// é»˜è®¤çš„å‰ç¼€å’Œ0ï¼Œå‡ºç°1æ¬¡
    nSum := 0
    m[nSum]++

    result := 0

    for i := 0;i < len(nums);i++ {
				// å½“å‰çš„å‰ç¼€å’Œx
        nSum += nums[i] 
				// å‰ç¼€å’Œx - target = å‰ç¼€å’ŒYï¼Œåœ¨ mä¸­æŸ¥æ‰¾Yå‡ºç°çš„æ¬¡æ•°
        result += m[nSum-k]

        // ç´¯ç§¯å‰ç¼€å’Œxå‡ºç°çš„æ¬¡æ•°
        m[nSum]++
    }

    return result
}
```
## 24. ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹
ç»™ä½ ä¸€ä¸ªé“¾è¡¨ï¼Œä¸¤ä¸¤äº¤æ¢å…¶ä¸­ç›¸é‚»çš„èŠ‚ç‚¹ï¼Œå¹¶è¿”å›äº¤æ¢åé“¾è¡¨çš„å¤´èŠ‚ç‚¹ã€‚ä½ å¿…é¡»åœ¨ä¸ä¿®æ”¹èŠ‚ç‚¹å†…éƒ¨çš„å€¼çš„æƒ…å†µä¸‹å®Œæˆæœ¬é¢˜ï¼ˆå³ï¼Œåªèƒ½è¿›è¡ŒèŠ‚ç‚¹äº¤æ¢ï¼‰ã€‚
æ€è·¯ï¼š
è¿™é¢˜æ˜¯ `25. Kä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨`çš„ç‰¹ä¾‹é¢˜å‹ï¼Œå³ ä¸¤ä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨

- æ˜ç¡®é€’å½’å‡½æ•°çš„å®šä¹‰ï¼š**swapPairså‡½æ•°å®šä¹‰ï¼šå¯¹é“¾è¡¨è¿›è¡Œä¸¤ä¸¤èŠ‚ç‚¹ç¿»è½¬ï¼Œå¹¶è¿”å›å¤´èŠ‚ç‚¹**
- åœ¨é€’å½’å‡½æ•°å†…éƒ¨ï¼Œå…ˆé’ˆå¯¹ä¸€å°æ®µé“¾è¡¨ï¼ˆ2ä¸ªèŠ‚ç‚¹çš„é“¾è¡¨ï¼‰è¿›è¡Œç¿»è½¬ï¼Œå°†ç¿»è½¬åçš„é“¾è¡¨ï¼Œæ‹¼æ¥ä¸Šé€šè¿‡é€’å½’å‡½æ•°`swapParis`ç¿»è½¬çš„é“¾è¡¨çš„å¤´èŠ‚ç‚¹![4b238dbc-90c8-4a30-a4d2-eb64581d5923.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411712263-4b238dbc-90c8-4a30-a4d2-eb64581d5923.png)


```go
// swapPairså‡½æ•°å®šä¹‰ï¼šç¿»è½¬ä»¥head ä¸ºå¤´èŠ‚ç‚¹çš„é“¾è¡¨ï¼Œå¹¶è¿”å›ç¿»è½¬åçš„å¤´èŠ‚ç‚¹
func swapPairs(head *ListNode) *ListNode {
  	// æˆªå–ä¸€å°æ®µé“¾è¡¨
    a,b := head,head
    for i := 0;i < 2;i++ {
        if b == nil {
            return a
        }
        b = b.Next
    }
		// å¯¹è¿™æ®µé“¾è¡¨è¿›è¡Œç¿»è½¬
    last := reverse(a,b)
  	// å°†ç¿»è½¬åçš„å°¾éƒ¨èŠ‚ç‚¹aæ‹¼æ¥ä¸Šï¼Œ swapPairs(b) ç¿»è½¬åçš„å¤´èŠ‚ç‚¹
    a.Next = swapPairs(b)
    return last
}


func reverse(a *ListNode, b *ListNode) *ListNode {
    
    var pre *ListNode = nil 
    for a != b {
        temp := a.Next

        a.Next = pre
        pre = a

        a = temp
    }
    return pre
}
```
## 283. ç§»åŠ¨é›¶
ç»™å®šä¸€ä¸ªæ•°ç»„ `nums`ï¼Œç¼–å†™ä¸€ä¸ªå‡½æ•°å°†æ‰€æœ‰ `0` ç§»åŠ¨åˆ°æ•°ç»„çš„æœ«å°¾ï¼ŒåŒæ—¶ä¿æŒéé›¶å…ƒç´ çš„ç›¸å¯¹é¡ºåºã€‚
**è¯·æ³¨æ„** ï¼Œå¿…é¡»åœ¨ä¸å¤åˆ¶æ•°ç»„çš„æƒ…å†µä¸‹åŸåœ°å¯¹æ•°ç»„è¿›è¡Œæ“ä½œã€‚
æ€è·¯ï¼š
åˆ©ç”¨åŒæŒ‡é’ˆï¼Œ`slow`æŒ‡å‘å¾…å­˜å‚¨å…ƒç´ çš„ä½ç½®ï¼Œ`fast`è´Ÿè´£éå†æ‰€æœ‰çš„å…ƒç´ ï¼ˆæŸ¥çœ‹æ‰€æœ‰çš„å…ƒç´ ï¼‰
å½“ `fast`æŒ‡å‘çš„å…ƒç´ ä¸ä¸º`0`çš„æ—¶å€™ï¼Œä¿å­˜åˆ°`slow`æŒ‡å‘çš„å­˜å‚¨ä½ç½®

```go
func moveZeroes(nums []int)  {

    slow , fast := 0,0
    for fast < len(nums) {
        if nums[fast] != 0 {
            nums[slow],nums[fast] = nums[fast],nums[slow]
            slow++
        }
        fast++
    }
}
```
è¿™é¢˜å’Œ **[905. æŒ‰å¥‡å¶æ’åˆ—æ•°ç»„](https://leetcode.cn/problems/sort-array-by-parity/)**æ˜¯ä¸€æ ·çš„è§£é¢˜æ–¹æ¡ˆã€‚
ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums`ï¼Œå°† `nums` ä¸­çš„çš„æ‰€æœ‰å¶æ•°å…ƒç´ ç§»åŠ¨åˆ°æ•°ç»„çš„å‰é¢ï¼Œåè·Ÿæ‰€æœ‰å¥‡æ•°å…ƒç´ ã€‚è¿”å›æ»¡è¶³æ­¤æ¡ä»¶çš„ **ä»»ä¸€æ•°ç»„** ä½œä¸ºç­”æ¡ˆã€‚
æ€è·¯ï¼š
åŒæŒ‡é’ˆæ–¹æ¡ˆï¼š`slow`æŒ‡å‘å¾…å­˜å‚¨å…ƒç´ çš„ä½ç½®ï¼Œ`fast`è´Ÿè´£éå†æ‰€æœ‰çš„å…ƒç´ ï¼ˆæŸ¥çœ‹æ‰€æœ‰çš„å…ƒç´ ï¼‰ã€‚å½“ `fast`æŒ‡å‘çš„å…ƒç´ ä¸ºå¶æ•°çš„æ—¶å€™ï¼Œä¿å­˜åˆ°`slow`æŒ‡å‘çš„å­˜å‚¨ä½ç½®ã€‚

```go
func sortArrayByParity(nums []int) []int {
    slow,fast := 0,0
    // ç±»ä¼¼äºï¼Œ283. ç§»åŠ¨é›¶ äº¤æ¢ 0 å’Œ >0çš„æ•°å­—ï¼Œè®©0éƒ½æ”¾åˆ°å°¾éƒ¨
    for fast < len(nums) {
        if nums[fast] % 2 == 0 { // å¶æ•°
            nums[slow],nums[fast] = nums[fast],nums[slow]
            slow++
        }
        fast++
    }
    return nums
}

//è¿™æ˜¯å¦å¤–ä¸€ç§æ–¹æ¡ˆï¼ˆæœ‰ç‚¹ç±»ä¼¼äºå¿«é€Ÿæ’åºä¸­çš„ä¸€ç‚¹ç‚¹é€»è¾‘ï¼‰ï¼šå®šä¹‰ left right æŒ‡é’ˆåˆ†åˆ«æŒ‡å‘æ•°ç»„çš„ä¸¤ç«¯
func sortArrayByParity(nums []int) []int { 

    left,right := 0,len(nums)-1
		// ä¿è¯ä»[0...left]èŒƒå›´éƒ½æ˜¯å¶æ•°å…ƒç´ 
  	// ä¿è¯ä» [right...len(nums)-1]èŒƒå›´çš„éƒ½æ˜¯å¥‡æ•°å…ƒç´ 
    for left < right {
        
        for left < right && nums[left] % 2 == 0 { // leftæŒ‡å‘å¶æ•°ï¼Œç›´åˆ°ç¢°åˆ°å¥‡æ•°åœæ­¢
            left++
        }

        for left < right && nums[right] % 2 != 0 { // rightæŒ‡å‘å¥‡æ•°ï¼Œç›´åˆ°ç¢°åˆ°å¶æ•°åœæ­¢
            right--
        }

        if left >= right {
            break
        }
				// äº¤æ¢ left rightæŒ‡å‘çš„å…ƒç´ 
        nums[left],nums[right] = nums[right],nums[left]
    }

    return nums
}
```
## 224. åŸºæœ¬è®¡ç®—å™¨
ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸²è¡¨è¾¾å¼ `s` ï¼Œè¯·ä½ å®ç°ä¸€ä¸ªåŸºæœ¬è®¡ç®—å™¨æ¥è®¡ç®—å¹¶è¿”å›å®ƒçš„å€¼ã€‚
æ³¨æ„:ä¸å…è®¸ä½¿ç”¨ä»»ä½•å°†å­—ç¬¦ä¸²ä½œä¸ºæ•°å­¦è¡¨è¾¾å¼è®¡ç®—çš„å†…ç½®å‡½æ•°ï¼Œæ¯”å¦‚ `eval()` ã€‚
æ€è·¯ï¼š
ä¸‹å›¾æ¼”ç¤ºäº†`1-(2+3)`çš„è®¡ç®—è¿‡ç¨‹ã€‚å»ºè®®è¾¹çœ‹ä»£ç ï¼Œè¾¹çœ‹å›¾ç‰‡ï¼Œç†è§£æ•´ä¸ªè¿‡ç¨‹
![50a33450-916f-48d4-bbf9-93c4af2ae19f.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411712678-50a33450-916f-48d4-bbf9-93c4af2ae19f.png)

![7e852e81-d580-4110-828e-d08469686c52.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411712837-7e852e81-d580-4110-828e-d08469686c52.png)


```go
func calculate(s string) int {
    // ä¾‹å¦‚ï¼š 1 + (2 + 3 )

    n := len(s)
    index := 0
    
    sign := 1 // é»˜è®¤çš„ç¬¦å·
    res := 0  // é»˜è®¤ç»“æœ

    // è®°å½•æ‹¬å·å¤–é¢ï¼Œä¸Šæ¬¡çš„ç»“æœ å’Œ ç¬¦å·
    resStack := []int{}
    signStack := []int{}
		
  	// index ç”¨æ¥éå†æ¯ä¸€ä¸ªå­—ç¬¦
    for index < n {
       
        if isDigit(s[index]) { // æ•°å­—
            num := 0
          	// è¿ç»­å–å‡ºå¤šä¸ªæ•°å­—
            for index < n && isDigit(s[index]) {
                num = num * 10 + int(s[index] - '0')
                index++
            }
            // ç¬¦å·*numï¼Œä¿å­˜åˆ°resä¸­
            res += sign * num
            
        } else if s[index] == '+' { // è®°å½•ç¬¦å· +
            sign = 1
            index++
        } else if s[index] == '-' { // è®°å½•ç¬¦å· -
            sign = -1
            index++
        } else if s[index] == '(' { // ä¿å­˜æ‹¬å·å¤–çš„ ç»“æœres å’Œ ç¬¦å·sign
            resStack = append(resStack,res)
            signStack = append(signStack,sign)

            // é‡ç½®
            res = 0 
            sign = 1
            index++
        } else if s[index] == ')' { // é‡åˆ° ï¼‰ è¯´æ˜ æ‹¬å·å†…è®¡ç®—ç»“æŸäº†
            // å¼¹å‡ºä¸Šæ¬¡çš„ç»“æœ
            preRes := resStack[len(resStack)-1]
            // å¼¹å‡ºä¸Šæ¬¡çš„ç¬¦å· 
            preSign := signStack[len(signStack)-1] 
            // ä¾‹å¦‚ï¼š 1+ï¼ˆ2+3ï¼‰èŒƒä¾‹ï¼Œ preRes = 1  presign = 1   res = 5
            res = preRes + preSign * res
            // æ¸…ç†
            resStack = resStack[:len(resStack)-1]
            signStack = signStack[:len(signStack)-1]

            index++
        } else if s[index] == ' ' {
            index++
        }
    }
    return res
}

func isDigit(c byte) bool{

    if c >= '0' && c <= '9' {
        return true
    }
    return false
}
```
## 739. æ¯æ—¥æ¸©åº¦
ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ `temperatures` ï¼Œè¡¨ç¤ºæ¯å¤©çš„æ¸©åº¦ï¼Œè¿”å›ä¸€ä¸ªæ•°ç»„ `answer` ï¼Œå…¶ä¸­ `answer[i]` æ˜¯æŒ‡å¯¹äºç¬¬ `i` å¤©ï¼Œä¸‹ä¸€ä¸ªæ›´é«˜æ¸©åº¦å‡ºç°åœ¨å‡ å¤©åã€‚å¦‚æœæ°”æ¸©åœ¨è¿™ä¹‹åéƒ½ä¸ä¼šå‡é«˜ï¼Œè¯·åœ¨è¯¥ä½ç½®ç”¨ `0` æ¥ä»£æ›¿ã€‚
æ€è·¯ï¼š
åˆ©ç”¨å•è°ƒæ ˆè®°å½•æ•°ç»„`temperatures`çš„ç´¢å¼•ï¼Œæ¯æ¥ä¸€ä¸ªæ–°å…ƒç´ ï¼Œéƒ½å’Œæ ˆé¡¶å…ƒç´ è¿›è¡Œå¯¹æ¯”ï¼Œå¦‚æœæ ˆé¡¶å…ƒç´ å°ï¼Œå¼¹å‡ºï¼ˆç›´åˆ°ä¸ç¬¦åˆè§„åˆ™ï¼‰

```go
func dailyTemperatures(temperatures []int) []int {
     // å•è°ƒæ ˆ
     sk := make([]int,0) // ä¿å­˜ç´¢å¼•
     answer := make([]int,len(temperatures))

     for i := 0;i < len(temperatures);i++ {

        // æ ˆä¸ä¸ºç©º && å½“å‰çš„æ¸©åº¦ æ¯” æ ˆé¡¶ä¸­çš„æ¸©åº¦å¤§
         for len(sk) != 0 && temperatures[i] > temperatures[sk[len(sk)-1]]  {
             answer[sk[len(sk)-1]] = i - sk[len(sk)-1]

             // å‡ºæ ˆ 
             sk = sk[:len(sk)-1]
         }
         sk = append(sk,i) // è®°å½•ç´¢å¼•
     }
     return answer
}
```
## 153. å¯»æ‰¾æ—‹è½¬æ’åºæ•°ç»„ä¸­çš„æœ€å°å€¼
å·²çŸ¥ä¸€ä¸ªé•¿åº¦ä¸º `n` çš„æ•°ç»„ï¼Œé¢„å…ˆæŒ‰ç…§å‡åºæ’åˆ—ï¼Œç»ç”± `1` åˆ° `n` æ¬¡ **æ—‹è½¬** åï¼Œå¾—åˆ°è¾“å…¥æ•°ç»„ã€‚ä¾‹å¦‚ï¼ŒåŸæ•°ç»„ `nums = [0,1,2,4,5,6,7]` åœ¨å˜åŒ–åå¯èƒ½å¾—åˆ°ï¼š

- è‹¥æ—‹è½¬ `4` æ¬¡ï¼Œåˆ™å¯ä»¥å¾—åˆ° `[4,5,6,7,0,1,2]`
- è‹¥æ—‹è½¬ `7` æ¬¡ï¼Œåˆ™å¯ä»¥å¾—åˆ° `[0,1,2,4,5,6,7]`æ³¨æ„ï¼Œæ•°ç»„ `[a[0], a[1], a[2], ..., a[n-1]]`**æ—‹è½¬ä¸€æ¬¡** çš„ç»“æœä¸ºæ•°ç»„ `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` ã€‚
ç»™ä½ ä¸€ä¸ªå…ƒç´ å€¼ **äº’ä¸ç›¸åŒ** çš„æ•°ç»„ `nums` ï¼Œå®ƒåŸæ¥æ˜¯ä¸€ä¸ªå‡åºæ’åˆ—çš„æ•°ç»„ï¼Œå¹¶æŒ‰ä¸Šè¿°æƒ…å½¢è¿›è¡Œäº†å¤šæ¬¡æ—‹è½¬ã€‚è¯·ä½ æ‰¾å‡ºå¹¶è¿”å›æ•°ç»„ä¸­çš„ **æœ€å°å…ƒç´ ** ã€‚
ä½ å¿…é¡»è®¾è®¡ä¸€ä¸ªæ—¶é—´å¤æ‚åº¦ä¸º `O(log n)` çš„ç®—æ³•è§£å†³æ­¤é—®é¢˜ã€‚

- `nums` ä¸­çš„æ‰€æœ‰æ•´æ•° **äº’ä¸ç›¸åŒ**æ€è·¯ï¼š
äºŒåˆ†æœç´¢ç®—æ³•ï¼Œæœ¬è´¨å°±æ˜¯å°†ä¸ç¬¦åˆé¢˜æ„çš„ç»“æœæœç´¢èŒƒå›´ï¼Œé€šè¿‡æ”¶ç¼©`left right`çš„æ–¹å¼ï¼Œä¸¢å¼ƒã€‚åªä¿ç•™ç¬¦åˆé¢˜æ„çš„æœç´¢èŒƒå›´`[left,right]`ï¼Œä¾›ä¸‹ä¸€æ¬¡äºŒåˆ†æœç´¢ã€‚
ç»“åˆå›¾ç‰‡ç†è§£ä»£ç 
![c8cc3e79-c56a-46c8-ac7e-4393d14b346f.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411712815-c8cc3e79-c56a-46c8-ac7e-4393d14b346f.png)

![2a1bc4c3-c98d-4348-b970-917c09c8c160.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411712745-2a1bc4c3-c98d-4348-b970-917c09c8c160.png)


```go
func findMin(nums []int) int {

    left, right := 0,len(nums)-1
    for left <= right {
        mid := left + (right - left)/2

        if nums[mid] > nums[right] { // è¯´æ˜æœ€å°å€¼åœ¨ å³è¾¹æ•°ç»„
            left = mid+1
        } else if nums[mid] < nums[right] {
            right = mid // mid å¯èƒ½å°±æ˜¯æœ€å°å€¼
        } else {
            return nums[mid]
        }
    }

    return -1
}
```
## 297. äºŒå‰æ ‘çš„åºåˆ—åŒ–å’Œååºåˆ—åŒ–
åºåˆ—åŒ–æ˜¯å°†ä¸€ä¸ªæ•°æ®ç»“æ„æˆ–è€…å¯¹è±¡è½¬æ¢ä¸ºè¿ç»­çš„æ¯”ç‰¹ä½çš„æ“ä½œï¼Œè¿›è€Œå¯ä»¥å°†è½¬æ¢åçš„æ•°æ®å­˜å‚¨åœ¨ä¸€ä¸ªæ–‡ä»¶æˆ–è€…å†…å­˜ä¸­ï¼ŒåŒæ—¶ä¹Ÿå¯ä»¥é€šè¿‡ç½‘ç»œä¼ è¾“åˆ°å¦ä¸€ä¸ªè®¡ç®—æœºç¯å¢ƒï¼Œé‡‡å–ç›¸åæ–¹å¼é‡æ„å¾—åˆ°åŸæ•°æ®ã€‚
è¯·è®¾è®¡ä¸€ä¸ªç®—æ³•æ¥å®ç°äºŒå‰æ ‘çš„åºåˆ—åŒ–ä¸ååºåˆ—åŒ–ã€‚è¿™é‡Œä¸é™å®šä½ çš„åºåˆ— / ååºåˆ—åŒ–ç®—æ³•æ‰§è¡Œé€»è¾‘ï¼Œä½ åªéœ€è¦ä¿è¯ä¸€ä¸ªäºŒå‰æ ‘å¯ä»¥è¢«åºåˆ—åŒ–ä¸ºä¸€ä¸ªå­—ç¬¦ä¸²å¹¶ä¸”å°†è¿™ä¸ªå­—ç¬¦ä¸²ååºåˆ—åŒ–ä¸ºåŸå§‹çš„æ ‘ç»“æ„ã€‚
æ€è·¯ï¼š
åºåˆ—åŒ–é—®é¢˜å…¶å®å°±æ˜¯éå†é—®é¢˜ï¼Œä½ èƒ½éå†ï¼Œé¡ºæ‰‹æŠŠéå†çš„ç»“æœè½¬åŒ–æˆå­—ç¬¦ä¸²çš„å½¢å¼ï¼Œä¸å°±æ˜¯åºåˆ—åŒ–äº†ä¹ˆï¼Ÿ
å‰åºéå†çš„ç‰¹ç‚¹æ˜¯æ ¹èŠ‚ç‚¹åœ¨å¼€å¤´ï¼Œç„¶åæ¥ç€å·¦å­æ ‘çš„å‰åºéå†ç»“æœï¼Œç„¶åæ¥ç€å³å­æ ‘çš„å‰åºéå†ç»“æœï¼š
![06028e21-2b68-495c-91b2-d80faf2526d6.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411713400-06028e21-2b68-495c-91b2-d80faf2526d6.png)

æ‰€ä»¥å¦‚æœæŒ‰ç…§å‰åºéå†é¡ºåºè¿›è¡Œååºåˆ—åŒ–çš„æ—¶å€™ï¼Œå°±çŸ¥é“ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯æ ¹èŠ‚ç‚¹çš„å€¼ï¼Œç„¶åé€’å½’è°ƒç”¨ååºåˆ—åŒ–å·¦å³å­æ ‘ï¼Œæ¥åˆ°æ ¹èŠ‚ç‚¹ä¸Šå³å¯ï¼Œä¸Šè¿°æ€è·¯ç¿»è¯‘æˆä»£ç å³å¯è§£å†³æœ¬é¢˜ã€‚

```go
type Codec struct {
    index int
    data []string
}

func Constructor() Codec {
    return Codec{}
    
}

// å‰åºéå†ï¼ˆåºåˆ—åŒ–ï¼‰
func (this *Codec) serialize(root *TreeNode) string {
    if root == nil {
        return "nil"
    }
  	// åˆ©ç”¨ "," åˆ†å‰²
    return strconv.Itoa(root.Val)+","+ this.serialize(root.Left) +","+this.serialize(root.Right)
}

//ååºåˆ—åŒ–
func (this *Codec) deserialize(data string) *TreeNode {    
  	// åˆå§‹åŒ– indexå€¼
    this.index = 0
  	// æ‹†åˆ†å­—ç¬¦ä¸²
    this.data = strings.Split(data,",")
    return this.deser()
}

func (this *Codec)deser() *TreeNode {
  	// è¶Šç•Œè¿”å› nil
    if this.index >= len(this.data) {
        return nil
    }
  	
    val := this.data[this.index] //ä»å¤´åˆ°å°¾ï¼Œé€’å½’éå†this.dataåˆ‡ç‰‡
    this.index++
    if val == "nil" { // å¦‚æœæ˜¯nilå­—ç¬¦ä¸²ï¼Œè¿”å›nil
        return nil
    }  
		
  	// è¯´æ˜æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„èŠ‚ç‚¹å€¼
    v ,_ := strconv.Atoi(val)
		
    root := &TreeNode{Val:v,Left:nil,Right:nil} //æ„é€ TreeNodeæ ¹èŠ‚ç‚¹
    root.Left = this.deser() //ååºåˆ—åŒ–ï¼Œæ„é€ å·¦èŠ‚ç‚¹
    root.Right = this.deser() //ååºåˆ—åŒ–ï¼Œæ„é€ å³èŠ‚ç‚¹
    return root
}
```
## 468. éªŒè¯IPåœ°å€
ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² `queryIP`ã€‚å¦‚æœæ˜¯æœ‰æ•ˆçš„ IPv4 åœ°å€ï¼Œè¿”å› `"IPv4"` ï¼›å¦‚æœæ˜¯æœ‰æ•ˆçš„ IPv6 åœ°å€ï¼Œè¿”å› `"IPv6"` ï¼›å¦‚æœä¸æ˜¯ä¸Šè¿°ç±»å‹çš„ IP åœ°å€ï¼Œè¿”å› `"Neither"` ã€‚
**æœ‰æ•ˆçš„IPv4åœ°å€** æ˜¯ `â€œx1.x2.x3.x4â€` å½¢å¼çš„IPåœ°å€ã€‚ å…¶ä¸­ `0 <= xi <= 255` ä¸” `xi`**ä¸èƒ½åŒ…å«** å‰å¯¼é›¶ã€‚ä¾‹å¦‚: `â€œ192.168.1.1â€` ã€ `â€œ192.168.1.0â€` ä¸ºæœ‰æ•ˆIPv4åœ°å€ï¼Œ `â€œ192.168.01.1â€` ä¸ºæ— æ•ˆIPv4åœ°å€; `â€œ192.168.1.00â€` ã€ `â€œ192.168@1.1â€` ä¸ºæ— æ•ˆIPv4åœ°å€ã€‚
**ä¸€ä¸ªæœ‰æ•ˆçš„IPv6åœ°å€** æ˜¯ä¸€ä¸ªæ ¼å¼ä¸º`â€œx1:x2:x3:x4:x5:x6:x7:x8â€` çš„IPåœ°å€ï¼Œå…¶ä¸­:

- `1 <= xi.length <= 4`
- `xi` æ˜¯ä¸€ä¸ª **åå…­è¿›åˆ¶å­—ç¬¦ä¸²** ï¼Œå¯ä»¥åŒ…å«æ•°å­—ã€å°å†™è‹±æ–‡å­—æ¯( `'a'` åˆ° `'f'` )å’Œå¤§å†™è‹±æ–‡å­—æ¯( `'A'` åˆ° `'F'` )ã€‚
- åœ¨ `xi` ä¸­å…è®¸å‰å¯¼é›¶ã€‚ä¾‹å¦‚ `"2001:0db8:85a3:0000:0000:8a2e:0370:7334"` å’Œ `"2001:db8:85a3:0:0:8A2E:0370:7334"` æ˜¯æœ‰æ•ˆçš„ IPv6 åœ°å€ï¼Œè€Œ `"2001:0db8:85a3::8A2E:037j:7334"` å’Œ `"02001:0db8:85a3:0000:0000:8a2e:0370:7334"` æ˜¯æ— æ•ˆçš„ IPv6 åœ°å€ã€‚
æ€è·¯ï¼š
è¿™é¢˜æ²¡æœ‰æŠ€å·§ï¼Œå°±æ˜¯å¯¹æ•´ä¸ªå­—ç¬¦ä¸²ï¼ŒæŒ‰ç…§é¢˜ç›®è¦æ±‚çš„æ ¼å¼ï¼Œè¿›è¡ŒéªŒè¯å³å¯

```go
func validIPAddress(queryIP string) string {
    // 1. åˆ¤æ–­æ˜¯ip4 ip6
    isIp4,isIp6 :=  strings.Contains(queryIP,"."),strings.Contains(queryIP,":")
    // 2.ip4 åˆ†æˆ4ä»½ï¼Œæ¯ä»½çš„æ•°å€¼å¤§å°ä¸º [0,255],ä¸èƒ½æœ‰å‰å¯¼0

    if isIp4 && !isIp6 && ip4Check(queryIP) {
        return "IPv4"
    }

    // 3.ip6 åˆ†æˆ8ä»½ï¼Œæ¯ä»½é•¿åº¦ä¸º[1,4]ï¼Œæ˜¯ä¸€ä¸ª16è¿›åˆ¶æ•°å­—
    if !isIp4 && isIp6 && ip6Check(queryIP) {
        return "IPv6"
    }

    return "Neither"
}

func ip4Check(queryIP string) bool {
    if ipSlice := strings.Split(queryIP,"."); len(ipSlice) == 4 { // 4ä»½
        // å¯¹æ¯ä¸ªç‰‡æ®µè¿›è¡Œ æ£€æŸ¥
        for _, val := range ipSlice {
            // å­—ç¬¦ä¸²é•¿åº¦ å¤§äº3 ç­‰äº 0 æ— æ•ˆï¼Œå‰©ä¸‹ 1 2 3èŒƒå›´çš„é•¿åº¦ï¼Œå¦‚æœé•¿åº¦å¤§äº1ï¼Œè¡¨ç¤ºæœ‰2ä½or3ä½æ•°å­—ï¼Œé‚£ä¹ˆä¸èƒ½æœ‰å‰å¯¼0
            if len(val) > 3 || len(val) == 0 || (len(val) > 1 && val[0] == '0') {
                return false
            }
            // æ•°å€¼éœ€è¦ <= 255
            if v ,err := strconv.Atoi(val);err != nil || v > 255 {
                return false
            }
        }
        return true
    }
    return false
}


func ip6Check(queryIP string) bool {
    if ipSlice := strings.Split(queryIP,":"); len(ipSlice) == 8 {// 8ä»½

        for _, val := range ipSlice {
          	// é•¿åº¦åœ¨[1~4]ä¹‹é—´
            if len(val) < 1 || len(val) > 4 {
                return false
            }
            // å°†16è¿›åˆ¶æ•°å­—ï¼Œè½¬æ¢æˆ64ä½çš„æ•´æ•°ï¼ˆèƒ½è½¬æˆï¼Œè¯´æ˜æ˜¯æœ‰æ•ˆçš„16è¿›åˆ¶æ•°å­—ï¼‰
            if _,err:=strconv.ParseUint(val,16,64);err != nil {
                return false
            }
        }
        return true
    }
    return false
}
```
## 460. LFUç¼“å­˜
è¯·ä½ ä¸º [æœ€ä¸ç»å¸¸ä½¿ç”¨ï¼ˆLFUï¼‰](https://baike.baidu.com/item/%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95)ç¼“å­˜ç®—æ³•è®¾è®¡å¹¶å®ç°æ•°æ®ç»“æ„ã€‚
å®ç° `LFUCache` ç±»ï¼š

- `LFUCache(int capacity)` - ç”¨æ•°æ®ç»“æ„çš„å®¹é‡ `capacity` åˆå§‹åŒ–å¯¹è±¡
- `int get(int key)` - å¦‚æœé”® `key` å­˜åœ¨äºç¼“å­˜ä¸­ï¼Œåˆ™è·å–é”®çš„å€¼ï¼Œå¦åˆ™è¿”å› `-1` ã€‚
- `void put(int key, int value)` - å¦‚æœé”® `key` å·²å­˜åœ¨ï¼Œåˆ™å˜æ›´å…¶å€¼ï¼›å¦‚æœé”®ä¸å­˜åœ¨ï¼Œè¯·æ’å…¥é”®å€¼å¯¹ã€‚å½“ç¼“å­˜è¾¾åˆ°å…¶å®¹é‡ `capacity` æ—¶ï¼Œåˆ™åº”è¯¥åœ¨æ’å…¥æ–°é¡¹ä¹‹å‰ï¼Œç§»é™¤æœ€ä¸ç»å¸¸ä½¿ç”¨çš„é¡¹ã€‚åœ¨æ­¤é—®é¢˜ä¸­ï¼Œå½“å­˜åœ¨å¹³å±€ï¼ˆå³ä¸¤ä¸ªæˆ–æ›´å¤šä¸ªé”®å…·æœ‰ç›¸åŒä½¿ç”¨é¢‘ç‡ï¼‰æ—¶ï¼Œåº”è¯¥å»é™¤ **æœ€ä¹…æœªä½¿ç”¨** çš„é”®ã€‚ä¸ºäº†ç¡®å®šæœ€ä¸å¸¸ä½¿ç”¨çš„é”®ï¼Œå¯ä»¥ä¸ºç¼“å­˜ä¸­çš„æ¯ä¸ªé”®ç»´æŠ¤ä¸€ä¸ª **ä½¿ç”¨è®¡æ•°å™¨** ã€‚ä½¿ç”¨è®¡æ•°æœ€å°çš„é”®æ˜¯æœ€ä¹…æœªä½¿ç”¨çš„é”®ã€‚
å½“ä¸€ä¸ªé”®é¦–æ¬¡æ’å…¥åˆ°ç¼“å­˜ä¸­æ—¶ï¼Œå®ƒçš„ä½¿ç”¨è®¡æ•°å™¨è¢«è®¾ç½®ä¸º `1` (ç”±äº put æ“ä½œ)ã€‚å¯¹ç¼“å­˜ä¸­çš„é”®æ‰§è¡Œ `get` æˆ– `put` æ“ä½œï¼Œä½¿ç”¨è®¡æ•°å™¨çš„å€¼å°†ä¼šé€’å¢ã€‚
å‡½æ•° `get` å’Œ `put` å¿…é¡»ä»¥ `O(1)` çš„å¹³å‡æ—¶é—´å¤æ‚åº¦è¿è¡Œã€‚
æ€è·¯ï¼š
æ€»ç»“ä¸‹é¢˜ç›®çš„è¦æ±‚ï¼š
1ã€è°ƒç”¨ `get(key)` æ–¹æ³•æ—¶ï¼Œè¦è¿”å›è¯¥ `key` å¯¹åº”çš„ `val`ã€‚
2ã€åªè¦ç”¨ `get` æˆ–è€… `put` æ–¹æ³•è®¿é—®ä¸€æ¬¡æŸä¸ª `key`ï¼Œè¯¥ `key` çš„ `freq` å°±è¦åŠ ä¸€ã€‚
3ã€å¦‚æœåœ¨å®¹é‡æ»¡äº†çš„æ—¶å€™è¿›è¡Œæ’å…¥ï¼Œåˆ™éœ€è¦å°† `freq` æœ€å°çš„ `key` åˆ é™¤ï¼Œå¦‚æœæœ€å°çš„ `freq` å¯¹åº”å¤šä¸ª `key`ï¼Œåˆ™åˆ é™¤å…¶ä¸­æœ€æ—§çš„é‚£ä¸€ä¸ªã€‚
![2ba4062e-5146-41a7-b4a9-61ad1805b1c3.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411713713-2ba4062e-5146-41a7-b4a9-61ad1805b1c3.png)

å»ºè®®è¾¹çœ‹ä»£ç ï¼Œè¾¹å‚è€ƒä¸Šå›¾ã€‚ä»£ç ä¸éš¾ï¼Œå°±æ˜¯ç»†èŠ‚å¾ˆå¤š**å¾ˆç»†ç»†ç»†ç»†ç»†ç»†ç»†ç»†ç»†**

```go
type Data struct {
    val int // å€¼

    // freqè®°å½•é¢‘ç‡ï¼Œ
    freq int
    // ele è®°å½•åœ¨freqé¢‘ç‡ä¸‹ï¼Œé“¾è¡¨ä¸­çš„èŠ‚ç‚¹
    ele *list.Element
}


type LFUCache struct {
    keyToData map[int]Data // key æ˜ å°„ Data

    freqToKey map[int]*list.List  // é¢‘ç‡freqæ˜ å°„keyï¼Œç›®çš„åœ¨äºè®°å½•ç›¸åŒé¢‘ç‡çš„keyå…ˆæ¥ååˆ°é¡ºåºï¼Œæ–¹ä¾¿åˆ é™¤æœ€æ—©çš„keyï¼ˆæŒ‰ç…§æ­£å¸¸æƒ…å†µä¸‹ï¼Œåœ¨å‡ºç°é¢‘ç‡ç›¸åŒçš„æƒ…å†µä¸‹ï¼Œåˆ é™¤è®¿é—®æ—¶é—´æœ€æ—©çš„keyï¼Œè¿™é‡Œæ²¡æœ‰ç”¨æ—¶é—´æˆ³ï¼Œè€Œæ˜¯ç”¨ä¸€ä¸ªåˆ—è¡¨ï¼Œå› ä¸ºé“¾è¡¨å­˜æ”¾é¡ºåºï¼Œå°±æœ‰æ—¶é—´çš„å«ä¹‰ï¼‰
    cap int // å®¹é‡
    minFreq int // å§‹ç»ˆæŒ‡å‘æœ€å°é¢‘ç‡ï¼Œé€šè¿‡freqToKeyï¼Œæ‰¾åˆ°æœ€æ—©çš„keyï¼Œç„¶ååˆ é™¤ï¼ˆç›®çš„åœ¨äºåˆ é™¤ï¼‰
}


func Constructor(capacity int) LFUCache {
  	// åˆå§‹åŒ–
    return LFUCache{
        keyToData : make(map[int]Data),
        freqToKey : make(map[int]*list.List),
        cap :capacity,
        minFreq : 0,
    }
}


func (this *LFUCache) Get(key int) int {
  	// å¦‚æœkeyå­˜åœ¨
    if data ,ok := this.keyToData[key];ok {
        this.increaseFreq(key) // å‡é¢‘
        return data.val // è¿”å›æ•°æ®
    }
    return -1
}

/*
increaseFreq æœ¬å‡½æ•°æ‰§è¡Œä¸¤ä»¶äº‹æƒ…ï¼š
ç¬¬ä¸€ä¸ªï¼Œç”¨ freq æ‰¾åˆ°æ—§é“¾è¡¨ï¼Œå¹¶åˆ é™¤èŠ‚ç‚¹ï¼ˆé¢å¤–æ³¨æ„ï¼šå¦‚æœfreq == minFreq å°†æœ€å°é¢‘ç‡+1ï¼‰
ç¬¬äºŒä¸ªï¼Œå°† freq++ æ‰¾åˆ°æ–°é“¾è¡¨ï¼Œå¹¶æ–°å¢èŠ‚ç‚¹
*/
func (this *LFUCache)increaseFreq(key int) {
  	//1.å…ˆå–å‡ºæºæ•°æ®
    data := this.keyToData[key] 

    //2.é€šè¿‡é¢‘ç‡ï¼Œæ‰¾åˆ°é“¾è¡¨ï¼Œç„¶åä»é“¾è¡¨ä¸­åˆ é™¤èŠ‚ç‚¹
    l := this.freqToKey[data.freq]
    l.Remove(data.ele)

  	if l.Len() == 0 { // å¦‚æœé“¾è¡¨ä¸ºç©ºï¼Œè¯´æ˜é“¾è¡¨ä¸­æ²¡æœ‰æ•°æ®äº†
        delete(this.freqToKey,data.freq) // é‡Šæ”¾ï¼ˆèŠ‚çº¦å†…å­˜ï¼‰
        if data.freq == this.minFreq { // å¦‚æœé¢‘ç‡æ°å¥½å’Œæœ€å°é¢‘ç‡ç›¸åŒï¼ˆè¯´æ˜æœ€å°çš„é¢‘ç‡å·²ç»è¢«åˆ é™¤äº†ï¼Œæœ€å°é¢‘ç‡å‡é¢‘ä¸ºæ¬¡å°é¢‘ç‡ï¼‰
            this.minFreq++
        }
    }

    //3.åŠ å…¥æ–°çš„åˆ—è¡¨
    data.freq += 1 // é¢‘ç‡+1
    if _,ok := this.freqToKey[data.freq];!ok{ //æ–°é¢‘ç‡å¯¹åº”çš„é“¾è¡¨ä¸å­˜åœ¨
        this.freqToKey[data.freq] = list.New() // åˆ›å»ºé“¾è¡¨
    }
    data.ele = this.freqToKey[data.freq].PushBack(key) // å°†keyåŠ å…¥é“¾è¡¨ï¼Œè¿”å›èŠ‚ç‚¹ï¼Œä¿å­˜åœ¨dataä¸­
    this.keyToData[key] = data // ä¿®æ”¹keyToDataä¸­çš„æ•°æ®
}

func (this *LFUCache) Put(key int, value int)  {
    if this.cap <= 0 {
        return
    }

    // 1. åˆ¤æ–­keyæ˜¯å¦å­˜åœ¨
    if _,ok := this.keyToData[key];ok {
        //2. keyå­˜åœ¨ï¼Œkeyå¯¹åº”çš„é¢‘ç‡+1
        this.increaseFreq(key)
        // æ›´æ–°keyçš„val
        data := this.keyToData[key]
        data.val = value
        this.keyToData[key] = data
        return
    }

    //2.key ä¸å­˜åœ¨
    if len(this.keyToData) >= this.cap { //å®¹é‡è¶…è¿‡é¢„æœŸï¼Œå…ˆåˆ é™¤ä¸€ä¸ª
        this.removeKey()
    }

    //3. ã€æ–°ã€‘æ’å…¥ï¼šé¢‘ç‡è‚¯å®šæ˜¯1

    data := Data{val:value,freq:1} // æ•°å€¼ + é¢‘ç‡
    if _,ok := this.freqToKey[1];!ok {
        this.freqToKey[1] = list.New()
    }
    data.ele = this.freqToKey[1].PushBack(key) // å¯¹åº”é“¾è¡¨ä¸­çš„å…ƒç´ 
    this.keyToData[key] = data
    this.minFreq = 1 // æ³¨æ„ï¼šæœ€å°é¢‘ç‡å˜æˆ1
}

func (this *LFUCache)removeMinFreqKey() {
    l := this.freqToKey[this.minFreq] // æ‰¾åˆ°æœ€å°é¢‘ç‡é“¾è¡¨

    deletedKey := l.Remove(l.Front()) // åˆ é™¤é“¾è¡¨çš„é¦–éƒ¨ï¼ˆå› ä¸ºæœ€æ–°çš„æ•°æ®éƒ½æ˜¯ç›´æ¥æ”¾å…¥åˆ°å°¾éƒ¨ PushBack(keyï¼‰ ï¼‰
    if l.Len() == 0 {
        delete(this.freqToKey,this.minFreq)
      	// this.minFreq++ // è¿™é‡Œè¿™ä¸ªå†™ä¸å†™éƒ½æ— æ‰€è°“ï¼Œå½“è¦æ–°å¢èŠ‚ç‚¹çš„æ—¶å€™ï¼Œä¸€å®šæ˜¯å› ä¸ºå®¹é‡ä¸è¶³ï¼Œæ‰æ‰§è¡Œçš„å‡½æ•°ã€‚å½“åç»­æ–°å¢èŠ‚ç‚¹çš„æ˜¯æ—¶å€™ï¼ŒèŠ‚ç‚¹æ˜¯ç¬¬ä¸€æ¬¡åŠ å…¥ï¼Œ this.minFreqä¼šè¢«è®¾å®šä¸º1
    }
    delete(this.keyToData,deletedKey.(int)) // åˆ é™¤keyå¯¹åº”çš„æ•°å€¼
}
```
## 207. è¯¾ç¨‹è¡¨
ä½ è¿™ä¸ªå­¦æœŸå¿…é¡»é€‰ä¿® `numCourses` é—¨è¯¾ç¨‹ï¼Œè®°ä¸º `0` åˆ° `numCourses - 1` ã€‚
åœ¨é€‰ä¿®æŸäº›è¯¾ç¨‹ä¹‹å‰éœ€è¦ä¸€äº›å…ˆä¿®è¯¾ç¨‹ã€‚ å…ˆä¿®è¯¾ç¨‹æŒ‰æ•°ç»„ `prerequisites` ç»™å‡ºï¼Œå…¶ä¸­ `prerequisites[i] = [ai, bi]` ï¼Œè¡¨ç¤ºå¦‚æœè¦å­¦ä¹ è¯¾ç¨‹ `ai` åˆ™ **å¿…é¡»** å…ˆå­¦ä¹ è¯¾ç¨‹ `bi` ã€‚

- ä¾‹å¦‚ï¼Œå…ˆä¿®è¯¾ç¨‹å¯¹ `[0, 1]` è¡¨ç¤ºï¼šæƒ³è¦å­¦ä¹ è¯¾ç¨‹ `0` ï¼Œä½ éœ€è¦å…ˆå®Œæˆè¯¾ç¨‹ `1` ã€‚è¯·ä½ åˆ¤æ–­æ˜¯å¦å¯èƒ½å®Œæˆæ‰€æœ‰è¯¾ç¨‹çš„å­¦ä¹ ï¼Ÿå¦‚æœå¯ä»¥ï¼Œè¿”å› `true` ï¼›å¦åˆ™ï¼Œè¿”å› `false` ã€‚
**ç¤ºä¾‹ 1ï¼š**

```go
è¾“å…¥ï¼šnumCourses = 2, prerequisites = [[1,0]]
è¾“å‡ºï¼štrue
è§£é‡Šï¼šæ€»å…±æœ‰ 2 é—¨è¯¾ç¨‹ã€‚å­¦ä¹ è¯¾ç¨‹ 1 ä¹‹å‰ï¼Œä½ éœ€è¦å®Œæˆè¯¾ç¨‹ 0 ã€‚è¿™æ˜¯å¯èƒ½çš„ã€‚
```
æ€è·¯ï¼š
æ¯”å¦‚ è¯¾ç¨‹1ä¾èµ–è¯¾ç¨‹2 è¯¾ç¨‹3ï¼Œè¯¾ç¨‹3åˆä¾èµ–è¯¾ç¨‹1ï¼Œè¿™æ ·å°±å½¢æˆäº†å¾ªç¯ä¾èµ–çš„å…³ç³»ã€‚è¯¾ç¨‹æ˜¯æ— æ³•å®Œæˆå­¦ä¹ çš„ã€‚
é€šè¿‡ä¸‹å›¾å¯ä»¥ç†è§£ `onPath`å˜é‡çš„æ„ä¹‰ï¼Œä»¥åŠæ•´ä¸ªæ£€æµ‹çš„å¯è§†åŒ–è¿‡ç¨‹ã€‚å»ºè®®è¾¹çœ‹ä»£ç è¾¹çœ‹å›¾ç†è§£
![e7771dcc-0e27-44ff-8ce5-74adf1c4253f.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411713483-e7771dcc-0e27-44ff-8ce5-74adf1c4253f.png)

![b3427765-64ad-499e-8669-1e7ac95f7174.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411713583-b3427765-64ad-499e-8669-1e7ac95f7174.png)

![7e83c582-599b-4631-acce-90aa83b33024.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411713977-7e83c582-599b-4631-acce-90aa83b33024.png)

![f53c96d1-2c1b-4af1-a554-c573182d6cc1.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411714177-f53c96d1-2c1b-4af1-a554-c573182d6cc1.png)


```go
var isCircle bool // è¡¨ç¤ºè¯¾ç¨‹æ˜¯å¦å­˜åœ¨å¾ªç¯ä¾èµ–
var visited []bool // è¡¨ç¤ºè¯¾ç¨‹å·²ç»åšè¿‡æ£€æŸ¥äº†ï¼Œä¸ç”¨é‡å¤æ£€æŸ¥
var onPath []bool  // æ ‡è®°è¯¾ç¨‹æ˜¯å¦æ­£åœ¨è¢«å ç”¨
func canFinish(numCourses int, prerequisites [][]int) bool {

    visited = make([]bool,numCourses)
    onPath = make([]bool,numCourses)

    isCircle = false
    //1.å…ˆæ„å»ºæœ‰å‘å›¾ï¼›ç”¨ä¸´æ¥è¡¨çš„æ–¹å¼
    graph := make([][]int,numCourses) // æ€»å…±æœ‰numCoursesä¸ªè¯¾ç¨‹ï¼Œgraphçš„ç›®çš„æ˜¯è®°å½•ä¸‹æ¯ä¸ªè¯¾ç¨‹ä¾èµ–çš„è¯¾ç¨‹åˆ—è¡¨

    for i := 0;i < len(prerequisites);i++ { // è¯¾ç¨‹prerequisites[i][0] ä¾èµ–äº è¯¾ç¨‹prerequisites[i][1] 
        graph[prerequisites[i][0]] = append(graph[prerequisites[i][0]],prerequisites[i][1])
    }

    // 2. éå†æœ‰å‘å›¾ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹ i ä» [0... numCoures-1] è¡¨ç¤ºæ¯ä¸ªè¯¾ç¨‹id
    for i := 0; i < numCourses;i++ { 
        dfs(graph,i) // ä» æ¯ä¸ªè¯¾ç¨‹ i å‡ºå‘ï¼Œæ£€æµ‹ä¾èµ–å…³ç³»
    }

    return !isCircle // æ²¡ç¯ï¼Œè¡¨ç¤ºå¯ä»¥å­¦ä¹ å®Œæ‰€æœ‰çš„è¯¾ç¨‹
}

// è¿™é‡Œçš„iå¯ä»¥ç†è§£ä¸ºè¯¾ç¨‹idï¼ˆå¯ä»¥ç†è§£æˆå‘å‘¨å›´ æ•£æ’­çš„æ„Ÿè§‰ï¼‰ï¼ŒonPathç”¨æ¥è®°å½•è¯¾ç¨‹å·²ç»è¢«å ä¸­äº†
func dfs(graph [][]int,i int) {
  	// ç°åœ¨è®¿é—®çš„è¯¾ç¨‹iï¼Œæ ‡è®°ä¸ºå ç”¨ä¸­ï¼Œè¯´æ˜è¯¾ç¨‹è¢«é‡å¤ä¾èµ–äº†ï¼ˆæ ‡è®°æœ‰ç¯ï¼‰
    if onPath[i] {
        isCircle = true
    }

    if visited[i] || isCircle { // è¯¾ç¨‹å·²ç»æ£€æµ‹è¿‡äº†ï¼Œæˆ–è€…å·²ç»å­˜åœ¨ç¯ï¼Œæ²¡å¿…è¦ç»§ç»­ä¸‹å»äº†ï¼Œå°½å¿«ç»“æŸ
        return
    }

    visited[i] = true // è¡¨ç¤ºè¯¾ç¨‹i å·²ç»æ£€æµ‹è¿‡äº†ï¼ˆæ²¡å¿…è¦é‡å¤æ£€æŸ¥äº†ï¼Œä¸ºäº†å‰ªæï¼ŒåŠ å¿«ç®—æ³•é€Ÿåº¦ï¼‰
    onPath[i] = true // æ ‡è®°è¯¾ç¨‹iè¢«å ç”¨äº†

    // ç»§ç»­å‘å‘¨å›´æ•£æ’­
    // çœ‹ä¸‹è¯¾ç¨‹i ä¾èµ–çš„è¯¾ç¨‹åˆ—è¡¨graph[i]
    for j := 0;j < len(graph[i]);j++ { // i ä¸‹é¢çš„æ‰€æœ‰è¯¾ç¨‹
        dfs(graph,graph[i][j]) // graph[i][j] è¡¨ç¤ºå­è¯¾ç¨‹
    }   

    onPath[i] = false // å–æ¶ˆå ç”¨æ ‡è®°
}
```
## 138. éšæœºé“¾è¡¨çš„å¤åˆ¶
ç»™ä½ ä¸€ä¸ªé•¿åº¦ä¸º `n` çš„é“¾è¡¨ï¼Œæ¯ä¸ªèŠ‚ç‚¹åŒ…å«ä¸€ä¸ªé¢å¤–å¢åŠ çš„éšæœºæŒ‡é’ˆ `random` ï¼Œè¯¥æŒ‡é’ˆå¯ä»¥æŒ‡å‘é“¾è¡¨ä¸­çš„ä»»ä½•èŠ‚ç‚¹æˆ–ç©ºèŠ‚ç‚¹ã€‚
æ„é€ è¿™ä¸ªé“¾è¡¨çš„ [**æ·±æ‹·è´**](https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin)ã€‚ æ·±æ‹·è´åº”è¯¥æ­£å¥½ç”± `n` ä¸ª **å…¨æ–°** èŠ‚ç‚¹ç»„æˆï¼Œå…¶ä¸­æ¯ä¸ªæ–°èŠ‚ç‚¹çš„å€¼éƒ½è®¾ä¸ºå…¶å¯¹åº”çš„åŸèŠ‚ç‚¹çš„å€¼ã€‚æ–°èŠ‚ç‚¹çš„ `next` æŒ‡é’ˆå’Œ `random` æŒ‡é’ˆä¹Ÿéƒ½åº”æŒ‡å‘å¤åˆ¶é“¾è¡¨ä¸­çš„æ–°èŠ‚ç‚¹ï¼Œå¹¶ä½¿åŸé“¾è¡¨å’Œå¤åˆ¶é“¾è¡¨ä¸­çš„è¿™äº›æŒ‡é’ˆèƒ½å¤Ÿè¡¨ç¤ºç›¸åŒçš„é“¾è¡¨çŠ¶æ€ã€‚**å¤åˆ¶é“¾è¡¨ä¸­çš„æŒ‡é’ˆéƒ½ä¸åº”æŒ‡å‘åŸé“¾è¡¨ä¸­çš„èŠ‚ç‚¹** ã€‚
ä¾‹å¦‚ï¼Œå¦‚æœåŸé“¾è¡¨ä¸­æœ‰ `X` å’Œ `Y` ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œå…¶ä¸­ `X.random --> Y` ã€‚é‚£ä¹ˆåœ¨å¤åˆ¶é“¾è¡¨ä¸­å¯¹åº”çš„ä¸¤ä¸ªèŠ‚ç‚¹ `x` å’Œ `y` ï¼ŒåŒæ ·æœ‰ `x.random --> y` ã€‚
è¿”å›å¤åˆ¶é“¾è¡¨çš„å¤´èŠ‚ç‚¹ã€‚
ç”¨ä¸€ä¸ªç”± `n` ä¸ªèŠ‚ç‚¹ç»„æˆçš„é“¾è¡¨æ¥è¡¨ç¤ºè¾“å…¥/è¾“å‡ºä¸­çš„é“¾è¡¨ã€‚æ¯ä¸ªèŠ‚ç‚¹ç”¨ä¸€ä¸ª `[val, random_index]` è¡¨ç¤ºï¼š

- `val`ï¼šä¸€ä¸ªè¡¨ç¤º `Node.val` çš„æ•´æ•°ã€‚
- `random_index`ï¼šéšæœºæŒ‡é’ˆæŒ‡å‘çš„èŠ‚ç‚¹ç´¢å¼•ï¼ˆèŒƒå›´ä» `0` åˆ° `n-1`ï¼‰ï¼›å¦‚æœä¸æŒ‡å‘ä»»ä½•èŠ‚ç‚¹ï¼Œåˆ™ä¸º `null` ã€‚ä½ çš„ä»£ç  **åª** æ¥å—åŸé“¾è¡¨çš„å¤´èŠ‚ç‚¹ `head` ä½œä¸ºä¼ å…¥å‚æ•°ã€‚
![b4b5034e-90a0-4619-a5da-0c2054b71be5.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411714352-b4b5034e-90a0-4619-a5da-0c2054b71be5.png)

æ€è·¯ï¼š
è¿™é“é¢˜ç›®ï¼Œå°±å±äºä¼šè€…ä¸éš¾ï¼Œéš¾è€…ä¸ä¼šçš„é‚£ç±»é¢˜ã€‚
**å¯¹äºæ•°æ®ç»“æ„å¤åˆ¶ï¼Œç”­ç®¡ä»–æ€ä¹ˆå˜ï¼Œä½ å°±è®°ä½æœ€ç®€å•çš„æ–¹å¼ï¼šä¸€ä¸ªå“ˆå¸Œè¡¨ + ä¸¤æ¬¡éå†**ã€‚
ç¬¬ä¸€æ¬¡éå†ä¸“é—¨å…‹éš†èŠ‚ç‚¹ï¼Œå€ŸåŠ©å“ˆå¸Œè¡¨æŠŠã€åŸå§‹èŠ‚ç‚¹å’Œå…‹éš†èŠ‚ç‚¹ã€‘çš„æ˜ å°„å­˜å‚¨èµ·æ¥ï¼›
ç¬¬äºŒæ¬¡ä¸“é—¨ç»„è£…èŠ‚ç‚¹ï¼Œç…§ç€åŸæ•°æ®ç»“æ„çš„æ ·å­ï¼ŒæŠŠå…‹éš†èŠ‚ç‚¹çš„æŒ‡é’ˆç»„è£…èµ·æ¥ã€‚

```go
/**
 * Definition for a Node.
 * type Node struct {
 *     Val int
 *     Next *Node
 *     Random *Node
 * }
 */

func copyRandomList(head *Node) *Node {
    // hashè¡¨ï¼Œå­˜å‚¨ åŸå§‹èŠ‚ç‚¹ -> å…‹éš†èŠ‚ç‚¹ çš„æ˜ å°„
    origin2Clone := make(map[*Node]*Node)
    //1.éå†é“¾è¡¨ï¼Œåˆ›å»º old -> new æ˜ å°„å…³ç³»
    for p := head;p != nil;p = p.Next {
        if _,ok := origin2Clone[p];!ok {
            origin2Clone[p] = &Node{Val:p.Val} // è€èŠ‚ç‚¹ -> æ–°èŠ‚ç‚¹
        }
    }

    //2. è¿›è¡Œæ˜ å°„
    // pè¡¨ç¤ºæ—§èŠ‚ç‚¹ origin2Clone[p] è¡¨ç¤ºæ–°èŠ‚ç‚¹
    for p := head;p != nil ;p = p.Next {
        origin2Clone[p].Next = origin2Clone[p.Next]
        origin2Clone[p].Random = origin2Clone[p.Random]
    }
		// è¿”å›æ–°å¤´èŠ‚ç‚¹ origin2Clone[head]
    return origin2Clone[head]
}
```
## 402. ç§»æ‰Kä½æ•°å­—
ç»™ä½ ä¸€ä¸ªä»¥å­—ç¬¦ä¸²è¡¨ç¤ºçš„éè´Ÿæ•´æ•° `num` å’Œä¸€ä¸ªæ•´æ•° `k` ï¼Œç§»é™¤è¿™ä¸ªæ•°ä¸­çš„ `k` ä½æ•°å­—ï¼Œä½¿å¾—å‰©ä¸‹çš„æ•°å­—æœ€å°ã€‚è¯·ä½ ä»¥å­—ç¬¦ä¸²å½¢å¼è¿”å›è¿™ä¸ªæœ€å°çš„æ•°å­—ã€‚
æ€è·¯ï¼š
æˆ‘ä»¬ä»¥å±€éƒ¨çš„è§†è§’çœ‹é—®é¢˜ï¼Œ**è®©ç›¸é‚»çš„ä¸¤ä¸¤æ•°å­—ï¼Œå°çš„åœ¨å‰é¢ï¼Œå¤§çš„åœ¨åé¢**
æ¯”å¦‚`54`ï¼Œç›¸é‚»çš„ä¸¤ä¸ªæ•°å­—ï¼Œå¦‚æœè¦æƒ³å˜å°ï¼Œè‚¯å®šè¦è®©å°çš„æ•°å­—å æ®é«˜ä½ï¼Œé‚£å°±æ˜¯`45`è¿™ç§æ ¼å¼ã€‚å¦‚æœæ˜¯ç§»é™¤ï¼Œé‚£å°±ç§»é™¤`5`åªä¿ç•™`4`å³å¯ã€‚
å†æ¯”å¦‚`541`ï¼Œç§»é™¤1ä½ï¼Œè®©æ•°å€¼æœ€å°ã€‚æŒ‰ç…§ä¸Šé¢çš„æ–¹æ¡ˆï¼Œæˆ‘ä»¬ç§»é™¤`5`å°±å¯ä»¥å¾—åˆ°`41`ã€‚å¯èƒ½ä¼šè§‰å¾—`541`ä¹‹é—´ï¼Œ1æ›´å°å‘€ï¼Œä¸ºå•¥ä¸ç§»é™¤ 4ã€‚
æˆ‘ä»¬åªèƒ½è¿›è¡Œ1æ¬¡ç§»é™¤æ“ä½œï¼Œå½“ä»å·¦åˆ°å³éå†ï¼Œä¹Ÿå°±æ˜¯ä»é«˜ä½åˆ°ä½ä½éå†ï¼Œæˆ‘ä»¬éœ€è¦ä¼˜å…ˆå°†é«˜ä½å˜å°ï¼Œå†è®©ä½ä½å˜å°ã€‚å¦‚æœé«˜ä½ä¸å˜å°ï¼Œåªæ˜¯æŠŠä½ä½å˜å°ï¼Œé‚£å°±æ˜¯`541`å»æ‰ 4 å˜æˆ `51`ã€‚è¿˜æ˜¯æ¯”ä¸Šé¢çš„`41`ç»“æœæ›´å¤§çš„ã€‚
æ‰€ä»¥ï¼Œç»“è®ºå°±æ˜¯**å…ˆè®©é«˜ä½å˜å°ï¼ˆç”¨å°çš„æ•°å­—ï¼‰ï¼Œç„¶åå†è®©åé¢çš„ä½å˜å°**
å†ä¾‹å¦‚`1432219`ï¼Œç§»é™¤3ä½å¾—åˆ°æœ€å°æ•°å€¼ã€‚
æˆ‘ä»¬ä»å·¦åˆ°å³éå†å­—ç¬¦ä¸²ï¼Œæ¥æ¼”ç¤ºè¿™ä¸ªè¿‡ç¨‹

- å…ˆæ¯”è¾ƒ 14ï¼Œé«˜ä½ 1å·²ç»å¾ˆå°äº†ï¼ˆä¿æŒä¸å˜ï¼‰ï¼Œæ‰€ä»¥ç»“æœä¸º 1432219
- å†æ¯”è¾ƒ 43ï¼Œ3æ›´å°ï¼Œã€å»æ‰4ã€‘ï¼ˆæ³¨æ„æ˜¯ä¸¤ä¸¤æ¯”è¾ƒï¼Œä¸€æ—¦å»æ‰äº†4ï¼Œé‚£ä¹ˆ3å°±å’Œ1ç›¸é‚»çš„ï¼Œå…¶å®è¿™é‡Œä¹Ÿè¦æ¯”è¾ƒä¸‹ 13çš„å…³ç³»ï¼Œæ˜¾ç„¶ 1 æ›´å°ï¼‰ï¼Œç»“æœä¸º 132219
- 32æ¯”è¾ƒï¼Œã€å»æ‰3ã€‘ï¼Œç»“æœä¸º 12219
- 22æ¯”è¾ƒï¼Œç›¸ç­‰ï¼Œæ‰€ä»¥ä¿æŒä¸å˜ï¼Œç»“æœä¸º 12219
- 21æ¯”è¾ƒï¼Œ1æ›´å°ï¼Œã€å»æ‰2ã€‘ç»“æœä¸º 1219ï¼ˆè¿™æ—¶å€™å‰ä¸€ä¸ª2å’Œ1ç›¸é‚»çš„äº†ï¼ŒæŒ‰ç…§ä¸Šé¢çš„ç†è®º1æ›´å°ï¼Œåº”è¯¥ã€å†å»æ‰ä¸€ä¸ª2ã€‘ï¼Œç»“æœä¸º119ï¼‰å› ä¸ºæˆ‘ä»¬åªéœ€è¦3æ¬¡ç§»é™¤æ“ä½œï¼Œå¦‚æœå†ç§»é™¤ä¸€ä¸ª2ï¼Œå°±æ˜¯4æ¬¡ç§»é™¤æ“ä½œäº†ã€‚å®é™…å®ç°çš„æ—¶å€™ï¼Œåˆ©ç”¨æ ˆæ¥å­˜å‚¨æ•°å­—ã€‚éå†åˆ°çš„æ•°å­—å’Œæ ˆé¡¶çš„æ•°å­—æ¯”è¾ƒï¼ˆä¹Ÿå°±å®ç°äº†ä¸¤ä¸¤æ¯”è¾ƒçš„å…³ç³»ï¼‰ï¼Œè®©å°çš„æ•°å­—å æ®é«˜ä½å³å¯ã€‚

```go
func removeKdigits(num string, k int) string {
    
    stack := make([]rune,0)

    for _,c := range num { // éå†å­—ç¬¦ä¸²ä¸­çš„æ¯ä¸ªå­—ç¬¦

      // åˆ é™¤kä¸ªæ•°å­—ï¼Œå¹¶ä¸”æ ˆé‡Œé¢æœ‰æ•°å­— å¹¶ä¸” å…¥æ ˆå­—ç¬¦cæ¯”æ ˆé¡¶å…ƒç´ å°(ä¹Ÿå°±æ˜¯ä¸¤ä¸¤æ¯”è¾ƒï¼Œè®©å°çš„å æ®é«˜ä½)
        for k > 0 && len(stack) != 0 && c < stack[len(stack)-1] { // æ³¨æ„è¿™é‡Œæ˜¯ä¸ªforå¾ªç¯
            //è¸¢å‡ºæ ˆé¡¶å…ƒç´ 
            stack = stack[:len(stack)-1]
            k-- // æ¯è¸¢å‡ºä¸€ä¸ªå…ƒç´ ï¼Œä¸ªæ•°-1
        }
				
      	// æ¯”å¦‚ï¼š102 è¿™ç§æ ¼å¼ï¼Œ 10æ¯”è¾ƒï¼Œ0æ›´å°ï¼Œå¦‚æœè®©0å…¥æ ˆï¼Œæœ€ç»ˆçš„ç»“æœå°±æ˜¯ 02ï¼Œå®é™…åº”è¯¥æ˜¯2
        if c == '0' && len(stack) == 0 { //å‰å¯¼0ã€å¿½ç•¥ã€‘
            continue
        }
        
        stack = append(stack,c) // æœ€åå…¥æ ˆ
    }
		
  	// ç‰¹æ®Šæƒ…å†µ
    if k >= len(stack) { // ä¾‹å¦‚ï¼š100  k=2ï¼Œåªä¼šæ‰§è¡Œ1æ¬¡ç§»é™¤æ“ä½œï¼ˆè¿˜ç¼ºå°‘ä¸€æ¬¡ï¼‰ï¼Œå¹¶ä¸”æœ€åçš„stackä¸ºç©ºã€‚ç›´æ¥è¿”å› 0
        return "0"
    } else {
        stack = stack[:len(stack)-k] // ä¾‹å¦‚ï¼š123456è¿™ç§é€’å¢çš„æ ¼å¼ï¼Œä¸Šé¢forå¾ªç¯ä¸ä¼šç§»é™¤ä»»ä½•å­—ç¬¦ï¼Œé¢˜ç›®è¦æ±‚å¿…é¡»å‰”é™¤kä¸ª 	1234 56 å»æ‰å°¾éƒ¨æœ€å¤§çš„æ•°ï¼Œä½™ä¸‹çš„å°±æ˜¯æœ€å°çš„å€¼
    }
    return string(stack)
}
```
## 136. åªå‡ºç°ä¸€æ¬¡çš„æ•°å­—
ç»™ä½ ä¸€ä¸ª **éç©º** æ•´æ•°æ•°ç»„ `nums` ï¼Œé™¤äº†æŸä¸ªå…ƒç´ åªå‡ºç°ä¸€æ¬¡ä»¥å¤–ï¼Œå…¶ä½™æ¯ä¸ªå…ƒç´ å‡å‡ºç°ä¸¤æ¬¡ã€‚æ‰¾å‡ºé‚£ä¸ªåªå‡ºç°äº†ä¸€æ¬¡çš„å…ƒç´ ã€‚
ä½ å¿…é¡»è®¾è®¡å¹¶å®ç°çº¿æ€§æ—¶é—´å¤æ‚åº¦çš„ç®—æ³•æ¥è§£å†³æ­¤é—®é¢˜ï¼Œä¸”è¯¥ç®—æ³•åªä½¿ç”¨å¸¸é‡é¢å¤–ç©ºé—´ã€‚
æ€è·¯ï¼š
è®°ä½å¼‚æˆ–è¿ç®—ï¼Œå°±æ˜¯åŠåŠ è¿ç®—ã€‚ä¹Ÿå°±æ˜¯åªåšåŠ æ³•ï¼Œä½†æ˜¯ä¸è¿›ä½ã€‚æ‰€ä»¥ç›¸åŒçš„æ•°å­—è¿›è¡Œå¼‚æˆ–çš„ç»“æœå°±æ˜¯`0`
![ff0916ca-827e-4753-9c4a-2aec1aa966bc.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411714530-ff0916ca-827e-4753-9c4a-2aec1aa966bc.png)


```go
func singleNumber(nums []int) int {
    // è¿™é¢˜çš„æ€è·¯ï¼šå¼‚æˆ–è¿ç®— a^a = 0  a ^ 0 = a
    // é‡å¤å…ƒç´ å‡ºç°ä¸¤æ¬¡,å¼‚æˆ–åéƒ½æ˜¯0ï¼Œæœ€åçš„ç»“æœå°±æ˜¯é‚£ä¸ªåªå‡ºç°ä¸€æ¬¡çš„å…ƒç´ 
    result := 0
    for _ ,num := range nums {
        result ^= num
    }
    return result
}
```
## 11. ç››æœ€å¤šæ°´çš„å®¹å™¨
ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º `n` çš„æ•´æ•°æ•°ç»„ `height` ã€‚æœ‰ `n` æ¡å‚çº¿ï¼Œç¬¬ `i` æ¡çº¿çš„ä¸¤ä¸ªç«¯ç‚¹æ˜¯ `(i, 0)` å’Œ `(i, height[i])` ã€‚
æ‰¾å‡ºå…¶ä¸­çš„ä¸¤æ¡çº¿ï¼Œä½¿å¾—å®ƒä»¬ä¸ `x` è½´å…±åŒæ„æˆçš„å®¹å™¨å¯ä»¥å®¹çº³æœ€å¤šçš„æ°´ã€‚
è¿”å›å®¹å™¨å¯ä»¥å‚¨å­˜çš„æœ€å¤§æ°´é‡ã€‚
**è¯´æ˜ï¼š**ä½ ä¸èƒ½å€¾æ–œå®¹å™¨ã€‚
![6dcf8cf7-1a80-44f0-8910-7c201dae54d6.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411714566-6dcf8cf7-1a80-44f0-8910-7c201dae54d6.png)

æ€è·¯ï¼š
**ç”¨ **`**left**`** å’Œ **`**right**`** ä¸¤ä¸ªæŒ‡é’ˆä»ä¸¤ç«¯å‘ä¸­å¿ƒæ”¶ç¼©ï¼Œä¸€è¾¹æ”¶ç¼©ä¸€è¾¹è®¡ç®— **`**[left, right]**`** ä¹‹é—´çš„çŸ©å½¢é¢ç§¯ï¼Œå–æœ€å¤§çš„é¢ç§¯å€¼å³æ˜¯ç­”æ¡ˆ**ã€‚
ä¸è¿‡è‚¯å®šæœ‰è¯»è€…ä¼šé—®ï¼Œä¸‹é¢è¿™æ®µ if è¯­å¥ä¸ºä»€ä¹ˆè¦ç§»åŠ¨è¾ƒä½çš„ä¸€è¾¹ï¼š

```go
// åŒæŒ‡é’ˆæŠ€å·§ï¼Œç§»åŠ¨è¾ƒä½çš„ä¸€è¾¹
if (height[left] < height[right]) {
    left++;
} else {
    right--;
}
```
**å…¶å®ä¹Ÿå¥½ç†è§£ï¼Œå› ä¸ºçŸ©å½¢çš„é«˜åº¦æ˜¯ç”± **`**min(height[left], height[right])**`** å³è¾ƒä½çš„ä¸€è¾¹å†³å®šçš„**ï¼š
ä½ å¦‚æœç§»åŠ¨è¾ƒä½çš„é‚£ä¸€è¾¹ï¼Œé‚£æ¡è¾¹å¯èƒ½ä¼šå˜é«˜ï¼Œä½¿å¾—çŸ©å½¢çš„é«˜åº¦å˜å¤§ï¼Œè¿›è€Œå°±ã€Œæœ‰å¯èƒ½ã€ä½¿å¾—çŸ©å½¢çš„é¢ç§¯å˜å¤§ï¼›ç›¸åï¼Œå¦‚æœä½ å»ç§»åŠ¨è¾ƒé«˜çš„é‚£ä¸€è¾¹ï¼ŒçŸ©å½¢çš„é«˜åº¦æ˜¯æ— è®ºå¦‚ä½•éƒ½ä¸ä¼šå˜å¤§çš„ï¼ˆå› ä¸ºä½çš„é‚£ä¸€è¾¹å†³å®šäº†é«˜åº¦ä¸Šé™ï¼Œä¹Ÿå°±æ˜¯çŸ­æ¿æ•ˆåº”ï¼‰ï¼Œæ‰€ä»¥ä¸å¯èƒ½ä½¿çŸ©å½¢çš„é¢ç§¯å˜å¾—æ›´å¤§ã€‚

```go
// åŒæŒ‡é’ˆæŠ€å·§
func maxArea(height []int) int {
    left,right := 0,len(height)-1
		// æœ€ç»ˆç»“æœ
    maxVal := 0
    for left < right {
        // è®¡ç®—ä¸¤æ¡è¾¹å›´æˆçš„é¢ç§¯ é«˜åº¦çš„æœ€å°å€¼ * åº•è¾¹é•¿åº¦

        maxVal = max(maxVal,min(height[left],height[right]) * (right-left)) 

        if height[left] < height[right] { // left/rightä¸¤æ¡è¾¹ï¼Œleftè¾¹æ¯”è¾ƒçŸ­ï¼Œå› ä¸ºå®¹å™¨ç››æ°´ï¼ŒçŸ­è¾¹ä¼šé™åˆ¶å®¹å™¨çš„é«˜åº¦ï¼Œå¦‚æœç§»åŠ¨rightï¼Œå³ä½¿æ‰¾åˆ°æ›´é«˜çš„rightï¼Œå› ä¸ºleftæ¯”è¾ƒçŸ­ï¼Œæœ€åå¯èƒ½å®¹å™¨çš„é«˜åº¦è¿˜æ˜¯lefté«˜åº¦
            left++

        } else {
            right--
        }
    }
    return maxVal
}

func max(a ,b int) int{
    if a > b {
        return a
    }
    return b
}

func min(a,b int) int {
    if a < b {
        return a
    }
    return b
}
```
## 47. å…¨æ’åˆ—II
ç»™å®šä¸€ä¸ªå¯åŒ…å«é‡å¤æ•°å­—çš„åºåˆ— `nums` ï¼Œ***æŒ‰ä»»æ„é¡ºåº*** è¿”å›æ‰€æœ‰ä¸é‡å¤çš„å…¨æ’åˆ—ã€‚
æ€è·¯:
è¯·å…ˆåšå‰ç½®é¢˜ç›®ã€Œ[46. å…¨æ’åˆ—](https://leetcode.cn/problems/permutations/solutions/2363882/46-quan-pai-lie-hui-su-qing-xi-tu-jie-by-6o7h/)ã€
æœ¬é¢˜å’Œä¸Šä¸€é¢˜çš„åŒºåˆ«æ˜¯æ•°ç»„ä¸­â€œå­˜åœ¨é‡å¤å…ƒç´ â€ã€‚å½“æ•°ç»„å­˜åœ¨é‡å¤å…ƒç´ æ—¶ï¼Œæ’åˆ—æ–¹æ¡ˆä¸­ä¹Ÿå­˜åœ¨é‡å¤çš„æ–¹æ¡ˆã€‚
é‡å¤çš„æ’åˆ—æ–¹æ¡ˆï¼Œä¸»è¦æ˜¯å› ä¸ºé‡å¤çš„å…ƒç´ é€ æˆçš„ã€‚
æ¯”å¦‚ï¼šæ•°å­—åºåˆ—`[1,1]`ï¼Œå‡å¦‚æˆ‘ä»¬å°†ç¬¬ä¸€ä¸ª1å«åš 1' ç¬¬äºŒä¸ª1å«åš 1"ï¼Œé‚£ä¹ˆæ•°å­—åºåˆ—æˆ‘ä»¬æ”¹å†™ä¸º`[1' 1"]`ã€‚å¦‚æœæˆ‘ä»¬è¿›è¡Œæ’åˆ—ï¼Œé‚£å°±åŒ…æ‹¬äº†`[1' 1"]å’Œ[1" 1']`ä¸¤ç§æ’åˆ—æ–¹æ¡ˆï¼Œå…¶å®è¿™ä¸¤ç§æ–¹æ¡ˆå°±æ˜¯ä¸€ç§æ–¹æ¡ˆã€‚
ä¸ºäº†ä¿è¯ä¸é‡å¤ï¼Œæˆ‘ä»¬è®¾å®šä¸€ä¸ªæ¡ä»¶ï¼Œå°±æ˜¯è¦æ±‚ 1' å¿…é¡»è¦åœ¨1"çš„å‰é¢ï¼Œé‚£ä¹ˆ`[1" 1']`è¿™ç§æ–¹æ¡ˆè‡ªç„¶ä¹Ÿå°±ä¸æˆç«‹äº†ã€‚
é‚£ä¹ˆæ€ä¹ˆæ‰èƒ½å®ç°è¿™ä¸ªæ¡ä»¶å‘¢ï¼Ÿ

- æˆ‘ä»¬éœ€è¦å¯¹æ•°ç»„è¿›è¡Œæ’åºï¼Œè®©ç›¸åŒçš„å…ƒç´ éƒ½ç›¸é‚»åœ¨ä¸€èµ·
- åœ¨æ¯æ¬¡é€‰æ‹©ä¸€ä¸ªå…ƒç´ çš„æ—¶å€™ï¼Œéƒ½è¦ä¿è¯ç›¸é‚»çš„ã€å‰ä¸€ä¸ªã€‘**ç›¸åŒ**å…ƒç´ ï¼Œå‡ºç°çš„æƒ…å†µä¸‹ï¼Œè‡ªå·±æ‰èƒ½å‡ºç°ï¼ˆä¹Ÿå°±æ˜¯ç›¸å¯¹é¡ºåºè¦ä¿è¯ä¸å˜ï¼‰ã€‚æ¯”å¦‚ä¸Šé¢çš„ 1" è¦æƒ³å‡ºç°ï¼Œå¿…é¡» 1'å…ˆå‡ºç°çš„æƒ…å†µä¸‹ã€‚ã€‚ã€‚è€Œ`[1" 1']`è¿™ç§æ ¼å¼ï¼Œ1' æ˜¯åœ¨ 1"åé¢å‡ºç°çš„ã€‚å…·ä½“çœ‹ä¸‹é¢ä»£ç 

```go
var used []bool
var track []int
var result [][]int
func permuteUnique(nums []int) [][]int {

    // 1.æ’åº
    sort.Slice(nums,func(i,j int)bool{
        return nums[i] < nums[j]
    })
    // å›æº¯ç®—æ³•
    used = make([]bool,len(nums)) //ç”¨æ¥è®°å½•å…ƒç´ æ˜¯å¦å·²ç»è¢«ä½¿ç”¨è¿‡
    track = []int{}
    result = [][]int{}
    backtrack(nums)
    return result
}

func backtrack(nums []int) {

    if len(track) == len(nums) {
        tmp := make([]int,len(track))
        copy(tmp,track)
        result = append(result,tmp)
        return
    }

    for i := 0;i < len(nums);i++ {
        if used[i] {
            continue
        }

        // ä¿è¯é‡å¤çš„å…ƒç´ çš„ã€ç›¸å¯¹é¡ºåºã€‘ä¸å˜ï¼Œä¾‹å¦‚å‰ä¸€ä¸ª1æ²¡æœ‰è¢«ä½¿ç”¨ï¼Œåé¢çš„é‡å¤å…ƒç´ 1ä¹Ÿä¸èƒ½è¢«ä½¿ç”¨ï¼Œè¿™æ ·å…¶å®å°±ä¿è¯é‡å¤å…ƒç´ çš„ç›¸å¯¹é¡ºåºä¸å˜ã€‚å†ä¾‹å¦‚ï¼š1 1' ï¼Œä¿è¯1'è¢«é€‰ä¸­çš„å‰æ 1å…ˆè¢«ä½¿ç”¨ï¼Œè¿™æ ·å°±å¯ä»¥ä¿è¯1 1'çš„é¡ºåºä¸å˜
        //å½“å‰é€‰æ‹©çš„å…ƒç´ å’Œå‰ä¸€ä¸ªå…ƒç´ ç›¸åŒ,å¦‚æœå‰ä¸€ä¸ªå…ƒç´ æ²¡æœ‰è¢«ä½¿ç”¨ï¼Œå½“å‰çš„è¿™ä¸ªå…ƒç´ ä¹Ÿä¸èƒ½è¢«ä½¿ç”¨
        if i > 0 && nums[i] == nums[i-1] && !used[i-1] {
            continue
        }

        //é€‰æ‹©
        used[i] = true
        track = append(track,nums[i])
        backtrack(nums)

        //æ’¤é”€é€‰æ‹©
        used[i] = false
        track = track[:len(track)-1]
    }
}
```
## 79. å•è¯æœç´¢
ç»™å®šä¸€ä¸ª `m x n` äºŒç»´å­—ç¬¦ç½‘æ ¼ `board` å’Œä¸€ä¸ªå­—ç¬¦ä¸²å•è¯ `word` ã€‚å¦‚æœ `word` å­˜åœ¨äºç½‘æ ¼ä¸­ï¼Œè¿”å› `true` ï¼›å¦åˆ™ï¼Œè¿”å› `false` ã€‚
å•è¯å¿…é¡»æŒ‰ç…§å­—æ¯é¡ºåºï¼Œé€šè¿‡ç›¸é‚»çš„å•å…ƒæ ¼å†…çš„å­—æ¯æ„æˆï¼Œå…¶ä¸­â€œç›¸é‚»â€å•å…ƒæ ¼æ˜¯é‚£äº›æ°´å¹³ç›¸é‚»æˆ–å‚ç›´ç›¸é‚»çš„å•å…ƒæ ¼ã€‚åŒä¸€ä¸ªå•å…ƒæ ¼å†…çš„å­—æ¯ä¸å…è®¸è¢«é‡å¤ä½¿ç”¨ã€‚
![810746f3-5ada-4b53-af90-325bac861b1d.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411714656-810746f3-5ada-4b53-af90-325bac861b1d.png)

æ€è·¯:
é‡‡ç”¨ DFS ç®—æ³•æš´åŠ›æœç´¢ï¼Œè¿™é¢˜å’Œå²›å±¿é—®é¢˜æœ‰ç±»ä¼¼ä¹‹å¤„ï¼Œå¯ä»¥å¯¹æ¯”çœ‹ä¸‹ã€‚
æ³¨æ„æˆ‘ä»¬è¦å¯¹å·²ç»åŒ¹é…è¿‡çš„å­—ç¬¦åšæ ‡è®°ï¼Œæ¯”å¦‚ç”¨ä¸€ä¸ªé¢å¤–çš„ `visited` å¸ƒå°”æ•°ç»„ï¼Œæˆ–è€…ä½¿ç”¨å…¶ä»–æ–¹æ³•æ ‡è®° `board` ä¸­å·²ç»åŒ¹é…è¿‡çš„å­—ç¬¦ã€‚
å¦‚æœä¸åšæ ‡è®°çš„è¯ä¼šå‡ºç°é”™è¯¯çš„ç»“æœï¼Œæ¯”å¦‚è¿™ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼š

```go
[["A","B","C","E"],
 ["S","F","C","S"],
 ["A","D","E","E"]]
```
ä½ å¦‚æœåœ¨å…¶ä¸­æœç´¢ `"ABCB"`ï¼ŒæŒ‰é“ç†ä¸åº”è¯¥æœåˆ°ï¼Œä½†å¦‚æœä½ ä¸å¯¹å·²ç»åŒ¹é…è¿‡çš„å­—ç¬¦åšæ ‡è®°çš„è¯ï¼Œç®—æ³•å¯èƒ½åŒ¹é…äº†ç¬¬ä¸€è¡Œå‰ä¸‰åˆ—çš„ `"ABC"` ä¹‹ååˆå›å¤´åŒ¹é…äº†ç¬¬äºŒåˆ—çš„ `"B"`ï¼Œå¯¼è‡´å‡ºç°é”™è¯¯çš„ç»“æœã€‚
ä»£ç å¦‚ä¸‹ï¼š

```go
var found bool
func exist(board [][]byte, word string) bool {
		// è®°å½•æ˜¯å¦å·²ç»æœç´¢åˆ°äº†
    found = false

    m ,n := len(board),len(board[0])
    for i := 0;i < m;i++ {
        for j := 0;j < n ;j++ {
          	// ä»æ¯ä¸€ä¸ªå­—ç¬¦board[i][j]å¼€å§‹ï¼Œè¿›è¡Œæœç´¢
            dfs(board,i,j,m,n,word,0)
            if found {
                return true
            }
        }
    }
    return false
}

//  boardä»iï¼Œjä½ç½®å¼€å§‹ï¼Œwordä»pä½ç½®å¼€å§‹ï¼Œå¯»æ‰¾åŒ¹é…çš„å­—ç¬¦ï¼Œæœ€ååˆ¤æ–­èƒ½å¦å®ŒæˆåŒ¹é…
func dfs (board [][]byte,i,j,m,n int,word string ,p int ) {
  	
    if p == len(word) { // è¯´æ˜æ•´ä¸ªpå®Œæˆäº†æœç´¢ï¼Œæ‰¾åˆ°äº†å°¾éƒ¨
        found = true
        return
    }
  	// å¦‚æœå·²ç»æœ‰åŒ¹é…çš„ç»“æœï¼Œå°±ä¸ç”¨ç»§ç»­ä¸‹å»äº†ï¼ˆä¸ºäº†å‰ªæï¼‰
    if found {
        return
    }

    if i < 0 || i >= m || j < 0 || j >=n { // è¯´æ˜è¶Šç•Œ
        return
    }

    if board[i][j] != word[p] { // ä¸ç›¸åŒï¼Œå¿½ç•¥
        return
    }


    // æ‰§è¡Œåˆ°è¿™é‡Œï¼Œè¯´æ˜pä½ç½®çš„å­—ç¬¦å’Œboard[i][j]ä½ç½®çš„å­—ç¬¦ç›¸åŒ
  	board[i][j] = board[i][j] ^ byte(0x80) // è¿™ä¸ªçš„ç›®çš„å°±æ˜¯æŠŠbyteçš„æœ€é«˜ä½è®¾ç½®ä¸º1ï¼Œå°±å˜æˆäº†ä¸€ä¸ªå…¶ä»–çš„å­—ç¬¦(è‚¯å®šä¸æ˜¯å¤§å°å†™å­—æ¯,ç­‰ä»·äºæ‰“ä¸Šäº†ç‰¹æ®Šæ ‡è®°)
		
  	// æ‰©å±•åˆ°å‘¨è¾¹å­—ç¬¦ å’Œ p+1 å­—ç¬¦ æ¯”è¾ƒ
    dfs(board,i+1,j,m,n,word,p+1)
    dfs(board,i-1,j,m,n,word,p+1)
    dfs(board,i,j+1,m,n,word,p+1)
    dfs(board,i,j-1,m,n,word,p+1)


    board[i][j] = board[i][j] ^ byte(0x80) // æ’¤é”€æ ‡è®°

}
```
## LCR 155. å°†äºŒå‰æœç´¢æ ‘è½¬åŒ–ä¸ºæ’åºçš„åŒå‘é“¾è¡¨
å°†ä¸€ä¸ª **äºŒå‰æœç´¢æ ‘** å°±åœ°è½¬åŒ–ä¸ºä¸€ä¸ª **å·²æ’åºçš„åŒå‘å¾ªç¯é“¾è¡¨** ã€‚
å¯¹äºåŒå‘å¾ªç¯åˆ—è¡¨ï¼Œä½ å¯ä»¥å°†å·¦å³å­©å­æŒ‡é’ˆä½œä¸ºåŒå‘å¾ªç¯é“¾è¡¨çš„å‰é©±å’Œåç»§æŒ‡é’ˆï¼Œç¬¬ä¸€ä¸ªèŠ‚ç‚¹çš„å‰é©±æ˜¯æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼Œæœ€åä¸€ä¸ªèŠ‚ç‚¹çš„åç»§æ˜¯ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚
ç‰¹åˆ«åœ°ï¼Œæˆ‘ä»¬å¸Œæœ›å¯ä»¥ **å°±åœ°** å®Œæˆè½¬æ¢æ“ä½œã€‚å½“è½¬åŒ–å®Œæˆä»¥åï¼Œæ ‘ä¸­èŠ‚ç‚¹çš„å·¦æŒ‡é’ˆéœ€è¦æŒ‡å‘å‰é©±ï¼Œæ ‘ä¸­èŠ‚ç‚¹çš„å³æŒ‡é’ˆéœ€è¦æŒ‡å‘åç»§ã€‚è¿˜éœ€è¦è¿”å›é“¾è¡¨ä¸­æœ€å°å…ƒç´ çš„æŒ‡é’ˆã€‚
æ€è·¯ï¼š
**æ ‘ä¸­èŠ‚ç‚¹çš„å·¦æŒ‡é’ˆ**`**left**`**éœ€è¦æŒ‡å‘å‰é©±ï¼Œæ ‘ä¸­èŠ‚ç‚¹çš„å³æŒ‡é’ˆ**`**right**`**éœ€è¦æŒ‡å‘åç»§**

- äºŒå‰æœç´¢æ ‘çš„ä¸­åºéå†ä¸º **é€’å¢åºåˆ—**
- **æ’åºé“¾è¡¨ï¼š** èŠ‚ç‚¹åº”ä»å°åˆ°å¤§æ’åºï¼Œå› æ­¤åº”ä½¿ç”¨ **ä¸­åºéå†** â€œä»å°åˆ°å¤§â€è®¿é—®æ ‘çš„èŠ‚ç‚¹
- **åŒå‘é“¾è¡¨**ï¼š åœ¨æ„å»ºç›¸é‚»èŠ‚ç‚¹çš„å¼•ç”¨å…³ç³»æ—¶ï¼Œè®¾å‰é©±èŠ‚ç‚¹ pre å’Œå½“å‰èŠ‚ç‚¹ cur ï¼Œä¸ä»…åº”æ„å»º pre.right = cur ï¼Œä¹Ÿåº”æ„å»º cur.left = pre
- **å¾ªç¯é“¾è¡¨ï¼š** è®¾é“¾è¡¨å¤´èŠ‚ç‚¹ `head` å’Œå°¾èŠ‚ç‚¹ `tail` ï¼Œåˆ™åº”æ„å»º `head.left = tail` å’Œ `tail.right = head`![d6a28855-5fb4-44c3-bfdb-7fc7437d1e0f.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411714805-d6a28855-5fb4-44c3-bfdb-7fc7437d1e0f.png)

å› ä¸º `leetcode`æ²¡æœ‰`Go`çš„ä»£ç ç¼–è¾‘å™¨ï¼Œè¿™é‡Œæä¾›`C++`çš„ä»£ç 

```go
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;

    Node() {}

    Node(int _val) {
        val = _val;
        left = NULL;
        right = NULL;
    }

    Node(int _val, Node* _left, Node* _right) {
        val = _val;
        left = _left;
        right = _right;
    }
};
*/
class Solution {
public:
    Node* pre = NULL;  // å‰é©±èŠ‚ç‚¹
    Node* head = NULL; // å¤´éƒ¨èŠ‚ç‚¹
public:
    // right ç”¨æ¥å¾€åé¢æŒ‡ leftç”¨æ¥å¾€å‰é¢æŒ‡
    Node* treeToDoublyList(Node* root) {

        if (root == NULL) {
            return head;
        }
			
        doublyList(root);
        // é¦–å°¾ç›¸è¿ï¼ˆå¾ªç¯ï¼‰
        head->left = pre;
        pre->right = head;
				// è¿”å›é“¾è¡¨çš„å¤´èŠ‚ç‚¹
        return head;
    }

  	// ä¸­åºéå†	
    void doublyList(Node* root) {
        
        if (root == NULL) {
            return;
        }
      
        doublyList(root->left);
        if (head == NULL) {
            head = root; // è®°å½•ä¸‹å¤´éƒ¨èŠ‚ç‚¹,ä½œä¸ºé“¾è¡¨çš„å¤´èŠ‚ç‚¹
            pre = root;  // è®°å½•ä¸‹å‰é©±èŠ‚ç‚¹
        } else {
          	// ç›¸é‚»èŠ‚ç‚¹(åŒå‘)  rootè¡¨ç¤ºå½“å‰èŠ‚ç‚¹ï¼ˆç­‰ä»·äºä¸Šå›¾ä¸­çš„èŠ‚ç‚¹4ï¼‰ï¼Œ preæ˜¯å‰ä¸€ä¸ªèŠ‚ç‚¹ï¼ˆç­‰ä»·äºä¸Šå›¾ä¸­çš„èŠ‚ç‚¹3ï¼‰
            root->left = pre;
            pre->right = root;
            pre = root;
        }
        doublyList(root->right);
    }
};
```
## LCR 125. å›¾ä¹¦ç®¡ç†
è¯»è€…æ¥åˆ°å›¾ä¹¦é¦†æ’é˜Ÿå€Ÿè¿˜ä¹¦ï¼Œå›¾ä¹¦ç®¡ç†å‘˜ä½¿ç”¨ä¸¤ä¸ªä¹¦è½¦æ¥å®Œæˆæ•´ç†å€Ÿè¿˜ä¹¦çš„ä»»åŠ¡ã€‚ä¹¦è½¦ä¸­çš„ä¹¦ä»ä¸‹å¾€ä¸Šå åŠ å­˜æ”¾ï¼Œå›¾ä¹¦ç®¡ç†å‘˜æ¯æ¬¡åªèƒ½æ‹¿å–ä¹¦è½¦é¡¶éƒ¨çš„ä¹¦ã€‚æ’é˜Ÿçš„è¯»è€…ä¼šæœ‰ä¸¤ç§æ“ä½œï¼š

- `push(bookID)`ï¼šæŠŠå€Ÿé˜…çš„ä¹¦ç±è¿˜åˆ°å›¾ä¹¦é¦†ã€‚
- `pop()`ï¼šä»å›¾ä¹¦é¦†ä¸­å€Ÿå‡ºä¹¦ç±ã€‚ä¸ºäº†ä¿æŒå›¾ä¹¦çš„é¡ºåºï¼Œå›¾ä¹¦ç®¡ç†å‘˜æ¯æ¬¡å–å‡ºä¾›è¯»è€…å€Ÿé˜…çš„ä¹¦ç±æ˜¯ **æœ€æ—©** å½’è¿˜åˆ°å›¾ä¹¦é¦†çš„ä¹¦ç±ã€‚ä½ éœ€è¦è¿”å› **æ¯æ¬¡è¯»è€…å€Ÿå‡ºä¹¦çš„å€¼** ã€‚
å¦‚æœæ²¡æœ‰å½’è¿˜çš„ä¹¦å¯ä»¥å–å‡ºï¼Œè¿”å› `-1` ã€‚
æ€è·¯ï¼š
è¿™é¢˜æœ‰äº›ç»•ï¼Œå…¶å®å°±æ˜¯è®©ä½ ç”¨æ ˆå®ç°é˜Ÿåˆ—ï¼Œä¸[232. ç”¨æ ˆå®ç°é˜Ÿåˆ—](https://leetcode.cn/problems/implement-queue-using-stacks) ç›¸åŒ

```go
type CQueue struct {
    sk1 []int
    sk2 []int
}


func Constructor() CQueue {

    return CQueue {
        sk1 : make([]int,0), // sk1ç”¨æ¥ä¿å­˜æœ€æ–°çš„æ•°æ®ï¼ˆçœ‹ä½œ é˜Ÿåˆ—çš„å°¾éƒ¨ï¼‰
        sk2 : make([]int,0), // sk2ç”¨æ¥å‡ºæ ˆæ•°æ®ï¼ˆçœ‹ä½œ é˜Ÿåˆ—çš„é¦–éƒ¨ï¼‰
    }
    
}


func (this *CQueue) AppendTail(value int)  { // æ’å…¥å°¾éƒ¨
    this.sk1 = append(this.sk1,value)
}


func (this *CQueue) DeleteHead() int { // åˆ é™¤å¤´éƒ¨
  	// å¦‚æœæ ˆä¸ºç©ºï¼Œè¯´æ˜æ²¡æœ‰ä¹¦
    if len(this.sk1) == 0 && len(this.sk2) == 0 {
        return -1
    }
		
  	// å¦‚æœsk2ä¸ºç©ºï¼Œå°†æ ˆsk2çš„å†…å®¹ï¼Œæ”¾å…¥åˆ°æ ˆsk1ä¸­
    if len(this.sk2) == 0 { 
        for len(this.sk1) != 0 {
            tempval := this.sk1[len(this.sk1)-1]
            this.sk2 = append(this.sk2,tempval)
            this.sk1 = this.sk1[:len(this.sk1)-1]
        }
    }

    // å‡ºæ ˆsk2ï¼ˆ
    val := this.sk2[len(this.sk2)-1]
    this.sk2 = this.sk2[:len(this.sk2)-1]

    return val
}
```
## 498. å¯¹è§’çº¿éå†
ç»™ä½ ä¸€ä¸ªå¤§å°ä¸º `m x n` çš„çŸ©é˜µ `mat` ï¼Œè¯·ä»¥å¯¹è§’çº¿éå†çš„é¡ºåºï¼Œç”¨ä¸€ä¸ªæ•°ç»„è¿”å›è¿™ä¸ªçŸ©é˜µä¸­çš„æ‰€æœ‰å…ƒç´ ã€‚
æ€è·¯ï¼š
è¿™é¢˜ä¸»è¦æ˜¯è§‚å¯ŸçŸ©é˜µ

- æ‰¾å‡ºè¾¹ç•Œä½ç½®çš„ã€è¡Œã€åˆ—ã€‘çš„å˜åŒ–å…³ç³»
- é€šè¿‡`(r+c)%2 == 0`çŸ¥é“å½“å‰æ˜¯ã€ä»å·¦ä¸‹åˆ°å³ä¸Šï¼Œè¿˜æ˜¯ä»å³ä¸Šåˆ°å·¦ä¸‹ã€‘
- åœ¨å…·ä½“çš„çš„å·¦ä¸‹å³ä¸Šçš„ç§»åŠ¨ä¸­ï¼ŒçŸ¥é“è¡Œåˆ—çš„å˜åŠ¨ç‰¹ç‚¹ï¼Œæ˜¯+1ï¼Œè¿˜æ˜¯-1![825469a6-c607-4138-9eab-4504341b1211.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411715063-825469a6-c607-4138-9eab-4504341b1211.png)

ğŸ“¢æ³¨æ„ï¼šä¸Šå›¾ä¸­çš„ç¬¬ä¸€ä¸ªçº¢çº¿å’Œç¬¬äºŒä¸ªçº¢çº¿ï¼Œå…¶å®éƒ½æ˜¯`r==0`ã€‚ä½†æ˜¯ç¬¬äºŒä¸ªçº¢çº¿ `c==n-1`å·²ç»æ˜¯æœ€åä¸€åˆ—äº†ï¼ˆå¦‚æœè¿˜å¯¹åˆ—+1ï¼Œé‚£å°±è¶Šç•Œäº†ï¼‰ã€‚æ‰€ä»¥ï¼Œåœ¨åˆ¤æ–­çš„æ—¶å€™ï¼Œè¦ä¼˜å…ˆä»¥`c==n-1`ä½œä¸ºåˆ¤æ–­æ¡ä»¶ï¼Œå†ä»¥`r==0`ä½œä¸ºåˆ¤æ–­æ¡ä»¶ã€‚æ³¨æ„çœ‹ä»£ç ä½“ä¼šè¿™ä¸ªã€‚

```go
func findDiagonalOrder(mat [][]int) []int {
    
    m,n := len(mat),len(mat[0])
    result := make([]int,m*n)

    r,c := 0,0 // ræ˜¯è¡Œ cæ˜¯åˆ—

    for i := 0;i < m*n;i++ {

        result[i] = mat[r][c]

        if (r+c) %2 == 0 { // è¯´æ˜ä»å·¦ä¸‹åˆ°å³ä¸Š
             // ã€æ³¨æ„è¿™é‡Œçš„é¡ºåºã€‘
            if c == n-1 { // è¾¹ç•Œä½ç½®ï¼šåˆ—ä¸å˜ï¼Œè¡Œ+1
                r++
            } else if r == 0 { // è¾¹ç•Œä½ç½®:è¡Œä¸å˜ï¼Œåˆ—+1
                c++
            } else {
                r--
                c++
            }
        } else { // è¯´æ˜ä»å³ä¸Šåˆ°å·¦ä¸‹
            // ã€æ³¨æ„è¿™é‡Œçš„é¡ºåºã€‘
            if r == m-1 { // è¾¹ç•Œä½ç½®ï¼šè¡Œä¸å˜ï¼Œåˆ—+1
                c++
            } else if c == 0 {// è¾¹ç•Œä½ç½®ï¼šåˆ—ä¸å˜ï¼Œè¡Œ+1
                r++
            }   else {
                r++
                c--
            }
        }
    }
    return result
}
```
## 958. äºŒå‰æ ‘çš„å®Œå…¨æ€§æ£€éªŒ
ç»™ä½ ä¸€æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œè¯·ä½ åˆ¤æ–­è¿™æ£µæ ‘æ˜¯å¦æ˜¯ä¸€æ£µ **å®Œå…¨äºŒå‰æ ‘** ã€‚
åœ¨ä¸€æ£µ [**å®Œå…¨äºŒå‰æ ‘**](https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin) ä¸­ï¼Œé™¤äº†æœ€åä¸€å±‚å¤–ï¼Œæ‰€æœ‰å±‚éƒ½è¢«å®Œå…¨å¡«æ»¡ï¼Œå¹¶ä¸”æœ€åä¸€å±‚ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹éƒ½å°½å¯èƒ½é å·¦ã€‚æœ€åä¸€å±‚ï¼ˆç¬¬ `h` å±‚ï¼‰ä¸­å¯ä»¥åŒ…å« `1` åˆ° `2h` ä¸ªèŠ‚ç‚¹ã€‚
æ€è·¯ï¼š
å±‚åºéå†ï¼šå½“é‡åˆ°`nil`èŠ‚ç‚¹ï¼Œåç»­ä¸èƒ½å†å‡ºç°`ã€énilã€‘`èŠ‚ç‚¹ï¼Œæ‰èƒ½æ»¡è¶³å®Œå…¨äºŒå‰æ ‘.

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func isCompleteTree(root *TreeNode) bool {
    
    if root == nil {
        return true
    }

    nodes := []*TreeNode{}
    nodes = append(nodes,root)//åŠ å…¥ç¬¬ä¸€ä¸ªèŠ‚ç‚¹
    end := false
    for len(nodes) != 0 {
        size := len(nodes)
        //å±‚åºéå†
        for i := 0;i < size;i++ {
            if nodes[i] == nil {
                end = true //é‡åˆ°ç¬¬ä¸€ä¸ªnilæ—¶å€™ï¼Œendå°±ä¸ºtrueï¼Œè¯´æ˜åç»­å°±ä¸åº”è¯¥å‡ºç°ã€énilã€‘èŠ‚ç‚¹
            } else { //é‡åˆ°énilèŠ‚ç‚¹
                if end {
                    return false
                }
                //ä¸åˆ¤æ–­æ˜¯å¦ä¸ºnilï¼Œç›´æ¥åŠ å…¥
                nodes = append(nodes,nodes[i].Left)
                nodes = append(nodes,nodes[i].Right)
            }
        }
        nodes = nodes[size:]//è¸¢å‡ºå·²ç»éå†è¿‡çš„èŠ‚ç‚¹
    }
    return true
}
```
## 55. è·³è·ƒæ¸¸æˆ
ç»™ä½ ä¸€ä¸ªéè´Ÿæ•´æ•°æ•°ç»„ `nums` ï¼Œä½ æœ€åˆä½äºæ•°ç»„çš„ **ç¬¬ä¸€ä¸ªä¸‹æ ‡** ã€‚æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ ä»£è¡¨ä½ åœ¨è¯¥ä½ç½®å¯ä»¥è·³è·ƒçš„æœ€å¤§é•¿åº¦ã€‚
åˆ¤æ–­ä½ æ˜¯å¦èƒ½å¤Ÿåˆ°è¾¾æœ€åä¸€ä¸ªä¸‹æ ‡ï¼Œå¦‚æœå¯ä»¥ï¼Œè¿”å› `true` ï¼›å¦åˆ™ï¼Œè¿”å› `false` ã€‚
æ€è·¯ï¼š
ä»å°¾éƒ¨å¼€å§‹å€’åºéå†ï¼›è¦æƒ³åˆ°è¾¾å°¾éƒ¨ï¼Œçœ‹ä¸‹å‰é¢çš„æŸä¸ªèŠ‚ç‚¹èƒ½å¦è¾¾åˆ°å°¾éƒ¨ï¼›æ¯”å¦‚æŸä¸ªèŠ‚ç‚¹`x`å¯ä»¥åˆ°è¾¾å°¾éƒ¨ï¼›é‚£å°±ç»§ç»­çœ‹`x`ä¹‹å‰çš„æŸä¸ªèŠ‚ç‚¹èƒ½å¦åˆ°è¾¾`x`ï¼Œé—´æ¥çš„ç­‰ä»·äºå¯ä»¥åˆ°è¾¾å°¾éƒ¨ï¼›

```go
func canJump(nums []int) bool {
  
    targetIdx := len(nums)-1 //æœŸæœ›åˆ°è¾¾çš„ä½ç½®
  
  	// i ä»å€’æ•°ç¬¬äºŒä¸ªç´¢å¼• targetIdx-1å¼€å§‹
    for i := targetIdx-1;i >= 0;i-- {
      
        if nums[i] +i >= targetIdx { // ä»ä½ç½®ièƒ½åˆ°è¾¾ targetIdx ä½ç½®
            // é‚£ä¹ˆæœŸæœ›åˆ°è¾¾çš„æ–°ä½ç½®ä¸ºiï¼Œåªè¦å‰é¢çš„å…¶ä»–çš„èŠ‚ç‚¹åˆ°è¾¾i, ç­‰ä»·äºé—´æ¥çš„å¯ä»¥åˆ°è¾¾å°¾éƒ¨
            targetIdx = i 
        }
    }
    return targetIdx == 0 // æœŸæœ›åˆ°è¾¾çš„ä½ç½®ä¸º0çš„æ—¶å€™ï¼Œè€Œæ­¤æ—¶æˆ‘ä»¬è¦ä»0çš„ä½ç½®å‡ºå‘ï¼Œæ‰€ä»¥å°±å¯ä»¥è¡¨æ˜æˆ‘ä»¬èƒ½åˆ°è¾¾å°¾éƒ¨ï¼›
}
```
## è¡¥å……é¢˜23ï¼šæ£€æµ‹å¾ªç¯ä¾èµ–
ç›´æ¥çœ‹è¿™ç¯‡æ–‡ç« å³å¯ [https://mp.weixin.qq.com/s/pCRscwKqQdYYN7M1Sia7xA](https://mp.weixin.qq.com/s/pCRscwKqQdYYN7M1Sia7xA) æ–‡ç« é‡‡ç”¨`BFS`çš„æ–¹å¼æ¥å¯»æ‰¾ä¾èµ–å…³ç³»ï¼Œä¹Ÿå°±æ˜¯æ‹“æ‰‘æ’åºã€‚
å¦‚æœæœ‰å°è±¡çš„è¯ï¼Œè¿™é¢˜å…¶å®å’Œ **207. è¯¾ç¨‹è¡¨**æ˜¯ç±»ä¼¼çš„é¢˜ç›®ï¼Œä¸è¿‡é‡‡ç”¨çš„æ˜¯`DFS`çš„å†™æ³•ã€‚**210. è¯¾ç¨‹è¡¨ II**å»ºè®®ä¹Ÿçœ‹ä¸‹ï¼Œä½ ä¼šå‘ç°å’Œ**207. è¯¾ç¨‹è¡¨**ç­”æ¡ˆå‡ ä¹ä¸€æ ·ã€‚
## LCR 170. äº¤æ˜“é€†åºå¯¹çš„æ€»æ•°
åœ¨è‚¡ç¥¨äº¤æ˜“ä¸­ï¼Œå¦‚æœå‰ä¸€å¤©çš„è‚¡ä»·é«˜äºåä¸€å¤©çš„è‚¡ä»·ï¼Œåˆ™å¯ä»¥è®¤ä¸ºå­˜åœ¨ä¸€ä¸ªã€Œäº¤æ˜“é€†åºå¯¹ã€ã€‚è¯·è®¾è®¡ä¸€ä¸ªç¨‹åºï¼Œè¾“å…¥ä¸€æ®µæ—¶é—´å†…çš„è‚¡ç¥¨äº¤æ˜“è®°å½• `record`ï¼Œè¿”å›å…¶ä¸­å­˜åœ¨çš„ã€Œäº¤æ˜“é€†åºå¯¹ã€æ€»æ•°ã€‚
**ç¤ºä¾‹ 1ï¼š**

```go
è¾“å…¥ï¼šrecord = [9, 7, 5, 4, 6]
è¾“å‡ºï¼š8
è§£é‡Šï¼šäº¤æ˜“ä¸­çš„é€†åºå¯¹ä¸º (9, 7), (9, 5), (9, 4), (9, 6), (7, 5), (7, 4), (7, 6), (5, 4)ã€‚
```
æ€è·¯ï¼š
æœ¬é¢˜æ˜¯**å½’å¹¶æ’åº**çš„åº”ç”¨ã€‚
å½’å¹¶æ’åºå¥—è·¯ï¼š
![742fe961-e37b-40bc-bfd9-d5173aeaac3d.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411715262-742fe961-e37b-40bc-bfd9-d5173aeaac3d.png)


- å°†æ•°ç»„ä¸æ–­çš„æ‹†åˆ†æˆä¸¤ä¸¤å­æ•°ç»„ï¼ˆå¹¶è¿›è¡Œæ’åºï¼‰ï¼Œæœ€åå†ä¸æ–­çš„ä¸¤ä¸¤åˆå¹¶æœ‰åºå­æ•°ç»„ï¼Œå˜æˆä¸€ä¸ªæ›´å¤§çš„æœ‰åºå­æ•°ç»„é€†åºå¯¹çš„è®°å½•ï¼Œå°±æ˜¯åœ¨åˆå¹¶çš„è¿‡ç¨‹ä¸­ï¼Œå¯¹æœ‰åºæ•°ç»„ï¼Œå¤šä¸€ä¸ªæ¯”è¾ƒçš„è¿‡ç¨‹ã€‚
![d94683aa-dbb7-41b3-9c65-109f5b1919f6.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411715146-d94683aa-dbb7-41b3-9c65-109f5b1919f6.png)

![0607fedd-3bfc-49ee-86cb-afd56130028b.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411715434-0607fedd-3bfc-49ee-86cb-afd56130028b.png)

å…·ä½“çœ‹ä¸‹é¢ä»£ç 

```go
var temp []int
var count int
func reversePairs(record []int) int {
    count = 0

    n := len(record)
    if n == 0 { // ç©ºæ•°ç»„ï¼Œä¸ç”¨æ’åº
        return count
    }
    // å½’å¹¶æ’åº
    temp = make([]int,len(record))
    sort(record,0,len(record)-1)
    return count
}

// sortå‡½æ•°å®šä¹‰ï¼š å¯¹æ•°ç»„record [lo,hi]èŒƒå›´å†…çš„å…ƒç´ è¿›è¡Œæ’åºï¼ˆå‡åºï¼‰
func sort(record []int, lo,hi int) { 
    if lo == hi { // è¯´æ˜åªæœ‰ä¸€ä¸ªå…ƒç´ 
        return
    }
    // æ‹†åˆ†æˆä¸¤ä¸ªå­æ•°ç»„
    mid := lo + (hi-lo)/2
    sort(record,lo,mid) //å¯¹å‰åŠéƒ¨åˆ†è¿›è¡Œæ’åº
    sort(record,mid+1,hi)// å¯¹ååŠéƒ¨åˆ†è¿›è¡Œæ’åº
    merge(record,lo,mid,hi) // åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„

}

func merge(record []int, lo ,mid ,hi int) {
    // lo æŒ‡å‘å‰åŠéƒ¨åˆ†çš„æœ‰åºæ•°ç»„ï¼Œé¦–éƒ¨
    // mid+1 æŒ‡å‘ååŠéƒ¨åˆ†çš„æœ‰åºæ•°ç»„ï¼Œé¦–éƒ¨

    //1.å…ˆå°†æœ‰åºæ•°ç»„recordï¼Œæ”¾åˆ°tempä¸­ä¿å­˜ï¼ˆå¤åˆ¶ä¸€ä»½ï¼‰ï¼Œæ­¤æ—¶çš„recordå’Œtempæ˜¯å®Œå…¨ä¸€æ ·çš„ï¼›
    for i := lo;i <= hi;i++ {
        temp[i] = record[i]
    }


   	
    // è¿™é‡Œå°±æ˜¯è®¡ç®—é€†åºå¯¹çš„ä»£ç é€»è¾‘
  
    j := mid+1 //è¡¨ç¤ºåé¢çš„å­æ•°ç»„æŒ‡é’ˆ
    for i := lo;i <= mid;i++ { // iè¡¨ç¤ºå‰é¢çš„å­æ•°ç»„æŒ‡é’ˆ
        for j <= hi && record[i] > record[j] { // è¯´æ˜ ã€å‰é¢çš„å…ƒç´  > åé¢çš„å…ƒç´ ã€‘ï¼Œæ˜¯ä¸€ä¸ªã€é€†åºå¯¹ã€‘
            j++
        }
      	// æ‰§è¡Œåˆ°è¿™é‡Œï¼Œè¯´æ˜[mid+1,j) ä¹‹é—´çš„å…ƒç´ ï¼Œå’Œrecord[i]ä½ç½®çš„å…ƒç´ ï¼Œéƒ½å¯ä»¥æ„æˆé€†åºå¯¹
        count += j - (mid+1) // é€†åºå¯¹çš„ä¸ªæ•°
    }


    //2.ç„¶ååˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„tempï¼Œå°†ç»“æœä¿å­˜åˆ°recordä¸­

    left := lo // tempä¸­çš„å·¦è¾¹å­æ•°ç»„
    right := mid+1 // tempä¸­çš„å³è¾¹å­æ•°ç»„

    for p := lo;p <= hi;p++ { //è¿™é‡Œçš„pè¡¨ç¤ºrecordçš„ä½ç½®

        if left == mid+1 { // è¯´æ˜tempå·¦è¾¹çš„å­æ•°ç»„å·²ç»éå†å®Œäº†
            record[p] = temp[right] // å‰©ä¸‹tempå³è¾¹çš„ï¼Œæ”¾å…¥è¿›å»
            right++
        } else if right == hi+1 { // è¯´æ˜tempå³è¾¹çš„å­æ•°ç»„å·²ç»éå†å®Œäº†
            record[p] = temp[left]/// å‰©ä¸‹tempå·¦è¾¹çš„ï¼Œæ”¾å…¥è¿›å»
            left++
        } else if temp[left] > temp[right] {
            record[p] = temp[right] // æ”¾å°çš„è¿›å»
            right++
        } else {
            record[p] = temp[left] // æ”¾å°çš„è¿›å»
            left++
        }
    }

}
```
## 7. æ•´æ•°åè½¬
ç»™ä½ ä¸€ä¸ª 32 ä½çš„æœ‰ç¬¦å·æ•´æ•° `x` ï¼Œè¿”å›å°† `x` ä¸­çš„æ•°å­—éƒ¨åˆ†åè½¬åçš„ç»“æœã€‚
å¦‚æœåè½¬åæ•´æ•°è¶…è¿‡ 32 ä½çš„æœ‰ç¬¦å·æ•´æ•°çš„èŒƒå›´ `[âˆ’231, 231 âˆ’ 1]` ï¼Œå°±è¿”å› 0ã€‚
**å‡è®¾ç¯å¢ƒä¸å…è®¸å­˜å‚¨ 64 ä½æ•´æ•°ï¼ˆæœ‰ç¬¦å·æˆ–æ— ç¬¦å·ï¼‰ã€‚**
**ç¤ºä¾‹ 1ï¼š**
**ç¤ºä¾‹ 2ï¼š**
æ€è·¯ï¼š
è¿™é¢˜å…¶å®å°±æ˜¯è€ƒå¯Ÿ**å–ä½™**

```go
func reverse(x int) int {
    res := 0
    for x != 0 {
        res = res * 10 + x % 10 // x % 10æ±‚ä½™ 
        x = x / 10
    }
		// é¢˜ç›®è¦æ±‚
    if res >= math.MaxInt32 || res <= math.MinInt32 {
        return 0
    }
    return res
}
```
## 40. ç»„åˆæ€»å’ŒII
ç»™å®šä¸€ä¸ªå€™é€‰äººç¼–å·çš„é›†åˆ `candidates` å’Œä¸€ä¸ªç›®æ ‡æ•° `target` ï¼Œæ‰¾å‡º `candidates` ä¸­æ‰€æœ‰å¯ä»¥ä½¿æ•°å­—å’Œä¸º `target` çš„ç»„åˆã€‚
`candidates` ä¸­çš„æ¯ä¸ªæ•°å­—åœ¨æ¯ä¸ªç»„åˆä¸­åªèƒ½ä½¿ç”¨ **ä¸€æ¬¡** ã€‚
**æ³¨æ„ï¼š**è§£é›†ä¸èƒ½åŒ…å«é‡å¤çš„ç»„åˆã€‚
æ€è·¯ï¼š
å»ºè®®å’Œ**39. ç»„åˆæ€»å’Œ**å¯¹æ¯”å­¦ä¹ ä¸‹ã€‚
æœ¬é¢˜è§£é¢˜çš„å…³é”®ç‚¹åœ¨äºä¸‹é¢å‡ ä¸ªæ¡ä»¶çš„é™åˆ¶ï¼š

- å…ƒç´ å­˜åœ¨é‡å¤
- ç»„åˆä¸èƒ½æœ‰é‡å¤çš„ç»“æœ
- æ¯ä¸ªæ•°å­—åœ¨æ¯ä¸ªç»„åˆä¸­åªèƒ½ä½¿ç”¨ä¸€æ¬¡
```go
var result [][]int

func combinationSum2(candidates []int, target int) [][]int {
	// å›æº¯ç®—æ³•
	result = [][]int{}
	// 1.æ’åº ï¼Œéå¸¸é‡è¦ä¸€ç‚¹ï¼Œå¿…é¡»æ•´ä¸ªæ•°ç»„æ˜¯æœ‰åºçš„ï¼ˆå› ä¸ºåŒ…å«é‡å¤çš„æ•°å­—ï¼Œä¸ºäº†åˆ¤æ–­ï¼‰
	sort.Ints(candidates)
	// 2.å›æº¯
	path := []int{}
	backtrack(0, candidates, path, 0, target)
	return result
}

// startä¿è¯æ¯æ¬¡é€‰æ‹©å…ƒç´ çš„èµ·å§‹èŒƒå›´ï¼Œä¸ç”¨æ¯æ¬¡éƒ½æ˜¯ä»start==0å¼€å§‹ï¼Œå› ä¸ºè¦æ‰¾çš„æ˜¯ç»„åˆï¼Œè€Œä¸æ˜¯æ’åˆ—
func backtrack(start int, candidates, path []int, sum int, target int) {

	if sum >= target { // è¿™é‡Œçš„  1 <= candidates[i] <= 50 éƒ½æ˜¯æ­£æ•°ï¼Œæ‰€ä»¥ sum > target å°±å¯ä»¥é€€å‡ºäº†
		if sum == target {
			// ä¸€ä¸ªç»„åˆç»“æœ
			t := make([]int, len(path))
			copy(t, path)
			result = append(result, t)
		}
		return
	}

	for i := start; i < len(candidates); i++ {
		// ã€æœ¬æ¬¡å¾ªç¯ã€‘é‡å¤çš„æ•°å­—ä¸å†é€‰æ‹©ï¼ˆä¿è¯è§£é›†ä¸åŒ…å«é‡å¤çš„ç»„åˆï¼‰
    // ä¾‹å¦‚  1 1 2 æ±‚target = 3,ç¬¬ä¸€ä¸ª1ä½¿ç”¨è¿‡äº†ï¼Œç¬¬äºŒä¸ª1å°±ä¸ç”¨å†ä½¿ç”¨äº†ã€‚
		if i-1 >= start && candidates[i-1] == candidates[i] {
			continue
		}
        
		path = append(path, candidates[i])
    sum += candidates[i]
    // ä¸‹ä¸€ä¸ªå…ƒç´ ä¸º i+1ï¼Œä¿è¯æ¯ä¸ªå…ƒç´ åœ¨ä¸€ä¸ªç»„åˆä¸­åªèƒ½ä½¿ç”¨ä¸€æ¬¡
		backtrack( i+1, candidates, path, sum, target)
		path = path[:len(path)-1]
    sum -= candidates[i]
	}
}
```
## 16. æœ€æ¥è¿‘çš„ä¸‰æ•°ä¹‹å’Œ
ç»™ä½ ä¸€ä¸ªé•¿åº¦ä¸º `n` çš„æ•´æ•°æ•°ç»„ `nums` å’Œ ä¸€ä¸ªç›®æ ‡å€¼ `target`ã€‚è¯·ä½ ä» `nums` ä¸­é€‰å‡ºä¸‰ä¸ªæ•´æ•°ï¼Œä½¿å®ƒä»¬çš„å’Œä¸ `target` æœ€æ¥è¿‘ã€‚
è¿”å›è¿™ä¸‰ä¸ªæ•°çš„å’Œã€‚
å‡å®šæ¯ç»„è¾“å…¥åªå­˜åœ¨æ°å¥½ä¸€ä¸ªè§£ã€‚
æ€è·¯ï¼š

- å…ˆæ’åºï¼ˆæ’åºçš„ç›®çš„æ˜¯ä¸ºäº†ä½¿ç”¨äºŒåˆ†æœç´¢ï¼Œå› ä¸ºäºŒåˆ†æœç´¢éœ€è¦æ•°æ®æ˜¯æœ‰åºçš„ï¼‰
- å›ºå®šç¬¬ä¸€ä¸ªæ•°`nums[i]`ï¼Œå†å» `nums[i+1..]` ä¸­å¯»æ‰¾å¦å¤–ä¸¤ä¸ªæ•°å­—ï¼Œä½¿ä¸‰æ•°ä¹‹å’Œæ— é™æ¥è¿‘`target`è§£é‡Šä¸‹ä»£ç ç‰‡æ®µçš„å«ä¹‰

```go
// è¿™é‡Œåªæ˜¯ä¸ºäº†å‡æï¼ˆé¿å…å¤šæ¬¡è®¡ç®—ï¼‰
if i-1 >= 0 && nums[i-1] == nums[i] { // è¡¨ç¤ºå½“å‰æ•°å­— nums[i]å’Œå‰ä¸€ä¸ªæ•°å­—nums[i-1]ç›¸åŒï¼Œç›´æ¥è·³è¿‡
  	continue
}
```
![0082a8ac-72e7-4a9a-a9b7-1825adf05b7e.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411715574-0082a8ac-72e7-4a9a-a9b7-1825adf05b7e.png)


```go
for left < right && nums[left] == leftValue { // é‡å¤çš„æ•°å€¼ï¼Œç›´æ¥è·³è¿‡
  	left++ // left++ ç›®çš„è®© sumå˜å¤§ä¸€äº›
}
```
![0104211d-69af-4147-b50e-281b112419c6.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411715745-0104211d-69af-4147-b50e-281b112419c6.png)

è¿™é¢˜çš„ç­”æ¡ˆå’Œä¹‹å‰çš„æ±‚**15. ä¸‰æ•°ä¹‹å’Œ**çš„éƒ¨åˆ†ä»£ç æ˜¯é›·åŒçš„ï¼ˆä¸è®°å¾—å¯ä»¥å»å¤ä¹ ä¸‹ï¼‰

```go
func threeSumClosest(nums []int, target int) int {

    sort.Ints(nums)// æ­£å‘æ’åº

    result := math.MaxInt
   
    for i := 0;i < len(nums);i++ {

        // è¿™é‡Œåªæ˜¯ä¸ºäº†å‡æï¼ˆé¿å…å¤šæ¬¡è®¡ç®—ï¼‰
      	if i-1 >= 0 && nums[i-1] == nums[i] { // è¡¨ç¤ºå½“å‰æ•°å­— nums[i]å’Œå‰ä¸€ä¸ªæ•°å­—nums[i-1]ç›¸åŒï¼Œç›´æ¥è·³è¿‡
            continue
        }
      // å›ºå®šæ•°å­—nums[i], åœ¨ [i+1:len(nums)-1] èŒƒå›´æ‰¾å¦å¤–ä¸¤ä¸ªæ•°å­—
        left ,right := i+1, len(nums)-1 
        for left < right {
            
            leftValue := nums[left]
            rightValue := nums[right]
            sum := nums[i] + leftValue + rightValue

            // è¯´æ˜sumæ›´æ¥è¿‘äºtargetï¼Œè®°å½•ä¸‹æ¥
            if abs(sum - target) < abs(result- target) {
                result = sum
            }

            if sum < target { 

                for left < right && nums[left] == leftValue { // é‡å¤çš„æ•°å€¼ï¼Œç›´æ¥è·³è¿‡
                    left++ // left++ ç›®çš„è®© sumå˜å¤§ä¸€äº›
                }
                
            } else { 
                for left < right && nums[right] == rightValue { // é‡å¤çš„æ•°å€¼ï¼Œç›´æ¥è·³è¿‡
                    right-- // right-- ç›®çš„è®©sumå˜å°ä¸€äº›
                }
            }
        }
    }
    return result
}

func abs(a int) int {
    if a < 0 {
        return -a
    }
    return a
}
```
## 61. æ—‹è½¬é“¾è¡¨
ç»™ä½ ä¸€ä¸ªé“¾è¡¨çš„å¤´èŠ‚ç‚¹ `head` ï¼Œæ—‹è½¬é“¾è¡¨ï¼Œå°†é“¾è¡¨æ¯ä¸ªèŠ‚ç‚¹å‘å³ç§»åŠ¨ `k` ä¸ªä½ç½®ã€‚

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func rotateRight(head *ListNode, k int) *ListNode {
    // åˆå§‹ï¼šç©º/åªæœ‰ä¸€ä¸ª/ç§»åŠ¨0ä½
    if head == nil || head.Next == nil || k == 0{
        return head
    }

    //1.é“¾è¡¨é•¿åº¦ && p æŒ‡å‘é“¾è¡¨å°¾éƒ¨
    count := 1
    p := head
    for p.Next != nil {
        count++
        p = p.Next
    }

    k = k % count
    if k == 0 { // kæ˜¯countçš„æ•´æ•°å€ï¼Œç­‰ä»·äºä¸ç§»åŠ¨
        return head
    }

    // 2.é¦–ä½ä¸²æˆç¯
    p.Next = head

    // 3. æ‰¾åˆ°ï¼Œéœ€è¦æ–­å¼€çš„èŠ‚ç‚¹
    count = count - k
    for count > 0 {
        p = p.Next
        count--
    }
    // æ­¤æ—¶pæ˜¯ç»“æœçš„ å°¾éƒ¨èŠ‚ç‚¹
		// p.Nextæ‰æ˜¯æ–°é“¾è¡¨çš„å¤´èŠ‚ç‚¹
    result := p.Next // é“¾è¡¨å¤´èŠ‚ç‚¹
    p.Next = nil // æ–­å¼€

    return result
}
```
## 123.ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº III
ç»™å®šä¸€ä¸ªæ•°ç»„ï¼Œå®ƒçš„ç¬¬ `i` ä¸ªå…ƒç´ æ˜¯ä¸€æ”¯ç»™å®šçš„è‚¡ç¥¨åœ¨ç¬¬ `i` å¤©çš„ä»·æ ¼ã€‚è®¾è®¡ä¸€ä¸ªç®—æ³•æ¥è®¡ç®—ä½ æ‰€èƒ½è·å–çš„æœ€å¤§åˆ©æ¶¦ã€‚ä½ æœ€å¤šå¯ä»¥å®Œæˆ **ä¸¤ç¬”** äº¤æ˜“ã€‚
**æ³¨æ„ï¼š**ä½ ä¸èƒ½åŒæ—¶å‚ä¸å¤šç¬”äº¤æ˜“ï¼ˆä½ å¿…é¡»åœ¨å†æ¬¡è´­ä¹°å‰å‡ºå”®æ‰ä¹‹å‰çš„è‚¡ç¥¨ï¼‰ã€‚
æ€è·¯ï¼š
ä¸Šé¢å·²ç»å†™äº†**ä¹°å–è‚¡ç¥¨çš„ 121 122 é¢˜**ï¼Œå…³é”®ç‚¹åœ¨ä¸ç†è§£åŠ¨æ€è§„åˆ’ä¸­`dp`æ•°ç»„çš„å®šä¹‰ã€‚
`dp[i][k][0 or 1]` çš„å«ä¹‰å°±æ˜¯ï¼š`i`è¡¨ç¤º åœ¨ä» `0`åˆ° `i`å¤©ï¼Œå®Œæˆäº†`k`ç¬”äº¤æ˜“ï¼Œæ­¤æ—¶ä¸æŒæœ‰`0` or æŒæœ‰ `1`è‚¡ç¥¨ï¼Œèƒ½è·å–çš„æœ€å¤§åˆ©æ¶¦ä¸º`dp[i][k][0 or 1]`
ä¸€å®šè¦ç†è§£ `i`ä¸æ˜¯æŒ‡çš„ä»…ä»…ç¬¬`i`å¤©ï¼Œè€Œæ˜¯æ—¶é—´æ®µä»`0`åˆ°`i`
`k`è¡¨ç¤ºåœ¨è¿™ä¸ªæ—¶é—´å†…å·²ç»å®Œæˆäº†`k`ç¬”äº¤æ˜“ï¼ˆå¦‚æœé¢˜ç›®æ²¡æœ‰å¯¹äº¤æ˜“æ¬¡æ•°è¿›è¡Œé™å®šï¼Œå¯ä»¥ä¸è¦è¿™ä¸ªï¼‰
`0 å’Œ 1`çš„å«ä¹‰ï¼šæ­¤æ—¶æ‰‹ä¸­çš„è‚¡ç¥¨æ˜¯æŒæœ‰è¿˜æ˜¯ä¸æŒæœ‰ï¼ˆæ„æ€å°±æ˜¯ï¼Œæˆ‘ä¹°äº†è‚¡ç¥¨æˆ‘å¯ä»¥ä¸€ç›´æ‹¿ç€ä¸å–ï¼Œä¹Ÿå¯ä»¥å–æ‰ï¼‰ï¼Œåˆ°äº†ç¬¬`i`å¤©æ­¤æ—¶è‚¡ç¥¨æ˜¯æ‹¿ç€è¿˜æ˜¯å·²ç»å–äº†ã€‚
æ³¨æ„é¢˜ç›®ä¸­æœ‰ä¸ª**æ³¨æ„äº‹é¡¹**ï¼šä½ ä¸èƒ½åŒæ—¶å‚ä¸å¤šç¬”äº¤æ˜“ï¼Œä¹Ÿå°±æ˜¯ä½ å¦‚æœç°åœ¨æŒæœ‰è‚¡ç¥¨ï¼Œæ­¤æ—¶å¦‚æœè¿˜æƒ³ä¹°ï¼Œå°±éœ€è¦å…ˆå–æ‰ä¹‹å‰çš„è‚¡ç¥¨ä¿è¯æ˜¯ç©ºä»“çš„çŠ¶æ€ï¼Œæ‰èƒ½å»ä¹°å…¶ä»–çš„ï¼ˆå½“ç„¶ï¼Œä½ å¯ä»¥ä¸€ç›´ç©ºä»“ï¼Œä¸å»è¿›è¡Œä»»ä½•äº¤æ˜“ï¼‰
æ¥ä¸‹æ¥è¯·ç†è§£ä¸‹é¢çš„çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼ˆå…¶å®å¾ˆç®€å•ï¼Œç”¨æ—¥å¸¸çš„æ€ç»´å»ç†è§£ï¼‰

```go
çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š
// ä¸æŒæœ‰è‚¡ç¥¨
// dp[i][k][0] ä» 0..iå¤©,å®Œæˆkç¬”äº¤æ˜“ï¼Œ0è¡¨ç¤ºæ­¤æ—¶æ‰‹ä¸­æ²¡æœ‰è‚¡ç¥¨
dp[i][k][0] = max(dp[i-1][k][0],dp[i-1][k][1] + prices[i]) 
// è¦è¾¾æˆ  dp[i][k][0] è¿™ä¸ªçŠ¶æ€ï¼Œå…¶å®æœ‰ä¸¤ç§æƒ…å†µ
// ç¬¬ä¸€ç§ï¼š ä» 0...i-1å¤©ï¼Œå®Œæˆäº†kç¬”äº¤æ˜“ï¼Œå¹¶ä¸”æ­¤æ—¶æ‰‹ä¸­ä¹Ÿæ²¡æœ‰è‚¡ç¥¨ï¼Œåˆ°äº†ç¬¬iå¤©ï¼Œæˆ‘ç»§ç»­ä¿æŒä¸äº¤æ˜“çš„ä¸å°±æ˜¯ dp[i][k][0]
// ç¬¬äºŒç§ï¼š ä» 0...i-1å¤©ï¼Œå®Œæˆäº†kç¬”äº¤æ˜“ï¼Œå¹¶ä¸”æ­¤æ—¶æ‰‹ä¸­æŒæœ‰è‚¡ç¥¨ï¼Œåˆ°äº†ç¬¬iå¤©ï¼Œæˆ‘è¦æƒ³ä¸æŒæœ‰è‚¡ç¥¨ï¼Œæ€ä¹ˆåŠï¼Ÿé‚£å°±åœ¨ç¬¬iå¤©å–æ‰å‘€ã€‚ã€‚æ—¢ç„¶æ˜¯å–æ‰ï¼Œé‚£åˆ©æ¶¦å°±è¦åŠ ä¸Š prices[i]çš„ä»·æ ¼å³å¯ã€‚


// æŒæœ‰è‚¡ç¥¨
// dp[i][k][1] ä» 0..iå¤©,å®Œæˆkç¬”äº¤æ˜“ï¼Œ1è¡¨ç¤ºæ­¤æ—¶æ‰‹ä¸­æŒæœ‰è‚¡ç¥¨
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i] ) 
// è¦è¾¾æˆ  dp[i][k][1] è¿™ä¸ªçŠ¶æ€ï¼Œå…¶å®æœ‰ä¸¤ç§æƒ…å†µ
// ç¬¬ä¸€ç§ï¼š ä» 0...i-1å¤©ï¼Œå®Œæˆäº†kç¬”äº¤æ˜“ï¼Œå¹¶ä¸”æ­¤æ—¶æ‰‹ä¸­æŒæœ‰è‚¡ç¥¨ï¼Œåˆ°äº†ç¬¬iå¤©ï¼ˆå› ä¸ºé¢˜ç›®ä¸­è¯´äº†ä¸èƒ½åŒæ—¶å‚ä¸å¤šç¬”äº¤æ˜“ï¼‰ï¼Œæ‰€ä»¥ç»§ç»­ä¿æŒæŒæœ‰çŠ¶æ€ï¼ˆä¸å¯èƒ½å–ï¼Œå–äº†å°±ä¸æ˜¯æŒæœ‰çŠ¶æ€äº†ï¼Œä½ ä¹Ÿå¯èƒ½è¯´ï¼Œæˆ‘å½“å¤©å–å½“å¤©ä¹°ï¼Œé‚£ä¸å°±ç­‰äºä¸ä¹°ä¸å–å—ï¼Œæ˜¯å§ã€‚ï¼‰
// ç¬¬äºŒç§ï¼šä» 0...i-1å¤©ï¼Œå®Œæˆäº† k-1 ç¬”äº¤æ˜“ï¼Œæ­¤æ—¶æ‰‹ä¸­æ²¡æœ‰æŒæœ‰è‚¡ç¥¨ï¼Œåˆ°äº†ç¬¬iå¤©ï¼Œä¹°å…¥è‚¡ç¥¨ï¼Œé‚£ä¹ˆç¬¬iå¤©ä¸å°±å¯ä»¥æŒæœ‰è‚¡ç¥¨äº†ï¼Œæ­¤æ—¶çš„äº¤æ˜“æ¬¡æ•° ä» k-1 å˜æˆäº† k æ¬¡ï¼ˆä¹°å…¥ç®—ä¸€æ¬¡äº¤æ˜“æ¬¡æ•°ï¼Œå–å‡ºå°±ä¸ç”¨å†ç®—äº¤æ˜“æ¬¡æ•°äº†ï¼‰ï¼Œæ—¢ç„¶æ˜¯ä¹°å…¥ï¼Œåˆ©æ¶¦å‡å» prices[i]çš„ä»·æ ¼å³å¯
```
æœ€ç»ˆçš„å®ç°ä»£ç å¦‚ä¸‹ï¼š

```go
func maxProfit(prices []int) int {
  
    n := len(prices)
  	// å®šä¹‰ dpæ•°ç»„
    dp := make([][][]int,n) //nå¤©

    for k,_ := range dp {
        dp[k] = make([][]int,3) // 2æ¬¡äº¤æ˜“ 0 1 2

        for k1,_:= range dp[k] {
            dp[k][k1] = make([]int,2) // æŒæœ‰orä¸æŒæœ‰
        }
    }

   

    for i := 0;i < n;i++ {
      	// k == 0 è¡¨ç¤ºå®Œæˆ0æ¬¡äº¤æ˜“ï¼Œä¹Ÿå°±æ˜¯ä¸ä¼šè¿›è¡Œäº¤æ˜“è‚¯å®šéƒ½æ˜¯0äº†ï¼Œä¸éœ€èµ‹å€¼äº†
        for k := 1;k <= 2;k++ {
            if i == 0 {
                dp[0][k][0] = 0 // ä¸æŒæœ‰
                dp[0][k][1] = -prices[0] // æŒæœ‰
                continue
            }
            dp[i][k][0] = max(dp[i-1][k][0],dp[i-1][k][1] + prices[i])
            dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i] )
        }
    }
		
  	// è¦æƒ³åˆ©æ¶¦æœ€å¤§ï¼Œé‚£è‚¯å®šæ˜¯å®Œæˆå¤šæ¬¡äº¤æ˜“ï¼Œå¹¶ä¸”æ‰‹ä¸­ä¸æŒæœ‰è‚¡ç¥¨
    return dp[n-1][2][0] // åœ¨ç¬¬n-1å¤©ï¼Œå®Œæˆ2ç¬”äº¤æ˜“ï¼Œå¹¶ä¸”ä¸æŒæœ‰è‚¡ç¥¨çš„æœ€å¤§åˆ©ç”¨
}

func max(a,b int) int {
    if a > b{
        return a
    }
    return b
}
```
## 238. å¥‡å¶é“¾è¡¨
ç»™å®šå•é“¾è¡¨çš„å¤´èŠ‚ç‚¹ `head` ï¼Œå°†æ‰€æœ‰ç´¢å¼•ä¸ºå¥‡æ•°çš„èŠ‚ç‚¹å’Œç´¢å¼•ä¸ºå¶æ•°çš„èŠ‚ç‚¹åˆ†åˆ«ç»„åˆåœ¨ä¸€èµ·ï¼Œç„¶åè¿”å›é‡æ–°æ’åºçš„åˆ—è¡¨ã€‚
**ç¬¬ä¸€ä¸ª**èŠ‚ç‚¹çš„ç´¢å¼•è¢«è®¤ä¸ºæ˜¯ **å¥‡æ•°** ï¼Œ **ç¬¬äºŒä¸ª**èŠ‚ç‚¹çš„ç´¢å¼•ä¸º **å¶æ•°** ï¼Œä»¥æ­¤ç±»æ¨ã€‚è¯·æ³¨æ„ï¼Œå¶æ•°ç»„å’Œå¥‡æ•°ç»„å†…éƒ¨çš„ç›¸å¯¹é¡ºåºåº”è¯¥ä¸è¾“å…¥æ—¶ä¿æŒä¸€è‡´ã€‚
ä½ å¿…é¡»åœ¨ `O(1)` çš„é¢å¤–ç©ºé—´å¤æ‚åº¦å’Œ `O(n)` çš„æ—¶é—´å¤æ‚åº¦ä¸‹è§£å†³è¿™ä¸ªé—®é¢˜ã€‚
![90672141-daf4-4391-8584-a4f26ed8ed10.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411715715-90672141-daf4-4391-8584-a4f26ed8ed10.png)

æ€è·¯ï¼š
å°†åŸå§‹é“¾è¡¨æ‹†åˆ†æˆä¸¤ä¸ªå­é“¾è¡¨ï¼Œç„¶åæ‹¼æ¥åˆ°ä¸€èµ·å³å¯ã€‚
è¿™é‡Œåˆ©ç”¨ `fast`ä¸€æ¬¡è·³è·ƒä¸¤ä¸ªèŠ‚ç‚¹ï¼š

- `fast`æŒ‡å‘çš„å°±æ˜¯å¥‡æ•°ç´¢å¼•èŠ‚ç‚¹
- `fast.Next`æŒ‡å‘çš„å°±æ˜¯å¶æ•°ç´¢å¼•èŠ‚ç‚¹ç‰¹æ®Šæƒ…å†µï¼Œå½“`fast`æŒ‡å‘å°¾éƒ¨æœ€åä¸€ä¸ªèŠ‚ç‚¹æ—¶å€™ï¼Œ`fast.Next`ä¸º`nil`,æ‰€ä»¥éœ€è¦å°†è¿™ä¸ª`fast`æŒ‡å‘çš„èŠ‚ç‚¹é¢å¤–å¤„ç†ï¼Œä½œä¸ºå¥‡æ•°ç´¢å¼•èŠ‚ç‚¹ï¼Œæ‹¼æ¥åˆ°`p1.Next`
![9c15fcf1-88d9-4ad7-b696-e2041e9f1e3f.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411715966-9c15fcf1-88d9-4ad7-b696-e2041e9f1e3f.png)


```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func oddEvenList(head *ListNode) *ListNode {

    p1 := &ListNode{} // å®šä¹‰å¤´èŠ‚ç‚¹ï¼Œè®°å½•å¥‡æ•°èŠ‚ç‚¹
    recordP1 := p1

    p2 := &ListNode{} // å®šä¹‰å¤´èŠ‚ç‚¹ï¼Œè®°å½•å¶æ•°èŠ‚ç‚¹
    recordP2 := p2

    fast := head

    // fast èŠ‚ç‚¹ + fast.Next éƒ½å­˜åœ¨çš„æƒ…å†µä¸‹ï¼Œè¿›è¡Œå¥‡å¶æ‹¼æ¥
    for fast != nil && fast.Next != nil {

        p1.Next = fast // å¥‡æ•°ç´¢å¼•æ‹¼æ¥åˆ° p1
        p1 = p1.Next

        p2.Next = fast.Next // å¶æ•°ç´¢å¼•æ‹¼æ¥åˆ° p2
        p2 = p2.Next

        // æ¯æ¬¡è·³è·ƒä¸¤ä¸ªèŠ‚ç‚¹
        fast = fast.Next.Next
    }

    // ç‰¹æ®Šæƒ…å†µï¼Œåªå‰©ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„æ—¶å€™ï¼ˆä¹Ÿå°±æ˜¯æ²¡æœ‰ fast.Next,ä¸Šé¢çš„é€»è¾‘æ˜¯ä¸ä¼šæ‰§è¡Œçš„ï¼‰
    if fast != nil { // ä¹Ÿå¯èƒ½ fast == nil ï¼Œæ‰€ä»¥ä¸ç”¨æ‰§è¡Œæ‹¼æ¥
        p1.Next = fast
        p1 = p1.Next
    }
    // p2éœ€è¦æ–­å¼€å°¾éƒ¨
    p2.Next = nil
    
    p1.Next = recordP2.Next // p1çš„å°¾éƒ¨ æ‹¼æ¥ä¸Š p2çš„å¤´éƒ¨
    return recordP1.Next // è¿”å›p1çš„å¤´éƒ¨
}
```
è¿™é‡Œå†æ‰©å±•ä¸€ä¸ªå˜å½¢é¢˜ï¼šå­—èŠ‚è·³åŠ¨å¸¸è€ƒ
ç»™å®šä¸€ä¸ªå¥‡æ•°ä½å‡åºï¼Œå¶æ•°ä½é™åºçš„é“¾è¡¨ï¼Œå°†å…¶é‡æ–°æ’åºã€‚

```go
è¾“å…¥: 1->8->3->6->5->4->7->2->NULL
è¾“å‡º: 1->2->3->4->5->6->7->8->NULL
```
é¢˜ç›®æ„æ€å°±æ˜¯å¶æ•°ç´¢å¼•ä½ç½®çš„æ˜¯é™åºçš„ï¼Œå¥‡æ•°ä½ç½®æ˜¯å‡åºçš„ï¼›éœ€è¦å°†æ•´ä¸ªé“¾è¡¨æ’åºä¸ºå‡åº
è§£æ³•ï¼š

```go
1. æŒ‰å¥‡å¶ä½ç½®æ‹†åˆ†é“¾è¡¨ï¼Œå¾—1->3->5->7->NULLå’Œ8->6->4->2->NULL
2. åè½¬å¶é“¾è¡¨ï¼Œå¾—1->3->5->7->NULLå’Œ2->4->6->8->NULL
3. åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨ï¼Œå¾—1->2->3->4->5->6->7->8->NULL
```
æŒ‰ç…§ä¸Šé¢çš„æ–¹æ³•ï¼Œæˆ‘ä»¬å·²ç»å¯ä»¥å¾—åˆ°å‡åºçš„å¥‡æ•°é“¾è¡¨å’Œ é™åºçš„å¶æ•°é“¾è¡¨ï¼›åªéœ€è¦å°†å¶æ•°é“¾è¡¨åè½¬ï¼Œç„¶ååˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨ä¸ºä¸€ä¸ªå‡åºé“¾è¡¨ã€‚
é“¾è¡¨åè½¬ä¸Šé¢å·²ç»åšè¿‡ç±»ä¼¼çš„é¢˜ç›®ï¼Œåˆå¹¶ä¸¤ä¸ªå‡åºé“¾è¡¨ä¹Ÿåšè¿‡ï¼Œå¤§å®¶å¯ä»¥ç”¨æ¥ç»ƒä¸‹æ‰‹ï¼Œè¯•è¯•ã€‚
## 518. é›¶é’±å…‘æ¢II
ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `coins` è¡¨ç¤ºä¸åŒé¢é¢çš„ç¡¬å¸ï¼Œå¦ç»™ä¸€ä¸ªæ•´æ•° `amount` è¡¨ç¤ºæ€»é‡‘é¢ã€‚è¯·ä½ è®¡ç®—å¹¶è¿”å›å¯ä»¥å‡‘æˆæ€»é‡‘é¢çš„ç¡¬å¸ç»„åˆæ•°ã€‚å¦‚æœä»»ä½•ç¡¬å¸ç»„åˆéƒ½æ— æ³•å‡‘å‡ºæ€»é‡‘é¢ï¼Œè¿”å› `0` ã€‚å‡è®¾æ¯ä¸€ç§é¢é¢çš„ç¡¬å¸æœ‰æ— é™ä¸ªã€‚ é¢˜ç›®æ•°æ®ä¿è¯ç»“æœç¬¦åˆ 32 ä½å¸¦ç¬¦å·æ•´æ•°ã€‚
æ€è·¯ï¼š
æˆ‘ä»¬å¯ä»¥æŠŠè¿™ä¸ªé—®é¢˜è½¬åŒ–ä¸ºèƒŒåŒ…é—®é¢˜çš„æè¿°å½¢å¼ï¼š
æœ‰ä¸€ä¸ªèƒŒåŒ…ï¼Œæœ€å¤§å®¹é‡ä¸º `amount`ï¼Œæœ‰ä¸€ç³»åˆ—ç‰©å“ `coins`ï¼Œæ¯ä¸ªç‰©å“çš„é‡é‡ä¸º `coins[i]`ï¼Œ**æ¯ä¸ªç‰©å“çš„æ•°é‡æ— é™**ã€‚è¯·é—®æœ‰å¤šå°‘ç§æ–¹æ³•ï¼Œèƒ½å¤ŸæŠŠèƒŒåŒ…æ°å¥½è£…æ»¡ï¼Ÿ
![b237f473-3c98-45f8-a7f9-6336a5791213.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411716269-b237f473-3c98-45f8-a7f9-6336a5791213.png)

æ³¨æ„ï¼š`i`è¡¨ç¤ºç‰©å“çš„ä¸ªæ•°ï¼Œå¦‚æœè¦å–åˆ°è¯¥ç‰©å“ï¼Œéœ€è¦`i-1`å¾—åˆ°ç´¢å¼•

```go
func change(amount int, coins []int) int {
	
		// å®šä¹‰ dp æ•°ç»„
    n := len(coins) // nä¸ªç‰©å“
    dp := make([][]int,n+1)
    for i := 0;i < n+1;i++ {
        dp[i] = make([]int,amount+1) // èƒŒåŒ…å®¹é‡ amount
    }

    // base case
    // èƒŒåŒ…å®¹é‡ä¸º0ï¼Œä¹Ÿå°±æ˜¯ä¸éœ€è¦é€‰æ‹©ç‰©å“ï¼Œå³å¯å®Œæˆå¡«å……
    for i := 0;i <= n;i++ {
        dp[i][0] = 1 // iä¸ªç‰©å“ï¼ŒèƒŒåŒ…å®¹é‡ä¸º0ï¼ˆä¹Ÿå°±æ˜¯å…¨éƒ½ä¸é€‰æ‹©ç‰©å“ï¼Œå³å¯å®Œæˆå¡«å……ï¼‰ï¼Œé»˜è®¤éƒ½æ˜¯1ç§ç»„åˆ
    }
    // ç‰©å“ä¸ªæ•°ä¸º0ï¼Œè‚¯å®šå°±æ˜¯0ï¼Œæ‰€ä»¥ä¸ç”¨é¢å¤–åˆå§‹åŒ–ï¼Œæ‰€ä»¥iä»1å¼€å§‹
    for i := 1;i <= n;i++ {
        for j := 1;j <= amount;j++ {
						// çœ‹ç¬¬iä¸ªç‰©å“ï¼Œèƒ½å¦è£…å…¥èƒŒåŒ…ï¼ˆæ³¨æ„ï¼šç¬¬iä¸ªç‰©å“ï¼Œå¯¹åº” coinsä¸­çš„i-1çš„ç´¢å¼•ï¼‰
            if j - coins[i-1] >= 0 { // è¯´æ˜ç‰©å“å¯ä»¥è£…å…¥èƒŒåŒ…ï¼ˆå¯ä»¥é€‰æ‹©è£…å…¥ or ä¸è£…å…¥ï¼‰ ä¸¤ç§ç»„åˆæ±‚å’Œ
                dp[i][j] = dp[i-1][j] + dp[i][j-coins[i-1]]
            } else { // è¯´æ˜ç‰©å“å¤ªå¤§ï¼Œæ— æ³•è£…å…¥ï¼ˆå³ï¼Œé€‰æ‹©ä¸è£…å…¥ï¼‰
                dp[i][j] = dp[i-1][j]
            }
        }
    }
  
    // nä¸ªç‰©å“ï¼Œè£…æ»¡èƒŒåŒ…amountçš„ç»„åˆ
    return dp[n][amount]
}
```
## 26. åˆ é™¤æœ‰åºæ•°ç»„ä¸­çš„é‡å¤é¡¹
ç»™ä½ ä¸€ä¸ª **éä¸¥æ ¼é€’å¢æ’åˆ—** çš„æ•°ç»„ `nums` ï¼Œè¯·ä½ **[åŸåœ°](http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)** åˆ é™¤é‡å¤å‡ºç°çš„å…ƒç´ ï¼Œä½¿æ¯ä¸ªå…ƒç´  **åªå‡ºç°ä¸€æ¬¡** ï¼Œè¿”å›åˆ é™¤åæ•°ç»„çš„æ–°é•¿åº¦ã€‚å…ƒç´ çš„ **ç›¸å¯¹é¡ºåº** åº”è¯¥ä¿æŒ **ä¸€è‡´** ã€‚ç„¶åè¿”å› `nums` ä¸­å”¯ä¸€å…ƒç´ çš„ä¸ªæ•°ã€‚
è€ƒè™‘ `nums` çš„å”¯ä¸€å…ƒç´ çš„æ•°é‡ä¸º `k` ï¼Œä½ éœ€è¦åšä»¥ä¸‹äº‹æƒ…ç¡®ä¿ä½ çš„é¢˜è§£å¯ä»¥è¢«é€šè¿‡ï¼š

- æ›´æ”¹æ•°ç»„ `nums` ï¼Œä½¿ `nums` çš„å‰ `k` ä¸ªå…ƒç´ åŒ…å«å”¯ä¸€å…ƒç´ ï¼Œå¹¶æŒ‰ç…§å®ƒä»¬æœ€åˆåœ¨ `nums` ä¸­å‡ºç°çš„é¡ºåºæ’åˆ—ã€‚`nums` çš„å…¶ä½™å…ƒç´ ä¸ `nums` çš„å¤§å°ä¸é‡è¦ã€‚
- è¿”å› `k` ã€‚æ€è·¯ï¼š
æœ‰åºæ•°ç»„ä¸­åˆ é™¤é‡å¤å‡ºç°çš„å…ƒç´ ï¼Œåˆ©ç”¨å¿«æ…¢æŒ‡é’ˆçš„æŠ€å·§ã€‚
æˆ‘ä»¬è®©æ…¢æŒ‡é’ˆ `slow` èµ°åœ¨åé¢ï¼Œå¿«æŒ‡é’ˆ `fast` èµ°åœ¨å‰é¢æ¢è·¯ï¼Œæ‰¾åˆ°ä¸€ä¸ªä¸é‡å¤çš„å…ƒç´ å°±å‘Šè¯‰ `slow` å¹¶è®© `slow` å‰è¿›ä¸€æ­¥ã€‚è¿™æ ·å½“ `fast` æŒ‡é’ˆéå†å®Œæ•´ä¸ªæ•°ç»„ `nums` åï¼Œ`**nums[0..slow]**`** å°±æ˜¯ä¸é‡å¤å…ƒç´ **ã€‚

```go
func removeDuplicates(nums []int) int {
  	
  	//æ³¨æ„ç†è§£ï¼šslowæŒ‡å‘çš„å…ƒç´ æ˜¯æœ€ç»ˆç»“æœçš„å°¾éƒ¨å…ƒç´ ï¼Œfast ç”¨æ¥éå†æ•´ä¸ªæ•°ç»„
    slow,fast := 0,0

    for fast < len(nums) {
        if nums[fast] != nums[slow] { // å½“slow å’Œ fastæŒ‡å‘çš„å…ƒç´ ä¸ç›¸åŒ
            slow++ // slowå…ˆå‰è¿›ä¸€æ­¥
            nums[slow] = nums[fast] // ç„¶ååœ¨slowä½ç½®å¤„ï¼Œä¿å­˜ä¸‹æ¥æœ€æ–°ä¸é‡å¤å…ƒç´ 
        }
        fast++ // fastä¸€ç›´ä¸æ–­çš„ç§»åŠ¨
    }
    // [0,slow]æŒ‡å‘çš„å°±æ˜¯æœ€ç»ˆçš„ç»“æœ

    return slow+1
}
```
## 75. é¢œè‰²åˆ†ç±»
ç»™å®šä¸€ä¸ªåŒ…å«çº¢è‰²ã€ç™½è‰²å’Œè“è‰²ã€å…± `n` ä¸ªå…ƒç´ çš„æ•°ç»„ `nums` ï¼Œ[**åŸåœ°**](https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95) å¯¹å®ƒä»¬è¿›è¡Œæ’åºï¼Œä½¿å¾—ç›¸åŒé¢œè‰²çš„å…ƒç´ ç›¸é‚»ï¼Œå¹¶æŒ‰ç…§çº¢è‰²ã€ç™½è‰²ã€è“è‰²é¡ºåºæ’åˆ—ã€‚
æˆ‘ä»¬ä½¿ç”¨æ•´æ•° `0`ã€ `1` å’Œ `2` åˆ†åˆ«è¡¨ç¤ºçº¢è‰²ã€ç™½è‰²å’Œè“è‰²ã€‚
å¿…é¡»åœ¨ä¸ä½¿ç”¨åº“å†…ç½®çš„ sort å‡½æ•°çš„æƒ…å†µä¸‹è§£å†³è¿™ä¸ªé—®é¢˜ã€‚

- ä½ èƒ½æƒ³å‡ºä¸€ä¸ªä»…ä½¿ç”¨å¸¸æ•°ç©ºé—´çš„ä¸€è¶Ÿæ‰«æç®—æ³•å—ï¼Ÿæ€è·¯ï¼š
è¿™é¢˜æ˜¯ä¸Šé¢ä¸€é¢˜å¿«æ…¢æŒ‡é’ˆæŠ€å·§çš„è¿›é˜¶ã€‚`slow`ç”¨æ¥ç»´æŠ¤æœ€ç»ˆçš„ç»“æœï¼Œ`fast`ç”¨æ¥éå†æ•´ä¸ªæ•°ç»„ï¼Œæœ€åæ•´ä¸ªæ•°ç»„åˆ†æˆäº†ä¸¤ä¸ªéƒ¨åˆ†ï¼Œä¸€éƒ¨åˆ†æ˜¯æœ€ç»ˆç»“æœï¼Œå¦å¤–ä¸€éƒ¨åˆ†æ˜¯å…¶ä»–æ•°æ®ã€‚ï¼ˆè¿™æ ·åªèƒ½åˆ†æˆä¸¤ä¸ªéƒ¨åˆ†ï¼‰
æœ¬é¢˜ï¼Œéœ€è¦å°†æ•°ç»„åˆ†å‰²æˆ3ä¸ªéƒ¨åˆ†ã€‚å¯ä»¥è€ƒè™‘ï¼Œåœ¨æ•°ç»„çš„å·¦å³éƒ½ç»´æŠ¤ä¸€ä¸ª `slow`æŒ‡é’ˆï¼Œç”¨æ¥è®°å½•ç»“æœã€‚ä¾ç„¶ç”¨`fast`æŒ‡é’ˆæ¥éå†æ•´ä¸ªæ•°ç»„ã€‚è¿™æ ·ï¼Œå°±å¯ä»¥å°†æ•´ä¸ªæ•°ç»„åˆ†å‰²æˆ3ä¸ªéƒ¨åˆ†ã€‚
æœ¬é¢˜å¯ä»¥å½“åšä¸€ä¸ªç»“è®ºè®°ä½å³å¯ï¼Œè¿™ç§æ’åºæ–¹æ³•ä¹Ÿå«ä¸‰è‰²æ’åºç®—æ³•ã€‚

- `fast`é‡åˆ° 0 ï¼Œå’Œå·¦è¾¹äº¤æ¢
- `fast`é‡åˆ° 1ï¼Œä¸äº¤æ¢
- `fast`é‡åˆ° 2ï¼Œå’Œå³è¾¹äº¤æ¢
```go
func sortColors(nums []int)  {
    // ä¸‰è‰²æ’åºï¼›è¿™é¢˜æˆ‘ä¸ªäººè§‰å¾—è§£æ³•è¿˜æ˜¯æŒºå®ç”¨çš„
    // ç”¨ä¸‰ä¸ªæŒ‡é’ˆï¼Œåˆ†åˆ«æŒ‡å‘ï¼Œå¤´/å°¾/ä¸­

    leftSlow,fast,rightSlow := 0,0,len(nums)-1
    for fast <= rightSlow { // fast å’Œ rightSlowç›¸é‡
      
        if nums[fast] == 0 { // å°†0å’Œå·¦è¾¹äº¤æ¢
          	
            nums[leftSlow],nums[fast] = nums[fast],nums[leftSlow]
            fast++
            leftSlow++ // æ­¤æ—¶ leftSlowæŒ‡å‘ä¸‹ä¸€ä¸ªå¾…ä¿å­˜ä½ç½®
          
        } else if nums[fast] == 1 { // 1 ç»§ç»­éå†
            fast++
        } else if nums[fast] ==2 { //å°†2å’Œå³è¾¹äº¤æ¢
            nums[fast],nums[rightSlow] = nums[rightSlow],nums[fast]
            //index++ è¿™é‡Œæ³¨æ„ï¼ˆä¸€ä¸ªå‘ï¼‰ï¼š2å’Œ rightSlow ä½ç½®çš„å…ƒç´ äº¤æ¢ä»¥åï¼Œindexä½ç½®çš„å…ƒç´ å¯èƒ½æ˜¯0æˆ–1ä¹Ÿå¯èƒ½æ˜¯2 ï¼Œä»ä¸Šé¢çŸ¥é“1  fast++,å¦‚æœæ˜¯0ï¼Œè¿˜è¦å’ŒleftSlow äº¤æ¢ï¼Œå¦‚æœæ˜¯2ï¼Œé‚£å°±éœ€è¦ç»§ç»­å’Œ rightSlowäº¤æ¢
            rightSlow-- // æ­¤æ—¶ rightSlowæŒ‡å‘ä¸‹ä¸€ä¸ªå¾…ä¿å­˜ä½ç½®
        }
    }
}
```
çœ‹å®Œç®—æ³•ï¼Œä¼°è®¡å¾ˆå¤šçš„ç–‘é—®ï¼Œæˆ‘è§‰å¾—å¯ä»¥å¯¹ç…§ä¸‹å›¾å†æ€è€ƒä¸‹
æœ¬å›¾é’ˆå¯¹ `nums[fast] ==2`è¿›è¡Œè§£é‡Š
![6796652d-f989-4766-a823-f601557dd5f6.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411716210-6796652d-f989-4766-a823-f601557dd5f6.png)

æœ¬å›¾é’ˆå¯¹ `nums[fast] == 0 `
![90ef7b5e-3507-4fbe-8637-92c768846bb2.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411716306-90ef7b5e-3507-4fbe-8637-92c768846bb2.png)

## LCR 159. åº“å­˜ç®¡ç† III
ä»“åº“ç®¡ç†å‘˜ä»¥æ•°ç»„ `stock` å½¢å¼è®°å½•å•†å“åº“å­˜è¡¨ï¼Œå…¶ä¸­ `stock[i]` è¡¨ç¤ºå¯¹åº”å•†å“åº“å­˜ä½™é‡ã€‚è¯·è¿”å›åº“å­˜ä½™é‡æœ€å°‘çš„ `cnt` ä¸ªå•†å“ä½™é‡ï¼Œè¿”å› **é¡ºåºä¸é™**ã€‚
**ç¤ºä¾‹ 1ï¼š**

```go
è¾“å…¥ï¼šstock = [2,5,7,4], cnt = 1
è¾“å‡ºï¼š[2]
```
**ç¤ºä¾‹ 2ï¼š**

```go
è¾“å…¥ï¼šstock = [0,2,3,6], cnt = 2
è¾“å‡ºï¼š[0,2] æˆ– [2,0]
```
æ€è·¯ï¼š
æœ¬é¢˜å°±æ˜¯æ±‚ï¼Œåœ¨æ— åºçš„æ•°ç»„ä¸­ï¼Œå¦‚ä½•æŸ¥æ‰¾æœ€å°çš„ä¸¤ä¸ªæ•°å­—
åˆ©ç”¨å¤§æ ¹å †ï¼Œå †å¤§å°é™å®šä¸º2ï¼Œå½“å †å®¹é‡è¶…è¿‡2çš„æ—¶å€™ï¼Œå¼¹å‡ºå †é¡¶çš„æœ€å¤§å…ƒç´ ï¼Œå‰©ä¸‹çš„å°±æ˜¯è¾ƒå°çš„ä¸¤ä¸ªå…ƒç´ ã€‚å½“æ‰€æœ‰çš„å…ƒç´ éå†ä¸€éï¼Œå¹¶ä¸”éƒ½ç»è¿‡å¤§æ ¹å †çš„è¿‡æ»¤åï¼Œæ­¤æ—¶å¤§æ ¹å †ä¸­å‰©ä½™çš„ä¸¤ä¸ªå…ƒç´ ï¼Œå°±æ˜¯è¦æ‰¾çš„å…ƒç´ ã€‚

```go
func inventoryManagement(stock []int, cnt int) []int {
	// æœ¬è´¨å°±æ˜¯æ‰¾ï¼Œåœ¨æœ‰åºæ•°ç»„ä¸­ï¼Œè·å–æœ€å°çš„cntä¸ªæ•°å€¼

    maxHeap := &MaxHeap{}

    heap.Init(maxHeap)
    for i := 0;i < len(stock);i++ { // éå†æ‰€æœ‰å…ƒç´ 

        heap.Push(maxHeap,stock[i]) // ä¿å­˜åˆ°å¤§æ ¹å †ä¸­
       	
      	// ä¿è¯å †ä¸­æ•°æ®ä¸ºcntä¸ª
       if maxHeap.Len() > cnt { // è¶…å‡ºcntä¸ªï¼Œå°±å¼¹å‡º
            heap.Pop(maxHeap)
       }
    }

    return maxHeap.data // æœ€åå‰©ä¸‹çš„å°±æ˜¯ç»“æœï¼ˆæœ€å°çš„ï¼‰
}

// ç»´æŠ¤å¤§æ ¹å †ï¼Œæœ€åå‰©ä¸‹çš„å°±æ˜¯æœ€å°çš„cntä¸ªæ•°

type MaxHeap struct {
    data []int
}

func (t *MaxHeap)Len() int {
    return len(t.data)
}

func (t *MaxHeap)Swap(i,j int) {
    t.data[i],t.data[j] = t.data[j],t.data[i]
}

func (t *MaxHeap)Less(i,j int) bool {
    return t.data[i] > t.data[j]
}

func (t *MaxHeap)Push(x any) {
    t.data = append(t.data,x.(int))
}

func (t *MaxHeap)Pop() any {
    x := t.data[len(t.data)-1]
    t.data = t.data[:len(t.data)-1]
    return x
}
```
## 59. èºæ—‹çŸ©é˜µ II
ç»™ä½ ä¸€ä¸ªæ­£æ•´æ•° `n` ï¼Œç”Ÿæˆä¸€ä¸ªåŒ…å« `1` åˆ° `n^2` æ‰€æœ‰å…ƒç´ ï¼Œä¸”å…ƒç´ æŒ‰é¡ºæ—¶é’ˆé¡ºåºèºæ—‹æ’åˆ—çš„ `n x n` æ­£æ–¹å½¢çŸ©é˜µ `matrix` ã€‚
![96389690-fdf7-47b2-8e60-9cf9879664d9.png](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/1748411716409-96389690-fdf7-47b2-8e60-9cf9879664d9.png)

æ€è·¯ï¼š
æœ¬é¢˜å’Œ **54.èºæ—‹çŸ©é˜µ**ç›¸ä¼¼ã€‚

- å…ˆæ„å»ºäºŒç»´æ•°ç»„
- è½¬åœˆçš„æ–¹å¼å°†æ•°æ®ä¿å­˜åˆ°äºŒç»´æ•°ç»„ä¸­
```go
func generateMatrix(n int) [][]int {


    // æ„å»º n*n çŸ©é˜µ
    matrix := make([][]int,n)
    for k := range matrix {
        matrix[k] = make([]int,n)
    }

    left,right := 0,n-1
    top,end := 0,n-1

    val := 1
		
  	// å¡«å…¥ n*n ä¸ªæ•°å€¼
    for val <= n*n {

        if top <= end { // ä¿è¯ top å’Œendä¸è¶Šç•Œ
          
            for i:= left;i <=right;i++ { //åœ¨ä¸Šé¢top ä»å·¦åˆ°å³
                matrix[top][i] = val
                val++
            }
        }
        top++

        if left <=right { // ä¿è¯ left å’Œ right ä¸è¶Šç•Œ
            for i := top;i <= end;i++ { //åœ¨å³è¾¹right ä»ä¸Šåˆ°ä¸‹
                matrix[i][right] = val
                val++
            }
        }
        right--


        if top <= end {  // ä¿è¯ top å’Œendä¸è¶Šç•Œ
            for i := right; i>=left;i-- { // åœ¨åº•éƒ¨endï¼Œä»å³åˆ°å·¦
                matrix[end][i] = val
                val++
            }
        }
        end--

        if left <= right { // ä¿è¯ left å’Œ right ä¸è¶Šç•Œ
            for i := end;i>= top;i-- { // åœ¨å·¦è¾¹ leftï¼Œä»ä¸‹åˆ°ä¸Š
                matrix[i][left]= val
                val++
            }
        }
        left++
    }
		// è¿”å›äºŒç»´æ•°ç»„
    return matrix
}
```
## 145. äºŒå‰æ ‘çš„ååºéå†
ç»™ä½ ä¸€æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„ **ååºéå†** ã€‚
æ€è·¯ï¼š
å°½å¯èƒ½åœ°å°†å·¦å­èŠ‚ç‚¹å‹å…¥æ ˆï¼Œç›´åˆ°æœ€å·¦è¾¹ã€‚ç„¶åå¤„ç†æ ˆé¡¶å…ƒç´ ï¼Œå¦‚æœæœ‰å³å­èŠ‚ç‚¹ä¸”æœªè¢«å¤„ç†è¿‡ï¼Œå°±è½¬å‘å¤„ç†å³å­èŠ‚ç‚¹ã€‚å¦åˆ™ï¼Œå¤„ç†å½“å‰èŠ‚ç‚¹ï¼Œå¹¶è®°å½•preï¼Œé˜²æ­¢é‡å¤å¤„ç†ã€‚
è¿™æ ·é€šè¿‡æ ˆæ¥æ¨¡æ‹Ÿé€’å½’çš„è¿‡ç¨‹ï¼ŒåŒæ—¶åˆ©ç”¨preå˜é‡æ¥æ ‡è®°å·²ç»å¤„ç†è¿‡çš„å³å­æ ‘ï¼Œé¿å…é‡å¤å…¥æ ˆã€‚æ•´ä¸ªè¿‡ç¨‹èƒ½å¤Ÿæ­£ç¡®åœ°æŒ‰ç…§ååºéå†çš„é¡ºåºè®¿é—®æ‰€æœ‰èŠ‚ç‚¹ã€‚
é‚£preçš„ä½œç”¨æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿæ¯”å¦‚åœ¨å¤„ç†å®ŒæŸä¸ªèŠ‚ç‚¹çš„å³å­æ ‘åï¼Œå½“å†æ¬¡å›åˆ°è¯¥èŠ‚ç‚¹æ—¶ï¼Œå¯ä»¥é€šè¿‡preåˆ¤æ–­å³å­æ ‘æ˜¯å¦å·²ç»å¤„ç†è¿‡ã€‚æ¯”å¦‚åœ¨ä¾‹å­ä¸­çš„èŠ‚ç‚¹2ï¼Œç¬¬ä¸€æ¬¡å¤„ç†æ—¶å‘ç°å³å­èŠ‚ç‚¹5æœªè¢«å¤„ç†ï¼Œæ‰€ä»¥å‹å›æ ˆï¼Œç„¶åå¤„ç†5ã€‚å½“å†æ¬¡å¤„ç†2æ—¶ï¼Œpreæ˜¯5ï¼Œä¹Ÿå°±æ˜¯å³å­èŠ‚ç‚¹å·²ç»è¢«å¤„ç†è¿‡äº†ï¼Œè¿™æ—¶å€™å°±å¯ä»¥å¤„ç†èŠ‚ç‚¹2è‡ªå·±äº†ã€‚
ä»£ç æ‰§è¡Œç¤ºä¾‹

```go
æ ‘ç»“æ„ï¼š

     1
    / \
   2   3
  / \
 4   5

åˆå§‹çŠ¶æ€:
stack = []
root = 1, pre = nil

æ­¥éª¤1: 1,2,4 å…¥æ ˆ
stack = [1->2->4]
root = nil

æ­¥éª¤2: å¼¹å‡º4 (æ— å³å­èŠ‚ç‚¹)
result = [4]
pre = 4
stack = [1->2]

æ­¥éª¤3: å¼¹å‡º2 (å‘ç°å³å­èŠ‚ç‚¹5æœªè®¿é—®)
stacké‡æ–°å‹å…¥2ï¼Œè½¬å‘5
stack = [1->2]
root = 5

æ­¥éª¤4: 5å…¥æ ˆåå¼¹å‡º
result = [4,5]
pre = 5
stack = [1->2]

æ­¥éª¤5: å†æ¬¡å¼¹å‡º2 (å³å­èŠ‚ç‚¹å·²è®¿é—®)
result = [4,5,2]
pre = 2
stack = [1]

...ï¼ˆåç»­æ­¥éª¤ç±»ä¼¼ï¼‰
```

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func postorderTraversal(root *TreeNode) []int {
    result := []int{}
    stack := []*TreeNode{}
		
  	// ç›®çš„åœ¨äºé¿å…å³èŠ‚ç‚¹é‡å¤å…¥æ ˆ
    var pre *TreeNode = nil
  
    for len(stack) > 0 || root != nil {
        // å…¥æ ˆ
        for root != nil {
            stack = append(stack,root)
            root = root.Left
        }
      
        // å‡ºæ ˆ
        root = stack[len(stack)-1] //æ ˆå°¾
        stack = stack[:len(stack)-1]
      
        if root.Right == nil || root.Right == pre { //å¦‚æœå‘ç°æ²¡æœ‰å³è¾¹èŠ‚ç‚¹ã€æˆ–ï¼Œå³è¾¹èŠ‚ç‚¹é‡å¤å‰ä¸€ä¸ªèŠ‚ç‚¹
            //ä¿å­˜ç»“æœ
            result = append(result,root.Val)
            pre = root // è®°å½•å‰ä¸€ä¸ªèŠ‚ç‚¹
            root = nil // ï¼ˆæ³¨æ„è¿™é‡Œï¼šroot = nilï¼‰å†å‡ºæ ˆä¸€ä¸ªæ–°å…ƒç´ 
        }else {
            stack = append(stack,root) //å…¥æ ˆ
            root = root.Right
        }
    }
    return result
}
```
æ€è·¯äºŒï¼š
é€šè¿‡é€’å½’çš„æ–¹å¼ï¼Œè¿™ç§æœ€ç®€å•

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

var result []int
func postorderTraversal(root *TreeNode) []int {
    result = []int{}
    traversal(root)
    return result
}

func traversal(root *TreeNode) {

    if root == nil {
        return
    }

    traversal(root.Left)
    traversal(root.Right)
    result = append(result,root.Val)
}
```
## 50. Pow(x,n)
å®ç° [pow(x, n)](https://www.cplusplus.com/reference/valarray/pow/) ï¼Œå³è®¡ç®— `x` çš„æ•´æ•° `n` æ¬¡å¹‚å‡½æ•°ï¼ˆå³ï¼Œ`xn` ï¼‰ã€‚
**ç¤ºä¾‹ 1ï¼š**

```go
è¾“å…¥ï¼šx = 2.00000, n = 10
è¾“å‡ºï¼š1024.00000
```
**ç¤ºä¾‹ 2ï¼š**

```go
è¾“å…¥ï¼šx = 2.10000, n = 3
è¾“å‡ºï¼š9.26100
```
æ€è·¯ï¼š
è¦è®¡ç®—n ä¸ª xç›¸ä¹˜ï¼Œå¯ä»¥å…ˆç»“ç®— n/2 ä¸ªxç›¸ä¹˜ï¼ˆå°†é—®é¢˜çš„è§„æ¨¡ç¼©å°ï¼‰ï¼ŒçŸ¥é“äº† n/2ä¸ªxç›¸ä¹˜çš„ç»“æœ `result`åï¼Œåªéœ€è¦å°† `result*result`å³å¯ã€‚æ¯”å¦‚æˆ‘ä»¬è¦æ±‚ 2 çš„4æ¬¡æ–¹ï¼Œå¯ä»¥å…ˆå»æ±‚ 2 çš„ 2æ¬¡æ–¹ã€‚
è¦æ³¨æ„ï¼šnå¯èƒ½æ˜¯å¥‡æ•°ï¼Œæ‰€ä»¥å¦‚æœæ˜¯å¥‡æ•°ï¼Œéœ€è¦é¢å¤–å¤„ç†ä¸€ä¸‹ï¼Œå°†nå˜æˆå¶æ•°ï¼Œæ‰èƒ½é™¤ä»¥2ï¼Œå…·ä½“è¯·çœ‹ä¸‹é¢ä»£ç ã€‚

```go
func myPow(x float64, n int) float64 {

    if n == 0 {
        return 1 
    }

    if n == 1 {
        return x
    }
    
    if n < 0 {
        return myPow(1/x ,-n) // è½¬æˆæ­£æ•°
    }
   
    if n & 1 == 1 { // n%2 == 1 è¡¨ç¤ºå¥‡æ•°
        return  x * myPow(x,n-1)

    } 
    
    // è¡¨ç¤ºå¶æ•°
    result := myPow(x,n/2)
    return result * result
}
```
## LCR 174. å¯»æ‰¾äºŒå‰æœç´¢æ ‘ä¸­çš„ç›®æ ‡èŠ‚ç‚¹
æŸå…¬å¸ç»„ç»‡æ¶æ„ä»¥äºŒå‰æœç´¢æ ‘å½¢å¼è®°å½•ï¼ŒèŠ‚ç‚¹å€¼ä¸ºå¤„äºè¯¥èŒä½çš„å‘˜å·¥ç¼–å·ã€‚è¯·è¿”å›ç¬¬ `cnt` å¤§çš„å‘˜å·¥ç¼–å·ã€‚
æ€è·¯ï¼š
æ ‘ä¸ºäºŒå‰æœç´¢æ ‘ï¼ŒèŠ‚ç‚¹ä¸Šçš„æ•°æ®å¦‚æœæŒ‰ç…§ä¸­åºéå†çš„æ–¹å¼ï¼ˆå·¦ä¸­å³ï¼‰ï¼Œæ•°æ®æ˜¯æŒ‰ç…§é€’å¢æ’åˆ—çš„ï¼Œæ–¹ä¾¿æ‰¾ç¬¬`cnt`å°çš„æ•°
æ³¨æ„é¢˜ç›®ï¼Œè¦æ‰¾åˆ°ç¬¬ `cnt`å¤§çš„æ•°å€¼ï¼ˆä¸æ˜¯ç¬¬ `cnt`å°çš„æ•°å€¼ï¼‰ï¼Œå¤§çš„æ•°æ®åœ¨å°¾éƒ¨ã€‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥é‡‡ç”¨ï¼ˆå³ä¸­å·¦ï¼‰çš„ä¸­åºéå†æ–¹å¼ï¼Œè®©æ•°æ®æŒ‰ç…§å€’åºæ’åˆ—
æœ¬é¢˜å°±æ˜¯è€ƒä¸€ä¸‹é€†å‘çš„æ€ç»´ï¼Œç¼ºå¤±å®¹æ˜“è®©äººæƒ³å½“ç„¶ã€‚
å…·ä½“çœ‹ä¸‹é¢ä»£ç 

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

// æ–¹æ³•ä¸€ï¼šåˆ©ç”¨é€’å½’
var result int
func findTargetNode(root *TreeNode, cnt int) int {
    result = 0
    dfs(root,&cnt)
    return result
}

// cntçš„ç›®çš„åœ¨äºè®¡æ•°ï¼Œå½“ cnt = 0 è¡¨ç¤ºæ‰¾åˆ°äº†
func dfs(root *TreeNode,cnt *int) {

    if root == nil || *cnt == 0{
        return
    }
		// ä¸­åºéå†
    dfs(root.Right,cnt) // å³
  	// ä¸­
    (*cnt)--
    if *cnt == 0 { // æ‰¾åˆ°æ•°å€¼
        result = root.Val
        return
    }
    dfs(root.Left,cnt) // å·¦
}

// æ–¹æ³•äºŒï¼šåˆ©ç”¨æ ˆï¼Œè¿­ä»£çš„æ–¹å¼
func findTargetNode11(root *TreeNode, cnt int) int {

    stack := []*TreeNode{}

    for root != nil || len(stack) > 0 {
        if root != nil { 
            stack = append(stack,root)
            root = root.Right  // å³èŠ‚ç‚¹å…¥æ ˆï¼ˆæ­£å¸¸æƒ…å†µä¸‹ï¼Œåº”è¯¥æ˜¯å·¦èŠ‚ç‚¹å…¥æ ˆï¼‰
        } else {
            // å‡ºæ ˆ
            root = stack[len(stack)-1]
            stack = stack[:len(stack)-1]
						// åœ¨è¿™é‡Œå¯¹cntè¿›è¡Œè®¡æ•°
            cnt--
            if cnt == 0 {
                return root.Val
            }
            root = root.Left
        }
    }
    return 0
}
```
## 114. äºŒå‰æ ‘å±•å¼€ä¸ºé“¾è¡¨
ç»™ä½ äºŒå‰æ ‘çš„æ ¹ç»“ç‚¹ `root` ï¼Œè¯·ä½ å°†å®ƒå±•å¼€ä¸ºä¸€ä¸ªå•é“¾è¡¨ï¼š

- å±•å¼€åçš„å•é“¾è¡¨åº”è¯¥åŒæ ·ä½¿ç”¨ `TreeNode` ï¼Œå…¶ä¸­ `right` å­æŒ‡é’ˆæŒ‡å‘é“¾è¡¨ä¸­ä¸‹ä¸€ä¸ªç»“ç‚¹ï¼Œè€Œå·¦å­æŒ‡é’ˆå§‹ç»ˆä¸º `null` ã€‚
- å±•å¼€åçš„å•é“¾è¡¨åº”è¯¥ä¸äºŒå‰æ ‘ [å…ˆåºéå†](https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin) é¡ºåºç›¸åŒã€‚æ€è·¯ï¼š
è¿™é¢˜çš„å…³é”®åœ¨äºç†è§£ `flatten`å‡½æ•°çš„å®šä¹‰
**ç»™ **`**flatten**`** å‡½æ•°è¾“å…¥ä¸€ä¸ªèŠ‚ç‚¹ **`**root**`**ï¼Œé‚£ä¹ˆä»¥ **`**root**`** ä¸ºæ ¹çš„äºŒå‰æ ‘å°±ä¼šè¢«æ‹‰å¹³ä¸ºä¸€æ¡é“¾è¡¨**ã€‚
å¦‚ä½•åˆ©ç”¨è¿™ä¸ªå®šä¹‰æ¥å®Œæˆç®—æ³•ï¼Ÿä½ æƒ³æƒ³æ€ä¹ˆæŠŠä»¥ `root` ä¸ºæ ¹çš„äºŒå‰æ ‘æ‹‰å¹³ä¸ºä¸€æ¡é“¾è¡¨ï¼Ÿ
å¾ˆç®€å•ï¼Œä»¥ä¸‹æµç¨‹ï¼š
1ã€å°† `root` çš„å·¦å­æ ‘å’Œå³å­æ ‘æ‹‰å¹³ã€‚
2ã€å°† `root` çš„å³å­æ ‘æ¥åˆ°å·¦å­æ ‘ä¸‹æ–¹ï¼Œç„¶åå°†æ•´ä¸ªå·¦å­æ ‘ä½œä¸ºå³å­æ ‘ã€‚
è‡³äºå¦‚ä½•æŠŠ `root` çš„å·¦å³å­æ ‘æ‹‰å¹³ï¼Œä¸ç”¨ä½ æ“å¿ƒï¼Œ`flatten` å‡½æ•°çš„å®šä¹‰å°±æ˜¯è¿™æ ·ï¼Œäº¤ç»™ä»–åšå°±è¡Œäº†ã€‚
æ‰€ä»¥ï¼Œåœ¨ç”¨é€’å½’æ–¹å¼è§£é¢˜çš„å…³é”®ï¼Œå°±åœ¨äºé€’å½’å‡½æ•°çš„å®šä¹‰ï¼Œå°†å¤æ‚é—®é¢˜ï¼Œç®€åŒ–ä¸ºä¸€ä¸ªå­é—®é¢˜ï¼Œåªè¦æŠŠå­é—®é¢˜è§£å†³äº†ï¼Œæ•´ä¸ªé—®é¢˜å…¨éƒ¨è§£å†³äº†ã€‚

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

//å®šä¹‰ï¼šflatten ä»¥ rootä¸ºæ ¹çš„æ ‘æ‹‰å¹³ä¸ºé“¾è¡¨
func flatten(root *TreeNode)  {
    if root == nil {
        return
    }
    //æŠŠå·¦å­æ ‘æ‹‰å¹³ä¸ºé“¾è¡¨
    flatten(root.Left)
    //æŠŠå³å­æ ‘æ‹‰å¹³ä¸ºé“¾è¡¨
    flatten(root.Right)

    
    l := root.Left
    r := root.Right

    root.Left = nil //å·¦è¾¹è®¾ç½®ä¸ºç©º
    root.Right = l //å·¦è¾¹ä»£æ›¿å³è¾¹

    //æŠŠå‰©ä¸‹çš„å³è¾¹ræ‹¼æ¥åˆ°root.Rightï¼ˆè¿™ä¸ªå…¶å®å°±æ˜¯åŸæ¥çš„å·¦è¾¹ï¼‰é“¾è¡¨çš„å°¾éƒ¨
    p := root
    for p.Right != nil { //æ‰¾åˆ°é“¾è¡¨çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹
        p = p.Right
    }
    p.Right = r //æ‹¼æ¥
}
```
## 572. å¦ä¸€æ£µæ ‘çš„å­æ ‘
ç»™ä½ ä¸¤æ£µäºŒå‰æ ‘ `root` å’Œ `subRoot` ã€‚æ£€éªŒ `root` ä¸­æ˜¯å¦åŒ…å«å’Œ `subRoot` å…·æœ‰ç›¸åŒç»“æ„å’ŒèŠ‚ç‚¹å€¼çš„å­æ ‘ã€‚å¦‚æœå­˜åœ¨ï¼Œè¿”å› `true` ï¼›å¦åˆ™ï¼Œè¿”å› `false` ã€‚
äºŒå‰æ ‘ `tree` çš„ä¸€æ£µå­æ ‘åŒ…æ‹¬ `tree` çš„æŸä¸ªèŠ‚ç‚¹å’Œè¿™ä¸ªèŠ‚ç‚¹çš„æ‰€æœ‰åä»£èŠ‚ç‚¹ã€‚`tree` ä¹Ÿå¯ä»¥çœ‹åšå®ƒè‡ªèº«çš„ä¸€æ£µå­æ ‘ã€‚
æ€è·¯ï¼š
æ³¨æ„ï¼šé¢˜ç›®è¦æ±‚å’Œ`subRoot` å…·æœ‰ç›¸åŒç»“æ„å’ŒèŠ‚ç‚¹å€¼çš„å­æ ‘ï¼Œè€Œä¸æ˜¯å­˜åœ¨å’Œ `subRoot`é‡å çš„éƒ¨åˆ†ã€‚æ³¨æ„çœ‹ä¸‹ç¤ºä¾‹`2`çš„ä¾‹å­ï¼Œåªæ˜¯æœ‰é‡å ï¼Œè€Œä¸æ˜¯ç›¸åŒçš„å­æ ‘ã€‚

- å°† `subRoot`è¿›è¡Œåºåˆ—åŒ–ä¸ºä¸€ä¸ªå­—ç¬¦ä¸²
- åˆ†åˆ«å¯¹`root`ä¸­çš„å„ä¸ªå­æ ‘è¿›è¡Œåºåˆ—åŒ–ï¼Œå¯¹æ¯”å­—ç¬¦ä¸²æ˜¯å¦ç›¸åŒ
```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

func isSubtree(root *TreeNode, subRoot *TreeNode) bool {
    return isSub(root,encodeTree(subRoot))  // encodeTree(subRoot) å¯¹ subRootè¿›è¡Œåºåˆ—åŒ–
}

func isSub(root *TreeNode, str string) bool {
    
  	// å¯¹ root è¿›è¡Œåºåˆ—åŒ–ï¼Œåˆ¤æ–­æ˜¯å¦å’Œ str ç›¸åŒ
    if encodeTree(root) == str {
        return true
    }
		// root == nil å°±ä¸å­˜åœ¨å·¦å³å­æ ‘
    if root == nil {
        return false
    }
  	// åˆ†åˆ«å¯¹ root.Left  root.Right  åºåˆ—åŒ– ç»“æœå’Œ str æ¯”è¾ƒ
    return isSub(root.Left,str) || isSub(root.Right,str)
}


// å¯¹æ ‘åºåˆ—åŒ–
func encodeTree(root *TreeNode) string {
    if root == nil {
        return "#"
    }
    return strconv.Itoa(root.Val) +"," + encodeTree(root.Left) +","+ encodeTree(root.Right)
}
```
## 440. å­—å…¸åºçš„ç¬¬Kå°æ•°å­—
ç»™å®šæ•´æ•° `n` å’Œ `k`ï¼Œè¿”å› `[1, n]` ä¸­å­—å…¸åºç¬¬ `k` å°çš„æ•°å­—ã€‚
**ç¤ºä¾‹ 1:**

```go
è¾“å…¥: n = 13, k = 2
è¾“å‡º: 10
è§£é‡Š: å­—å…¸åºçš„æ’åˆ—æ˜¯ [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]ï¼Œæ‰€ä»¥ç¬¬äºŒå°çš„æ•°å­—æ˜¯ 10ã€‚
```
**ç¤ºä¾‹ 2:**
æ€è·¯ï¼š
è¿™é¢˜ç¡®å®æŒºéš¾ï¼Œå»ºè®®å¤šçœ‹å‡ éè®°ä½å³å¯ã€‚è¾¹çœ‹ä»£ç è¾¹å¯¹ç…§é€»è¾‘ç¤ºä¾‹å¯¹æ¯”çœ‹

```go
è¿™é‡Œç”¨ä¸¾ä¾‹çš„æ–¹å¼è§£é‡Šä»£ç çš„é€»è¾‘ï¼š
    
    æ¯”å¦‚n = 13 k=8 
    å­—å…¸åºï¼š 1 10 11 12 13 2 3 4 5 6 7 8 9 
    æŒ‰ç…§ä¸Šé¢çš„å­—å…¸åºï¼Œk=8çš„ä½ç½®ï¼Œå°±æ˜¯æ•°å­— 4
    
    å®é™…çš„è§£æ³•ï¼šå°±æ˜¯æ„å»ºä¸€ä¸ªå¤šå‰æ ‘çš„ç»“æ„
    æ ‘çš„æ ¹éƒ¨ä¸ºï¼šè™šæ‹Ÿçš„èŠ‚ç‚¹0
               0
            1     2
         [0..9] [0..9]   

    1å’Œ2ç›¸å½“äº0çš„ä¸¤ä¸ªå­æ ‘ï¼ˆåˆ†å‰ï¼‰ï¼›
    å·¦å­æ ‘éƒ½æ˜¯ä»¥1å¼€å¤´çš„æ•°å­—ï¼ˆä¹Ÿå°±æ˜¯ä»¥1å¼€å¤´çš„æ•°å­—éƒ½åœ¨1æ ‘ä¸‹ï¼‰ï¼›æ„æˆ 1 10 11 12 13 ...
    å³å­æ ‘éƒ½æ˜¯ä»¥2å¼€å¤´çš„æ•°å­—ï¼ˆä¹Ÿå°±æ˜¯ä»¥2å¼€å¤´çš„æ•°å­—éƒ½åœ¨2æ ‘ä¸‹ï¼‰; æ„æˆ 2 ...
    
    é¢˜ç›®è¦æ±‚æ‰¾ç¬¬kä¸ªæ•°å€¼
    é‚£ä¹ˆå°±éœ€è¦çŸ¥é“æ•°å€¼ï¼Œåœ¨å“ªä¸ªæ ‘é‡Œé¢ï¼ˆä¹Ÿå°±éœ€è¦çŸ¥é“å­æ ‘ä¸­èŠ‚ç‚¹çš„ä¸ªæ•°ï¼‰å¦‚æœk=8;ä»¥1ä¸ºæ ¹çš„å­æ ‘ï¼Œé‡Œé¢åªæœ‰5ä¸ªèŠ‚ç‚¹ï¼ˆå³ 1 10 11 12 13ï¼‰ï¼›è¯´æ˜è¦æ‰¾çš„æ•°å€¼ä¸åœ¨å·¦å­æ ‘ä¸­ï¼Œé‚£å°±ä»1çš„å³è¾¹æ ‘æ‰¾ï¼Œé‚£å°±æ˜¯ä»¥2ä¸ºæ ¹çš„å­æ ‘ï¼›

    1æ ‘ä¸­å…±æœ‰5ä¸ªèŠ‚ç‚¹ï¼›æˆ‘è¦æ‰¾ç¬¬8ä¸ªï¼Œé‚£ç­‰ä»·äºåœ¨2æ ‘ä¸­ æ‰¾8-5= 3ï¼ˆç¬¬3ä¸ªï¼‰ç›¸å½“äºæŠŠé—®é¢˜ï¼Œè½åœ¨äº†æ¯ä¸€ä¸ªå­æ ‘ä¸­æ‰¾å¯¹åº”çš„èŠ‚ç‚¹ï¼›

    æ€ä¹ˆçŸ¥é“ä¸€æ£µæ ‘æœ‰å¤šå°‘ä¸ªèŠ‚ç‚¹å‘¢ï¼Ÿåªéœ€è¦çŸ¥é“æ¯ä¸€å±‚æœ‰å¤šå°‘ä¸ªèŠ‚ç‚¹ï¼ˆæ‰€æœ‰çš„å±‚åŠ ä¸€èµ·ï¼Œå°±æ˜¯æ•´ä¸ªæ ‘çš„èŠ‚ç‚¹æ•°ï¼‰ï¼›ã€æ‰¾æ¯ä¸€å±‚çš„æœ€å°èŠ‚ç‚¹å€¼å’Œæœ€å¤§èŠ‚ç‚¹å€¼ æ±‚å·®ã€‘ï¼Œè¿™é‡Œè¿˜æœ‰ä¸€ä¸ªé™åˆ¶æ¡ä»¶ï¼Œå°±æ˜¯ é¢˜ç›®ç»™å®šçš„æ•´æ•°nï¼ˆä¸èƒ½è¶…è¿‡n+1ï¼‰ 
    
     													0
           			 		1     							2
          0 1 2 3 4 5 6 7 8 9   0 1 2 3 4 5 6 7 8 9
    æ¯”å¦‚ï¼šå·¦å­æ ‘1ï¼Œæ ¹èŠ‚ç‚¹ä¸º1ï¼Œæœ€å·¦è¾¹èŠ‚ç‚¹ä¸º1ï¼Œæœ€å³è¾¹èŠ‚ç‚¹ä¸º2ï¼Œæœ¬å±‚ä¹Ÿå°±æ˜¯ 2-1=1ä¸ªèŠ‚ç‚¹
    ç»§ç»­ä¸‹ä¸€å±‚æœ¬å±‚çš„æœ€å·¦è¾¹èŠ‚ç‚¹ä¸º10ï¼Œæœ€å³è¾¹çš„èŠ‚ç‚¹ä¸º 20ï¼Œæ‰€ä»¥ 20-10=10ä¸ªèŠ‚ç‚¹
    æ‰€ä»¥ï¼Œå¾—å‡ºå·¦å­æ ‘1ä¸­ï¼Œä¸€å…±æœ‰ 11 ä¸ªèŠ‚ç‚¹ï¼ˆå³ï¼š 1  10 11 12 13 14 15 16 17 18 19ï¼‰
```

```go
func findKthNumber(n int, k int) int {
   

    cur := 1 // cur çœ‹ä½œæ¯æ£µæ ‘çš„æ ¹èŠ‚ç‚¹

    for k != 1 { // kè¡¨ç¤ºæˆ‘ä»¬è¦ç¬¬kä¸ªæ•°å€¼ï¼Œå½“k==1çš„æ—¶å€™ï¼Œå°±æ˜¯è¦æ‰¾çš„æ•°å€¼
        //è®¡ç®—ä»¥å½“å‰çš„curä½œä¸ºæ ¹èŠ‚ç‚¹çš„æ•°å€¼æœ‰å¤šå°‘ä¸ªï¼Œæ˜¯å¦æ»¡è¶³kçš„ä¸ªæ•°
        left,right := cur,cur+1 // leftè¡¨ç¤ºæ¯ä¸€å±‚çš„æœ€å·¦è¾¹çš„èŠ‚ç‚¹ï¼Œrightè¡¨ç¤ºæ¯ä¸€å±‚çš„æœ€å³è¾¹çš„èŠ‚ç‚¹
        nodeNum := 0 // è®¡ç®—å‡ºä»¥curä¸ºèµ·ç‚¹çš„èŠ‚ç‚¹ä¸ªæ•°ï¼ŒåŒ…æ‹¬curè¿™ä¸ªèŠ‚ç‚¹
        for left <= n { // leftæ²¡æœ‰è¶…è¿‡nï¼Œè¯´æ˜å±‚æ•°è¿˜æ²¡æœ‰æ‰¾å®Œï¼›
          // rightçš„å€¼ï¼Œä¸èƒ½è¶Šç•Œ n+1 (ä¹Ÿå°±æ˜¯æ•´ä¸ªæ•°å€¼æœ€å¤§å€¼å°±æ˜¯n)
           nodeNum +=  min(n+1,right) - left // è¿™ä¸ªè®¡ç®—æ¯ä¸€å±‚çš„èŠ‚ç‚¹æ•°
           // ä¸‹ä¸€å±‚
           left *= 10
           right *= 10
        }

        if nodeNum < k { // è¯´æ˜å½“å‰curèŠ‚ç‚¹ï¼Œæ‹¥æœ‰çš„èŠ‚ç‚¹ä¸ªæ•°å¤ªå°‘äº†ï¼›æˆ‘ä»¬éœ€è¦æ¢æ£µæ ‘ï¼›
            k -= nodeNum
            cur++ // æ¢åˆ°å¦å¤–ä¸€æ£µæ ‘ï¼ˆæ¯”å¦‚ä¸Šé¢ä¾‹å­çš„ å³å­æ ‘ 2ï¼‰
        } else {
            // æ‰§è¡Œåˆ°è¿™é‡Œï¼Œè¯´æ˜curä¸ºèŠ‚ç‚¹çš„æ ‘ä¸­åŒ…æ‹¬kä¸ªèŠ‚ç‚¹ï¼›
            k-- // è¡¨ç¤ºå»æ‰curèŠ‚ç‚¹ï¼›
            cur *= 10 // ç„¶åå»æœ¬æ ‘çš„ä¸‹å±‚èŠ‚ç‚¹å¼€å§‹æ‰¾ç¬¬kä¸ªèŠ‚ç‚¹ï¼›é¦–å…ˆå½“å‰curèŠ‚ç‚¹è‚¯å®šä¸æ˜¯è¦æ‰¾çš„ï¼Œå¦‚æœæ˜¯è¦æ‰¾çš„k== 1,é‚£å°±è·³å‡ºå¾ªç¯äº†ï¼›è¿™é‡Œå°±æ˜¯ä»¥1ä¸‹é¢çš„0ä½œä¸ºæ–°çš„æ ¹èŠ‚ç‚¹ï¼ŒåŒæ—¶å¯¹äº1ä¸‹é¢çš„0èŠ‚ç‚¹è€Œè¨€ï¼Œä»–æ—è¾¹çš„1å°±ç®—æ˜¯å…¶ä»–çš„æ ‘äº†ï¼›
       /*
           1       
        [0..1 9] 
        */     
        }
    }
  
    return cur
}

func min(a ,b int) int{
    if a < b{
        return a
    }

    return b
}
```
## 450. åˆ é™¤äºŒå‰æœç´¢æ ‘ä¸­çš„èŠ‚ç‚¹
ç»™å®šä¸€ä¸ªäºŒå‰æœç´¢æ ‘çš„æ ¹èŠ‚ç‚¹ **root** å’Œä¸€ä¸ªå€¼ **key**ï¼Œåˆ é™¤äºŒå‰æœç´¢æ ‘ä¸­çš„ **key** å¯¹åº”çš„èŠ‚ç‚¹ï¼Œå¹¶ä¿è¯äºŒå‰æœç´¢æ ‘çš„æ€§è´¨ä¸å˜ã€‚è¿”å›äºŒå‰æœç´¢æ ‘ï¼ˆæœ‰å¯èƒ½è¢«æ›´æ–°ï¼‰çš„æ ¹èŠ‚ç‚¹çš„å¼•ç”¨ã€‚
ä¸€èˆ¬æ¥è¯´ï¼Œåˆ é™¤èŠ‚ç‚¹å¯åˆ†ä¸ºä¸¤ä¸ªæ­¥éª¤ï¼š

1. é¦–å…ˆæ‰¾åˆ°éœ€è¦åˆ é™¤çš„èŠ‚ç‚¹ï¼›
2. å¦‚æœæ‰¾åˆ°äº†ï¼Œåˆ é™¤å®ƒã€‚æ€è·¯ï¼š

1. å…ˆæ‰¾åˆ°`key`èŠ‚ç‚¹
2. åˆ é™¤èŠ‚ç‚¹ åˆ†æˆ3ç§æƒ…å†µ èŠ‚ç‚¹æ²¡æœ‰å­èŠ‚ç‚¹ï¼ˆç›´æ¥åˆ é™¤ï¼‰ èŠ‚ç‚¹ä»…æœ‰ä¸€ä¸ªå­èŠ‚ç‚¹ï¼ˆå­èŠ‚ç‚¹ä»£æ›¿è‡ªå·±ï¼‰ èŠ‚ç‚¹æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹ï¼ˆé€‰æ‹©å·¦å­æ ‘æœ€å¤§å€¼ or å³å­æ ‘æœ€å°å€¼ ä»£æ›¿è‡ªå·±ä¿è¯BSTçš„æ€§è´¨ä¸å˜ï¼‰
```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

 // åœ¨rootæ ‘ä¸­åˆ é™¤keyèŠ‚ç‚¹ï¼Œè¿”å›æ ‘çš„æ ¹èŠ‚ç‚¹
func deleteNode(root *TreeNode, key int) *TreeNode {
    
    if root == nil {
        return root
    }
    // å½“å‰çš„æ ¹èŠ‚ç‚¹ï¼Œå°±æ˜¯è¦æ‰¾çš„key
    if root.Val == key { 

        // æ²¡æœ‰å·¦å­æ ‘
        if root.Left == nil {
            return root.Right 
        }
        // æ²¡æœ‰å³å­æ ‘
        if root.Right == nil {
            return root.Left
        }

        // æ‰§è¡Œåˆ°è¿™é‡Œï¼Œè¯´æ˜å·¦å³å­æ ‘éƒ½ä¸ä¸ºnil,ä»å³å­æ ‘æ‰¾åˆ°æœ€å°èŠ‚ç‚¹ï¼ˆç›®çš„ï¼šä½œä¸ºå½“å‰èŠ‚ç‚¹çš„æ›¿æ¢èŠ‚ç‚¹ï¼‰
        minNode := getMin(root.Right)
        // å…ˆä»å³å­æ ‘ä¸­åˆ é™¤ minNodeèŠ‚ç‚¹
        root.Right = deleteNode(root.Right,minNode.Val)

        // ç”¨minNodeèŠ‚ç‚¹ï¼Œæ›¿æ¢rootä½ç½®
        minNode.Left = root.Left
        minNode.Right = root.Right
				// å°† minNodeä½œä¸ºæ–°çš„root
        root = minNode

    } else if root.Val > key { // è¦æ‰¾çš„ key åœ¨å·¦å­æ ‘ä¸­
        root.Left = deleteNode(root.Left,key) // ä»å·¦å­æ ‘ä¸­åˆ é™¤keyï¼Œå¹¶å°†æ–°çš„æ ¹èŠ‚ç‚¹å’Œ root.Leftæ‹¼æ¥åˆ°ä¸€èµ·
    } else { // è¦æ‰¾çš„ key åœ¨å³å­æ ‘ä¸­
        root.Right = deleteNode(root.Right,key)// ä»å³å­æ ‘ä¸­åˆ é™¤keyï¼Œå¹¶å°†æ–°çš„æ ¹èŠ‚ç‚¹å’Œ root.Right æ‹¼æ¥åˆ°ä¸€èµ·
    }
    return root
}

// æ‰¾å³å­æ ‘çš„æœ€å°èŠ‚ç‚¹
func getMin(root *TreeNode) *TreeNode {

    for root.Left != nil {
        root = root.Left
    }
    return root
}
```
## 125. éªŒè¯å›æ–‡ä¸²
å¦‚æœåœ¨å°†æ‰€æœ‰å¤§å†™å­—ç¬¦è½¬æ¢ä¸ºå°å†™å­—ç¬¦ã€å¹¶ç§»é™¤æ‰€æœ‰éå­—æ¯æ•°å­—å­—ç¬¦ä¹‹åï¼ŒçŸ­è¯­æ­£ç€è¯»å’Œåç€è¯»éƒ½ä¸€æ ·ã€‚åˆ™å¯ä»¥è®¤ä¸ºè¯¥çŸ­è¯­æ˜¯ä¸€ä¸ª **å›æ–‡ä¸²** ã€‚
å­—æ¯å’Œæ•°å­—éƒ½å±äºå­—æ¯æ•°å­—å­—ç¬¦ã€‚
ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² `s`ï¼Œå¦‚æœå®ƒæ˜¯ **å›æ–‡ä¸²** ï¼Œè¿”å› `true` ï¼›å¦åˆ™ï¼Œè¿”å› `false` ã€‚
**ç¤ºä¾‹ 1ï¼š**

```go
è¾“å…¥: s = "A man, a plan, a canal: Panama"
è¾“å‡ºï¼štrue
è§£é‡Šï¼š"amanaplanacanalpanama" æ˜¯å›æ–‡ä¸²ã€‚
```
**ç¤ºä¾‹ 2ï¼š**

```go
è¾“å…¥ï¼šs = "race a car"
è¾“å‡ºï¼šfalse
è§£é‡Šï¼š"raceacar" ä¸æ˜¯å›æ–‡ä¸²ã€‚
```
æ€è·¯ï¼š
è¿™é“é¢˜å¾ˆç®€å•ï¼Œåªè¦å…ˆæŠŠæ‰€æœ‰å­—ç¬¦è½¬åŒ–æˆå°å†™ï¼Œå¹¶è¿‡æ»¤æ‰ç©ºæ ¼å’Œæ ‡ç‚¹è¿™ç±»å­—ç¬¦ï¼Œç„¶åå¯¹å‰©ä¸‹çš„å­—ç¬¦æ‰§è¡Œ **ä¸¤ç«¯å‘ä¸­å¿ƒçš„åŒæŒ‡é’ˆç®—æ³•**å³å¯ã€‚

```go
func isPalindrome(s string) bool {
    // 1.å¤§å†™è½¬å°å†™ï¼Œå¹¶å»æ‰ éã€å­—æ¯+æ•°å­—ã€‘å­—ç¬¦
		
  	// tempStr å­˜å‚¨è½¬æ¢åçš„ç»“æœ
    tempStr := []byte{}
    for i := 0;i < len(s);i++ {
        c := 	convert(s[i]) 
        if c != ' ' { // ä¸æ˜¯ç©ºå­—ç¬¦ï¼Œå­˜å‚¨åˆ° tempSträ¸­
            tempStr = append(tempStr,c)
        }
    }

    // åŒæŒ‡é’ˆæŠ€å·§
    left,right := 0,len(tempStr)-1
    for left <= right {
        if tempStr[left] == tempStr[right] {
            left++
            right--
        } else {
            return false
        }
    }

    return true
}

func convert(c byte) byte {
		// å°å†™åŸæ ·
    if c >= 'a' && c <= 'z' {
        return c
    }
		// å¤§å†™è½¬å°å†™
    if c >= 'A' && c <= 'Z' {

        return 'a' + (c - 'A')
    }
    // æ•°å­—åŸæ ·
    if c >= '0' && c <='9' {
        return c
    }
		// å…¶ä»–å­—ç¬¦è¾“å‡ºç©º
    return ' '
}
```
## 91. è§£ç æ–¹æ³•
ä¸€æ¡åŒ…å«å­—æ¯ `A-Z` çš„æ¶ˆæ¯é€šè¿‡ä»¥ä¸‹æ˜ å°„è¿›è¡Œäº† **ç¼–ç ** ï¼š

```go
"1" -> 'A' "2" -> 'B' ... "25" -> 'Y' "26" -> 'Z'
```
ç„¶è€Œï¼Œåœ¨ **è§£ç ** å·²ç¼–ç çš„æ¶ˆæ¯æ—¶ï¼Œä½ æ„è¯†åˆ°æœ‰è®¸å¤šä¸åŒçš„æ–¹å¼æ¥è§£ç ï¼Œå› ä¸ºæœ‰äº›ç¼–ç è¢«åŒ…å«åœ¨å…¶å®ƒç¼–ç å½“ä¸­ï¼ˆ`"2"` å’Œ `"5"` ä¸ `"25"`ï¼‰ã€‚
ä¾‹å¦‚ï¼Œ`"11106"` å¯ä»¥æ˜ å°„ä¸ºï¼š

- `"AAJF"` ï¼Œå°†æ¶ˆæ¯åˆ†ç»„ä¸º `(1, 1, 10, 6)`
- `"KJF"` ï¼Œå°†æ¶ˆæ¯åˆ†ç»„ä¸º `(11, 10, 6)`
- æ¶ˆæ¯ä¸èƒ½åˆ†ç»„ä¸º `(1, 11, 06)` ï¼Œå› ä¸º `"06"` ä¸æ˜¯ä¸€ä¸ªåˆæ³•ç¼–ç ï¼ˆåªæœ‰ "6" æ˜¯åˆæ³•çš„ï¼‰ã€‚æ³¨æ„ï¼Œå¯èƒ½å­˜åœ¨æ— æ³•è§£ç çš„å­—ç¬¦ä¸²ã€‚
ç»™ä½ ä¸€ä¸ªåªå«æ•°å­—çš„ **éç©º** å­—ç¬¦ä¸² `s` ï¼Œè¯·è®¡ç®—å¹¶è¿”å› **è§£ç ** æ–¹æ³•çš„ **æ€»æ•°** ã€‚å¦‚æœæ²¡æœ‰åˆæ³•çš„æ–¹å¼è§£ç æ•´ä¸ªå­—ç¬¦ä¸²ï¼Œè¿”å› `0`ã€‚
é¢˜ç›®æ•°æ®ä¿è¯ç­”æ¡ˆè‚¯å®šæ˜¯ä¸€ä¸ª **32 ä½** çš„æ•´æ•°ã€‚
**ç¤ºä¾‹ 1ï¼š**

```go
è¾“å…¥ï¼šs = "12"
è¾“å‡ºï¼š2
è§£é‡Šï¼šå®ƒå¯ä»¥è§£ç ä¸º "AB"ï¼ˆ1 2ï¼‰æˆ–è€… "L"ï¼ˆ12ï¼‰ã€‚
```
**ç¤ºä¾‹ 2ï¼š**

```go
è¾“å…¥ï¼šs = "226"
è¾“å‡ºï¼š3
è§£é‡Šï¼šå®ƒå¯ä»¥è§£ç ä¸º "BZ" (2 26), "VF" (22 6), æˆ–è€… "BBF" (2 2 6) ã€‚
```
æ€è·¯ï¼š
æœ¬æ¬¡é‡‡ç”¨åŠ¨æ€è§„åˆ’çš„æ€è·¯ï¼šæ ¸å¿ƒåœ¨äºç†è§£`dp`æ•°ç»„çš„å®šä¹‰ï¼ˆä¹Ÿå°±æ˜¯å…ˆæ€è€ƒå±€éƒ¨çš„è§£ç é—®é¢˜ï¼Œç„¶åæ¨å¹¿ä¸ºä¸€èˆ¬çš„è§£æ³•ï¼‰

```go
dpçš„å®šä¹‰ï¼š

dp[i][0]: iè¡¨ç¤ºä»[0,i]çš„å­—ç¬¦ä¸²ï¼Œ0è¡¨ç¤ºæŠŠs[i]ä½œä¸ºä¸€ä¸ªå­—ç¬¦è¿›è¡Œè§£ç ï¼Œé‚£ä¹ˆèƒ½å¾—åˆ°çš„è§£ç æ–¹æ³•çš„æ€»æ•°
dp[i][1]: iè¡¨ç¤ºä»[0,i]çš„å­—ç¬¦ä¸²ï¼Œ1è¡¨ç¤ºæŠŠs[i-1]s[i]ä¸¤ä¸ªå­—ç¬¦ä¸€èµ·è¿›è¡Œè§£ç ï¼Œé‚£ä¹ˆèƒ½å¾—åˆ°çš„è§£ç æ–¹æ³•çš„æ€»æ•°

å³ï¼š ä»[0,i]çš„å­—ç¬¦ä¸²,å°¾éƒ¨å•ç‹¬è§£ç ï¼ˆè¿˜å‰©ä¸‹å‰é¢çš„i-1ä¸ªï¼‰çš„è§£ç æ–¹æ³•æ•° or ä¸¤ä¸ªä¸€èµ·è§£ç ï¼ˆè¿˜å‰©ä¸‹å‰é¢çš„i-2ä¸ªï¼‰çš„è§£ç æ–¹æ³•æ•°ï¼Œã€æ±‚å’Œã€‘

// ä¸€èˆ¬é€’æ¨å…³ç³»
// iå•ç‹¬è§£ç çš„è§£ç æ€»æ•° = i-1 å¯ä»¥å•ç‹¬ åŠ ä¸Š  i-2 i-1ä¸€èµ·è§£ç 
dp[i][0] = dp[i-1][0] + dp[i-1][1] 

// i-1å’Œiä¸€èµ·è§£ç æ€»æ•° = i-2å•ç‹¬è§£ç   åŠ ä¸Š   i-3 i-2ä¸€èµ·è§£å¯†
dp[i][1] = dp[i-2][0] + dp[i-2][1]

// ç‰¹æ®Šæƒ…å†µ
å½“iå•ç‹¬è§£ç ï¼Œå¹¶ä¸”s[i] == 0,æ˜¯ä¸å¯¹çš„è§£ç æ–¹å¼ï¼Œdp[i][0] = 0
å½“ i-1/iä¸€èµ·è§£ç ï¼Œå¹¶ä¸”s[i-1]s[i]çš„å–å€¼èŒƒå›´ä¸åœ¨ã€10ï¼Œ26ã€‘ï¼Œæ˜¯ä¸å¯¹çš„è§£ç æ–¹å¼ dp[i][1] = 0
```
å…·ä½“è¯·çœ‹ä¸‹é¢ä»£ç ï¼ˆæœ¬é¢˜çœ‹å®Œä»£ç ä¸éš¾ç†è§£ï¼Œä½†æ˜¯ç»†èŠ‚æ¯”è¾ƒå¤šï¼‰

```go
func numDecodings(s string) int {

   
    n := len(s)
    dp := make([][]int,n)
    for k := range dp {
        dp[k] = make([]int,2)
    }

    // base case
		
  	// å•ç‹¬ç¼–ç 
    if s[0] == '0' { // æ³¨æ„ å­—ç¬¦æ˜¯ 0çš„æƒ…å†µ
        dp[0][0] = 0
    } else {
        dp[0][0] = 1 
    }
  	// è”åˆè§£ç 
    dp[0][1] = 0 // æ²¡æœ‰s[-1]æ‰€ä»¥ä¸º0


    for i := 1;i < n;i++ { // è¿™é‡Œä»1å¼€å§‹ã€æ³¨æ„ã€‘

        // å•ç‹¬ç¼–ç 
        if s[i] == '0' { 
            dp[i][0] = 0
        } else {
            dp[i][0] = dp[i-1][0] + dp[i-1][1] 
        }
        
        // è”åˆç¼–ç 
        num := s[i-1:i+1] 
        // å½“è·å–ä¸¤ä¸ªå­—ç¬¦çš„æ—¶å€™ï¼Œè¿™ä¸¤ä¸ªå­—ç¬¦ä¸€å®šå¤„äº [10...26]ä¹‹é—´çš„æ•°å­—ï¼Œå¯ä»¥ç”¨å­—ç¬¦ä¸²è¿›è¡Œæ¯”è¾ƒ
        if num >= "10" && num <= "26" { // è¿‡æ»¤äº† "06"çš„æƒ…å†µ

            if i == 1 { // è¶Šç•Œçš„ç‰¹æ®Šæƒ…å†µ
                dp[i][1] = 1
            } else {
                dp[i][1] = dp[i-2][0] + dp[i-2][1]
            }
        } else {
            dp[i][1] = 0
        }
    }

    return dp[n-1][0] + dp[n-1][1]
}
```
## LCR 143. å­ç»“æ„åˆ¤æ–­
ç»™å®šä¸¤æ£µäºŒå‰æ ‘ `tree1` å’Œ `tree2`ï¼Œåˆ¤æ–­ `tree2` æ˜¯å¦ä»¥ `tree1` çš„æŸä¸ªèŠ‚ç‚¹ä¸ºæ ¹çš„å­æ ‘å…·æœ‰ **ç›¸åŒçš„ç»“æ„å’ŒèŠ‚ç‚¹å€¼** ã€‚ æ³¨æ„ï¼Œ**ç©ºæ ‘** ä¸ä¼šæ˜¯ä»¥ `tree1` çš„æŸä¸ªèŠ‚ç‚¹ä¸ºæ ¹çš„å­æ ‘å…·æœ‰ **ç›¸åŒçš„ç»“æ„å’ŒèŠ‚ç‚¹å€¼** ã€‚
æ€è·¯ï¼š
è¿™é¢˜æ³¨æ„å’Œ **572. å¦ä¸€æ£µæ ‘çš„å­æ ‘**è¿›è¡ŒåŒºåˆ«ã€‚è¿™é‡Œåªéœ€è¦å­˜åœ¨ç›¸åŒçš„ç»“æ„å’ŒèŠ‚ç‚¹å€¼å³å¯ï¼Œä¸éœ€è¦å®Œå…¨ä¸€æ¨¡ä¸€æ ·çš„å­æ ‘ç»“æ„ã€‚

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
// å‡½æ•°å®šä¹‰ï¼šAä¸­æ˜¯å¦åŒ…å«Bè¿™ä¸ªå­ç»“æ„ (å­ç»“æ„ï¼šè¡¨ç¤ºå­˜åœ¨ç›¸åŒéƒ¨åˆ†ï¼Œè€Œä¸éœ€è¦å®Œå…¨ä¸€æ¨¡ä¸€æ ·çš„å­æ ‘)
func isSubStructure(A *TreeNode, B *TreeNode) bool {

    if A == nil && B == nil { // åŒæ—¶æ˜¯ç©º
        return true
    } 

    if A == nil || B == nil { // çº¦å®šç©ºæ ‘ä¸æ˜¯ä»»æ„ä¸€ä¸ªæ ‘çš„å­ç»“æ„
        return false
    }
    // æ‰§è¡Œåˆ°è¿™é‡Œï¼Œè¯´æ˜Aå’ŒBéƒ½ä¸ä¸ºç©º

    // isSame(A,B) åˆ¤æ–­Aå’ŒBæ˜¯å¦ç›¸åŒï¼ˆå¦‚æœç›¸åŒï¼Œè¯´æ˜æ˜¯å­ç»“æ„ï¼‰ï¼›å¦‚æœä¸ç›¸åŒæ²¡å…³ç³»ï¼ŒåŒæ—¶çœ‹ä¸‹Açš„ã€å·¦è¾¹æˆ–è€…å³è¾¹ã€‘æ˜¯å¦å­˜åœ¨Bè¿™ä¸ªå­ç»“æ„ï¼Œåªè¦æœ‰ä¸€ä¸ªæ»¡è¶³å³å¯
    return isSame(A,B) || isSubStructure(A.Left,B) || isSubStructure(A.Right,B)

}


// å®šä¹‰é€’å½’å‡½æ•°ï¼šä»¥aå’Œbä½œä¸ºã€èµ·ç‚¹ã€‘çš„ä¸¤æ£µæ ‘æ˜¯å¦é‡å ï¼ˆç›¸åŒï¼‰
func isSame( a,b *TreeNode) bool {
    if b == nil { // è¯´æ˜bæ ‘æ˜¯ç©ºï¼Œä¸ç®¡aæ˜¯å¦æœ‰å€¼ï¼Œè¯´æ˜éƒ½æ˜¯aåŒ…å«bçš„å…³ç³»
        return true
    }
    if a == nil && b != nil {
        return false
    }

    if a.Val != b.Val { // æ‰§è¡Œåˆ°è¿™é‡Œaå’Œbä¸€å®šéƒ½ä¸æ˜¯nilï¼Œå¦‚æœä¸¤ä¸ªèŠ‚ç‚¹å€¼ä¸åŒï¼Œè¯´æ˜ä¸é‡å 
        return false
    }

    return isSame(a.Left,b.Left) && isSame(a.Right,b.Right) // å¦‚æœaå’Œbç›¸åŒï¼Œå†åˆ†åˆ«çœ‹ä¸‹å·¦å³èŠ‚ç‚¹æ˜¯å¦ä¹Ÿç›¸åŒ
}
```
## LCR 127. è·³è·ƒè®­ç»ƒ
ä»Šå¤©çš„æœ‰æ°§è¿åŠ¨è®­ç»ƒå†…å®¹æ˜¯åœ¨ä¸€ä¸ªé•¿æ¡å½¢çš„å¹³å°ä¸Šè·³è·ƒã€‚å¹³å°æœ‰ `num` ä¸ªå°æ ¼å­ï¼Œæ¯æ¬¡å¯ä»¥é€‰æ‹©è·³ **ä¸€ä¸ªæ ¼å­** æˆ–è€… **ä¸¤ä¸ªæ ¼å­**ã€‚è¯·è¿”å›åœ¨è®­ç»ƒè¿‡ç¨‹ä¸­ï¼Œå­¦å‘˜ä»¬å…±æœ‰å¤šå°‘ç§ä¸åŒçš„è·³è·ƒæ–¹å¼ã€‚
ç»“æœå¯èƒ½è¿‡å¤§ï¼Œå› æ­¤ç»“æœéœ€è¦å–æ¨¡ 1e9+7ï¼ˆ1000000007ï¼‰ï¼Œå¦‚è®¡ç®—åˆå§‹ç»“æœä¸ºï¼š1000000008ï¼Œè¯·è¿”å› 1ã€‚
**ç¤ºä¾‹ 1ï¼š**
**ç¤ºä¾‹ 2ï¼š**
æ€è·¯ï¼š
æœ¬é¢˜å’Œ **70. çˆ¬æ¥¼æ¢¯** æ˜¯ç›¸åŒé¢˜ç›®
`dp[i]`è¡¨ç¤ºï¼šè·³åˆ°ç¬¬`i`ä¸ªæ ¼å­çš„æ–¹å¼ã€‚æˆ‘ä»¬å¯ä»¥é€‰æ‹©ä»ç¬¬`i-1`ä¸ªæ ¼å­è·³è·ƒä¸€æ¬¡åˆ° `i`ï¼Œä¹Ÿå¯ä»¥é€‰æ‹©ä¸­ç¬¬`i-2`ä¸ªæ ¼å­è·³è·ƒä¸€æ¬¡åˆ°`i`ã€‚

```go
func trainWays(num int) int {

    // dp[i] = dp[i-1] + dp[i-2]
    // num è¡¨ç¤ºæ ¼å­ä¸ªæ•°

    dp := make([]int,num+1)

    for i := 0;i < num+1;i++ {
        if i == 0 {
            dp[i] = 1 // ç¬¬0ä¸ªæ ¼å­ï¼Œå…¶å®å°±æ˜¯æ²¡æœ‰æ ¼å­ï¼ˆæ‰€ä»¥ä¸è¦è·³è·ƒï¼Œå³é»˜è®¤1ç§è·³è·ƒæ–¹å¼ï¼‰
        } else if i == 1 {
            dp[i] = 1
        } else {
            dp[i] = (dp[i-1] + dp[i-2]) % 1000000007 
        }
    }
    return dp[num] 
}
```
## 329. çŸ©é˜µä¸­çš„æœ€é•¿é€’å¢è·¯å¾„
ç»™å®šä¸€ä¸ª `m x n` æ•´æ•°çŸ©é˜µ `matrix` ï¼Œæ‰¾å‡ºå…¶ä¸­ **æœ€é•¿é€’å¢è·¯å¾„** çš„é•¿åº¦ã€‚
å¯¹äºæ¯ä¸ªå•å…ƒæ ¼ï¼Œä½ å¯ä»¥å¾€ä¸Šï¼Œä¸‹ï¼Œå·¦ï¼Œå³å››ä¸ªæ–¹å‘ç§»åŠ¨ã€‚ ä½  **ä¸èƒ½** åœ¨ **å¯¹è§’çº¿** æ–¹å‘ä¸Šç§»åŠ¨æˆ–ç§»åŠ¨åˆ° **è¾¹ç•Œå¤–**ï¼ˆå³ä¸å…è®¸ç¯ç»•ï¼‰ã€‚
æ€è·¯ï¼š

- ç†è§£ `dp[i][j]`çš„å«ä¹‰ï¼šä½œä¸ºå¤‡å¿˜å½•ï¼Œç”¨æ¥è®°å½•ä» `i,j` å‡ºå‘ï¼Œæœ€é•¿é€’å¢è·¯ç»çš„å€¼ï¼ˆé¿å…é‡å¤è®¡ç®—ï¼‰
- ç†è§£`dfs`å‡½æ•°çš„å®šä¹‰ï¼š ä» `i,j` å‡ºå‘çš„æœ€é•¿é€’å¢è·¯ç»é•¿åº¦ä¸€èˆ¬é€’æ¨å…³ç³»

```go
åœ¨ä¿è¯ã€ä¸Šä¸‹å·¦å³ã€‘ä¸è¶Šç•Œçš„æƒ…å†µä¸‹ï¼Œå¦‚æœã€ä¸Šä¸‹å·¦å³ã€‘çš„å€¼æ¯” matrix[i][j] å¤§ï¼Œè¯´æ˜é€’å¢è·¯å¾„å¯ä»¥+1

	// ä¸Š
	if i-1 >= 0 && matrix[i-1][j] > matrix[i][j] {
		dp[i][j] = max(dp[i][j], dfs(matrix,i-1,j,m,n,dp) + 1)
	}

	// ä¸‹
	if i+1 < m && matrix[i+1][j] > matrix[i][j] {
		dp[i][j] = max(dp[i][j], dfs(matrix,i+1,j,m,n,dp) + 1)
	}

	// å·¦
	if j-1 >= 0 && matrix[i][j-1] > matrix[i][j] {
		dp[i][j] = max(dp[i][j], dfs(matrix,i,j-1,m,n,dp) + 1)
	}

	// å³
	if j+1 < n && matrix[i][j+1] > matrix[i][j] {
		dp[i][j] = max(dp[i][j], dfs(matrix,i,j+1,m,n,dp) + 1)
	}
```
è¿™é¢˜å…¶å®å’Œå²›å±¿é—®é¢˜æœ‰ç‚¹ç‚¹ç±»ä¼¼ï¼Œåªæ˜¯è¿™é‡Œé¢å¤–å®šä¹‰äº†ä¸€ä¸ª`dp`æ•°ç»„ï¼Œç”¨æ¥è®°å½•æ¯ä¸ª`i,j`ä½ç½®çš„ï¼Œæœ€å¤§é€’å¢é•¿åº¦

```go
var result int

func longestIncreasingPath(matrix [][]int) int {
	

	m, n := len(matrix), len(matrix[0])
    // å®šä¹‰ dp æ•°ç»„
	dp := make([][]int, m)
	for i := range dp {
		dp[i] = make([]int, n)
	}

	result := 0
  
	for i := 0; i < m; i++ {
		for j := 0; j < n; j++ {
			// ä»æ¯ä¸ªi,jå…ƒç´ å‡ºå‘ï¼Œåœ¨resutä¸­è®°å½•ä¸‹ æœ€æœ€æœ€æœ€æœ€æœ€ å¤§çš„è·¯å¾„å€¼
			result = max(result, dfs(matrix, i, j, m, n,dp))
		}
	}
	return result
}

//dfså‡½æ•°çš„å®šä¹‰ï¼š ä» i,j å‡ºå‘çš„æœ€é•¿é€’å¢è·¯ç»é•¿åº¦
func dfs(matrix [][]int, i, j, m, n int, dp [][]int) int {

  // é»˜è®¤ dp[i][j] ä¸­çš„å€¼ä¸º0
	if dp[i][j] != 0 {  // è¯´æ˜å·²ç»å¤„ç†è¿‡äº†
		return dp[i][j] // ç›´æ¥è¿”å›
	}

	// dp[i][j] == 0 è¯´æ˜æ˜¯ç¬¬ä¸€æ¬¡å¤„ç†è¯¥èŠ‚ç‚¹ï¼Œé»˜è®¤é•¿åº¦ä¸º1ï¼ˆä¹Ÿå°±æ˜¯i,jè¿™ä¸ªæ•°å­—æœ¬èº«ï¼‰
	dp[i][j] = 1

	// ä¸Š
	if i-1 >= 0 && matrix[i-1][j] > matrix[i][j] {
		dp[i][j] = max(dp[i][j], dfs(matrix,i-1,j,m,n,dp) + 1) // ä¸Šé¢çš„æœ€å¤§é•¿åº¦ + 1 å’Œ dp[i][j] æ¯”è¾ƒï¼Œä½œä¸ºæœ€å¤§å€¼
	}

	// ä¸‹
	if i+1 < m && matrix[i+1][j] > matrix[i][j] {
		dp[i][j] = max(dp[i][j], dfs(matrix,i+1,j,m,n,dp) + 1)// ä¸‹é¢çš„æœ€å¤§é•¿åº¦ + 1 å’Œ dp[i][j] æ¯”è¾ƒï¼Œä½œä¸ºæœ€å¤§å€¼
	}

	// å·¦
	if j-1 >= 0 && matrix[i][j-1] > matrix[i][j] {
		dp[i][j] = max(dp[i][j], dfs(matrix,i,j-1,m,n,dp) + 1)// å·¦é¢çš„æœ€å¤§é•¿åº¦ + 1 å’Œ dp[i][j] æ¯”è¾ƒï¼Œä½œä¸ºæœ€å¤§å€¼
	}

	// å³
	if j+1 < n && matrix[i][j+1] > matrix[i][j] {
		dp[i][j] = max(dp[i][j], dfs(matrix,i,j+1,m,n,dp) + 1)// å³é¢çš„æœ€å¤§é•¿åº¦ + 1 å’Œ dp[i][j] æ¯”è¾ƒï¼Œä½œä¸ºæœ€å¤§å€¼
	}

    // dp[i][j] ä¸­ä¿å­˜çš„å°±æ˜¯éå†è¿‡ä¸Šä¸‹å·¦å³ï¼Œå¾—åˆ°çš„iï¼Œjä½ç½®çš„æœ€å¤§é•¿åº¦
    return dp[i][j]
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```
## 445. ä¸¤æ•°ç›¸åŠ  II
ç»™ä½ ä¸¤ä¸ª **éç©º** é“¾è¡¨æ¥ä»£è¡¨ä¸¤ä¸ªéè´Ÿæ•´æ•°ã€‚æ•°å­—æœ€é«˜ä½ä½äºé“¾è¡¨å¼€å§‹ä½ç½®ã€‚å®ƒä»¬çš„æ¯ä¸ªèŠ‚ç‚¹åªå­˜å‚¨ä¸€ä½æ•°å­—ã€‚å°†è¿™ä¸¤æ•°ç›¸åŠ ä¼šè¿”å›ä¸€ä¸ªæ–°çš„é“¾è¡¨ã€‚
ä½ å¯ä»¥å‡è®¾é™¤äº†æ•°å­— 0 ä¹‹å¤–ï¼Œè¿™ä¸¤ä¸ªæ•°å­—éƒ½ä¸ä¼šä»¥é›¶å¼€å¤´ã€‚
![é™„ä»¶ä¸‹è½½å¤±è´¥](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/)

æ€è·¯ï¼š
è¿™é“é¢˜æ˜¯** 2. ä¸¤æ•°ç›¸åŠ  **çš„è¿›é˜¶é—®é¢˜ï¼Œæˆ‘ä»¬æ¨¡æ‹ŸåŠ æ³•è¿ç®—å½“ç„¶æ˜¯ä»æœ€ä½ä½å¼€å§‹åŠ ï¼Œè¿™æ ·æ‰èƒ½æ­£ç¡®çš„å¤„ç†è¿›ä½ã€‚ä½†ç°åœ¨å•é“¾è¡¨çš„å¼€å¤´æ˜¯æœ€é«˜ä½ï¼Œé‚£ä¹ˆæœ€ç›´æ¥çš„æƒ³æ³•å°±æ˜¯å…ˆ ç¿»è½¬é“¾è¡¨ï¼Œè¿™æ ·å°±å¯ä»¥ç»§ç»­ç©ç¬¬ 2 é¢˜é‚£ä¸€å¥—äº†ï¼Œæ²¡ä»€ä¹ˆéš¾åº¦ã€‚
ä¸è¿‡æœ¬é¢˜ä¹Ÿè¯´äº†ï¼Œå¦‚æœä¸è®©ä½ åè½¬é“¾è¡¨æ€ä¹ˆåŠï¼Ÿå…¶å®ä¹Ÿå¥½åŠï¼Œæˆ‘ä»¬å¯ä»¥åˆ©ç”¨æ ˆè¿™ç§å…ˆè¿›åå‡ºçš„æ•°æ®ç»“æ„ï¼ŒæŠŠé“¾è¡¨èŠ‚ç‚¹ä»å¤´åˆ°å°¾æ”¾è¿›æ ˆä¸­ï¼Œå†ä»æ ˆæ‹¿å‡ºæ¥å°±æ˜¯ä»å°¾åˆ°å¤´çš„é¡ºåºï¼Œç›¸å½“äºæ˜¯åè½¬é“¾è¡¨çš„æ•ˆæœï¼Œç„¶ååˆå›åˆ°äº†ç¬¬ 2 é¢˜çš„åŠ æ³•é€»è¾‘ã€‚
è¿˜æœ‰ä¸€ä¸ªéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè®¡ç®—ç»“æœçš„é«˜ä½ä¹Ÿåº”è¯¥æ”¾åœ¨ç»“æœé“¾è¡¨çš„å·¦ä¾§ï¼Œä¹Ÿå°±æ˜¯æ’å…¥åˆ° `dummy` èŠ‚ç‚¹çš„åé¢ã€‚å…·ä½“çœ‹ä»£ç å§ã€‚

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    

    sk1,sk2 := []int{},[]int{}
		
  	// å…¥æ ˆ l1é“¾è¡¨
    p1 := l1
    for p1 != nil {

        sk1 = append(sk1,p1.Val)
        p1 = p1.Next
    }
		// å…¥æ ˆ l2 é“¾è¡¨
    p2 := l2
    for p2 != nil {

        sk2 = append(sk2,p2.Val)
        p2 = p2.Next
    }
	
  
  	// å®šä¹‰ dummyèŠ‚ç‚¹
    dummy := &ListNode{Val:0,Next:nil}
    

    carry := 0 // è¿›ä½

    for len(sk1) != 0 || len(sk2) != 0 || carry != 0 {

        sum := 0
      	
        sum += carry
     		// å‡ºæ ˆæ±‚å’Œ
        if len(sk1) != 0 {
            sum += sk1[len(sk1)-1]
            sk1 = sk1[:len(sk1)-1]
        }
				// å‡ºæ ˆæ±‚å’Œ
        if len(sk2) != 0 {
            sum += sk2[len(sk2)-1]
            sk2 = sk2[:len(sk2)-1]
        }
       
        carry = sum / 10 // è¿›ä½
        val := sum % 10 // ä½™æ•°
        
        // å°†èŠ‚ç‚¹æ‹¼æ¥åˆ° dummy åé¢ï¼ˆæ³¨æ„è¿™é‡Œæ”¾ç½®çš„ä½ç½®ï¼‰
        node := &ListNode{Val:val,Next:nil}
        node.Next = dummy.Next
        dummy.Next = node
    }
		
    return dummy.Next
}
```
## 442. æ•°ç»„ä¸­é‡å¤çš„æ•°æ®
ç»™ä½ ä¸€ä¸ªé•¿åº¦ä¸º `n` çš„æ•´æ•°æ•°ç»„ `nums` ï¼Œå…¶ä¸­ `nums` çš„æ‰€æœ‰æ•´æ•°éƒ½åœ¨èŒƒå›´ `[1, n]` å†…ï¼Œä¸”æ¯ä¸ªæ•´æ•°å‡ºç° **æœ€å¤š****ä¸¤æ¬¡** ã€‚è¯·ä½ æ‰¾å‡ºæ‰€æœ‰å‡ºç° **ä¸¤æ¬¡** çš„æ•´æ•°ï¼Œå¹¶ä»¥æ•°ç»„å½¢å¼è¿”å›ã€‚
ä½ å¿…é¡»è®¾è®¡å¹¶å®ç°ä¸€ä¸ªæ—¶é—´å¤æ‚åº¦ä¸º `O(n)` ä¸”ä»…ä½¿ç”¨å¸¸é‡é¢å¤–ç©ºé—´ï¼ˆä¸åŒ…æ‹¬å­˜å‚¨è¾“å‡ºæ‰€éœ€çš„ç©ºé—´ï¼‰çš„ç®—æ³•è§£å†³æ­¤é—®é¢˜ã€‚
**ç¤ºä¾‹ 1ï¼š**

```go
è¾“å…¥ï¼šnums = [4,3,2,7,8,2,3,1]
è¾“å‡ºï¼š[2,3]
```
**ç¤ºä¾‹ 2ï¼š**
æ€è·¯ï¼š
è¿™é“é¢˜å°±ç”¨å¸¸è§„çš„è§£æ³•åšå§ï¼Œç”¨å“ˆå¸Œé›†åˆï¼ˆä¹Ÿå°±æ˜¯`map`)å¾ˆå®¹æ˜“æ‰¾åˆ° `nums` ä¸­é‚£äº›é‡å¤çš„å…ƒç´ ã€‚
ä½†æ˜¯é¢˜ç›®è¦æ±‚ä½¿ç”¨å¸¸é‡çš„é¢å¤–ç©ºé—´ï¼ˆçœ‹åˆ°è¿™ä¸ªï¼Œå°±æ˜¯è¦æˆ‘ä»¬ç›´æ¥åœ¨åŸå§‹æ•°ç»„ä¸Šåšæ–‡ç« ï¼‰
å› ä¸ºé¢˜ç›®è¯´ `nums` ä¸­çš„å…ƒç´ å–å€¼éƒ½åœ¨ `[1, n]` ä¹‹é—´ï¼Œå³å…ƒç´ æœ¬èº«å°±å’Œç´¢å¼•æˆæ˜ å°„å…³ç³»ï¼Œæ‰€ä»¥å¯ä»¥ç”¨ `nums` æœ¬èº«æ¨¡æ‹Ÿå“ˆå¸Œé›†åˆçš„æ•ˆæœ
![é™„ä»¶ä¸‹è½½å¤±è´¥](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/)

æ³¨æ„ï¼šç”¨ä¹˜ -1 çš„æ–¹å¼ç»™ç´¢å¼•åšæ ‡è®°çš„å‰ææ˜¯ï¼Œ`nums` ä¸­çš„å…ƒç´ éƒ½ä¸ºæ­£æ•°ï¼Œä¸èƒ½åŒ…å« 0ï¼Œå¦åˆ™æ— æ³•åŒºåˆ†è¯¥ç´¢å¼•æ˜¯å¦è¢«æ ‡è®°ã€‚

```go
func findDuplicates(nums []int) []int {

	res := []int{}

   // å°†æ¯ä¸ªæ•°å‡ 1 å½“ä½œç´¢å¼•å€¼ï¼Œçœ‹ä¸‹ç´¢å¼•å¯¹åº”çš„ æ•°å€¼æ˜¯å¦æ˜¯è´Ÿæ•°ï¼Œå¦‚æœæ˜¯è´Ÿæ•°ï¼Œè¯´æ˜å·²ç»å­˜åœ¨ç›¸åŒçš„æ•°å€¼ï¼Œå¦åˆ™å°†å€¼è®¾å®šä¸ºè´Ÿ
	for i := 0; i < len(nums); i++ {
		
		idx := abs(nums[i]) - 1
		if nums[idx] > 0 { // ä¸æ˜¯è´Ÿæ•°ï¼Œè¦æ ‡è®°ä¸ºè´Ÿæ•°ï¼›
			nums[idx] = -nums[idx]
		} else { // æ˜¯è´Ÿæ•°ï¼Œè¯´æ˜å½“å‰å…ƒç´ æ˜¯é‡å¤å…ƒç´ 
			res = append(res, abs(nums[i]))
		}
	}
	return res
}

// å› ä¸ºè®¾å®šè´Ÿæ•°çš„åŸå› ï¼Œéœ€è¦å…ˆè½¬æˆæ­£æ•°
func abs(a int) int {
	if a < 0 {
		return -a
	}
	return a
}
```
## 45. è·³è·ƒæ¸¸æˆ II
ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º `n` çš„ **0 ç´¢å¼•**æ•´æ•°æ•°ç»„ `nums`ã€‚åˆå§‹ä½ç½®ä¸º `nums[0]`ã€‚
æ¯ä¸ªå…ƒç´  `nums[i]` è¡¨ç¤ºä»ç´¢å¼• `i` å‘åè·³è½¬çš„æœ€å¤§é•¿åº¦ã€‚æ¢å¥è¯è¯´ï¼Œå¦‚æœä½ åœ¨ `nums[i]` å¤„ï¼Œä½ å¯ä»¥è·³è½¬åˆ°ä»»æ„ `nums[i + j]` å¤„:

- `0 <= j <= nums[i]`
- `i + j < n`è¿”å›åˆ°è¾¾ `nums[n - 1]` çš„æœ€å°è·³è·ƒæ¬¡æ•°ã€‚ç”Ÿæˆçš„æµ‹è¯•ç”¨ä¾‹å¯ä»¥åˆ°è¾¾ `nums[n - 1]`ã€‚
æ€è·¯ï¼š
æœ¬é¢˜é‡‡ç”¨åŠ¨æ€è§„åˆ’çš„æ€è·¯ï¼Œæœ€ç®€å•å®¹æ˜“ç†è§£

- å®šä¹‰`dp[i]`ï¼šè¡¨ç¤ºä»`0`è·³è·ƒåˆ°`i`ä½ç½®çš„æœ€å°è·³è·ƒæ¬¡æ•°
- å½“å‰å¦‚æœå°±å¤„äº`0`ä½ç½®ï¼Œå°±ä¸éœ€è¦è·³è·ƒï¼Œæ‰€ä»¥`dp[0] = 0`
- å½“ä½äº`i`ä½ç½®çš„æ—¶å€™ï¼Œæˆ‘å¯ä»¥é€‰æ‹©ä»`[0,i-1]`ä»»æ„ä½ç½®ï¼ˆå‰æèƒ½è·³è·ƒåˆ°`i`)è·³è·ƒåˆ°`i`ä½ç½®ï¼Œå½“ç„¶æˆ‘ä»¬åªéœ€è¦è®°å½•ä¸‹æœ€å°çš„æ¬¡æ•°å³å¯
```go
func jump(nums []int) int {
   

    n := len(nums)
    
    // å®šä¹‰dpæ•°ç»„
    dp := make([]int,n)
    //åˆå§‹åŒ–dpæ•°ç»„ï¼Œè·³è·ƒçš„æ¬¡æ•°ä¸ºæ— ç©·å¤§çš„æ•°ï¼ˆnå³å¯ï¼‰è·³è·ƒæ¬¡æ•°è‚¯å®šæ˜¯ä¸ä¼šå¤§äºnçš„
    for k,_ := range dp { 
        dp[k] = n
    }

    dp[0] = 0 // base case ä¸ç”¨è·³è·ƒ

    for i := 1;i < n;i++ {
        for j :=0;j < i ;j++ { // iä¹‹å‰çš„jè·³è·ƒåˆ°iä½ç½®(æ‰¾æœ€å°çš„è®°å½•ä¸‹æ¥)

            if j + nums[j] >= i { // è¯´æ˜ä»jä½ç½®å¯ä»¥è·³è·ƒåˆ°iä½ç½®
                dp[i] = min(dp[j]+1,dp[i])
            }
        }
    }
    return dp[n-1]
}

func min(a,b int) int {
    if a < b {
        return a
    }
    return b
}
```
## LCR 121. å¯»æ‰¾ç›®æ ‡å€¼-äºŒç»´æ•°ç»„
`m`*`n` çš„äºŒç»´æ•°ç»„ `plants` è®°å½•äº†å›­æ—æ™¯è§‚çš„æ¤ç‰©æ’å¸ƒæƒ…å†µï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹æ€§ï¼š

- æ¯è¡Œä¸­ï¼Œæ¯æ£µæ¤ç‰©çš„å³ä¾§ç›¸é‚»æ¤ç‰©ä¸çŸ®äºè¯¥æ¤ç‰©ï¼›
- æ¯åˆ—ä¸­ï¼Œæ¯æ£µæ¤ç‰©çš„ä¸‹ä¾§ç›¸é‚»æ¤ç‰©ä¸çŸ®äºè¯¥æ¤ç‰©ã€‚è¯·åˆ¤æ–­ `plants` ä¸­æ˜¯å¦å­˜åœ¨ç›®æ ‡é«˜åº¦å€¼ `target`ã€‚
æ€è·¯ï¼š
æœ¬é¢˜å’Œ **240. æœç´¢äºŒç»´çŸ©é˜µII**ç›¸åŒã€‚
æˆ‘ä»¬ä¸è¦ä»å·¦ä¸Šè§’å¼€å§‹ï¼Œè€Œæ˜¯ä»å³ä¸Šè§’å¼€å§‹ï¼Œè§„å®šåªèƒ½å‘å·¦æˆ–å‘ä¸‹ç§»åŠ¨ã€‚
ä½ æ³¨æ„ï¼Œå¦‚æœå‘å·¦ç§»åŠ¨ï¼Œå…ƒç´ åœ¨å‡å°ï¼Œå¦‚æœå‘ä¸‹ç§»åŠ¨ï¼Œå…ƒç´ åœ¨å¢å¤§ï¼Œè¿™æ ·çš„è¯æˆ‘ä»¬å°±å¯ä»¥æ ¹æ®å½“å‰ä½ç½®çš„å…ƒç´ å’Œ `target` çš„ç›¸å¯¹å¤§å°æ¥åˆ¤æ–­åº”è¯¥å¾€å“ªç§»åŠ¨ï¼Œä¸æ–­æ¥è¿‘ä»è€Œæ‰¾åˆ° `target` çš„ä½ç½®ã€‚

```go
func findTargetIn2DPlants(plants [][]int, target int) bool {
    row := len(plants) // è·å–è¡Œæ•°
    if row == 0 { // ç‰¹æ®Šæƒ…å†µï¼Œå¦‚æœrow=0,ç›´æ¥ä¸å­˜åœ¨äºŒç»´æ•°ç»„ï¼Œç›´æ¥è¿”å›
        return false
    }
    
    column := len(plants[0]) //è·å–åˆ—æ•°

    i,j := 0,column-1 // ç¬¬0è¡Œç¬¬n-1åˆ—(ä»å³ä¸Šè§’å¼€å§‹éå†äºŒç»´æ•°ç»„)

    for i <  row && j >= 0 {

        if plants[i][j] == target {
            return true
        } else if plants[i][j]  < target {
            i++ // ä¸‹è¡Œçš„æ•°æ®æ›´å¤§
        } else {
           j-- // å·¦åˆ—çš„æ•°æ®æ›´å°
        }
    }
    // æ²¡æ‰¾åˆ°ï¼Œé»˜è®¤è¿”å› false
    return false
}
```
## LCR 161. è¿ç»­å¤©æ•°çš„æœ€é«˜é”€å”®é¢
æŸå…¬å¸æ¯æ—¥é”€å”®é¢è®°äºæ•´æ•°æ•°ç»„ `sales`ï¼Œè¯·è¿”å›æ‰€æœ‰ **è¿ç»­** ä¸€æˆ–å¤šå¤©é”€å”®é¢æ€»å’Œçš„æœ€å¤§å€¼ã€‚
è¦æ±‚å®ç°æ—¶é—´å¤æ‚åº¦ä¸º `O(n)` çš„ç®—æ³•ã€‚
**ç¤ºä¾‹ 1ï¼š**

```go
è¾“å…¥ï¼šsales = [-2,1,-3,4,-1,2,1,-5,4]
è¾“å‡ºï¼š6
è§£é‡Šï¼š[4,-1,2,1] æ­¤è¿ç»­å››å¤©çš„é”€å”®æ€»é¢æœ€é«˜ï¼Œä¸º 6ã€‚
```
**ç¤ºä¾‹ 2ï¼š**

```go
è¾“å…¥ï¼šsales = [5,4,-1,7,8]
è¾“å‡ºï¼š23
è§£é‡Šï¼š[5,4,-1,7,8] æ­¤è¿ç»­äº”å¤©çš„é”€å”®æ€»é¢æœ€é«˜ï¼Œä¸º 23ã€‚
```
æ€è·¯ï¼š
æœ¬é¢˜å’Œ**53. æœ€å¤§å­æ•°ç»„å’Œ**ä¸€æ ·çš„é¢˜è§£ã€‚

- å®šä¹‰`dp[i]`è¡¨ç¤ºï¼šä»¥`i`ä¸ºã€ç»“å°¾ã€‘çš„å­æ•°ç»„çš„æœ€å¤§å’Œï¼ˆ æ½œåœ¨å«ä¹‰ï¼šå­æ•°ç»„æ±‚å’Œï¼Œæ˜¯å¿…é¡»ä»¥`soles[i]`ä½œä¸ºå°¾éƒ¨å…ƒç´ çš„å­æ•°ç»„ ï¼‰
- æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ ï¼Œéƒ½å¯ä»¥çœ‹åšä¸€ä¸ªå•ç‹¬çš„å­æ•°ç»„ï¼ˆåªæœ‰ä¸€ä¸ªå…ƒç´ ï¼‰ã€‚æ‰€ä»¥ï¼Œå­æ•°ç»„å’Œçš„åˆå§‹å€¼ï¼Œå°±æ˜¯åªåŒ…å«ä¸€ä¸ªå…ƒç´ çš„å€¼ã€‚
- ä¸€èˆ¬é€’æ¨å…³ç³»`dp[i] = max(dp[i-1],0) + sales[i]`
`sales[i]`çš„å«ä¹‰ï¼š`dp[i]`å¤„çš„å­æ•°ç»„å’Œï¼Œåœ¨å­æ•°ç»„ä¸­ï¼Œå½“åªåŒ…å«`sales[i]`è¿™ä¸€ä¸ªå…ƒç´ çš„æ—¶å€™ï¼Œå°±æ˜¯åˆå§‹å­æ•°ç»„å’Œ
`max(dp[i-1],0)`çš„å«ä¹‰ï¼šå¦‚æœ`dp[i-1]`çš„å­æ•°ç»„å’Œå°äº`0`å’Œ `sales[i]`å…ƒç´ è¿›è¡Œæ‹¼æ¥ï¼Œåªä¼šè®© `dp[i]`å˜çš„æ›´å°ï¼Œæ‰€ä»¥ï¼Œå°äº`0`éœ€è¦èˆå¼ƒ

```go
func maxSales(sales []int) int {
   
    dp := make([]int,len(sales))
		
  	// base case 
  	// ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œå­æ•°ç»„å’Œå°±æ˜¯ sales[0]
    dp[0] = sales[0]
  	// åˆå§‹æœ€å¤§å€¼å°±æ˜¯ sales[0]
    result := sales[0]

    for i := 1;i < len(sales);i++ {
      // dp[i] å­æ•°ç»„å’Œ = å‰é¢ dp[i-1]å­æ•°ç»„å’Œ (å‰æï¼šéœ€è¦dp[i-1]>0ï¼Œå¦åˆ™åªä¼šè®© dp[i]å˜çš„æ›´å°ï¼Œè¿˜ä¸å¦‚ä¸è¦å‰é¢çš„å­æ•°ç»„ï¼Œåªä¿ç•™ sales[i]è¿™ä¸ªå•ç‹¬çš„å…ƒç´ æ„æˆå­æ•°ç»„) + å½“å‰ä½ç½®å…ƒç´ çš„å€¼ sales[i]
        dp[i] = max(dp[i-1],0) + sales[i]
        
      	// æ¯”è¾ƒç•™ä¸‹ï¼Œæœ€å¤§å€¼
        result = max(dp[i],result)
    }
    return result
}

func max(a,b int) int {
    if a > b{
        return a
    }
    return b
}
```
## 135. åˆ†å‘ç³–æœ
`n` ä¸ªå­©å­ç«™æˆä¸€æ’ã€‚ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `ratings` è¡¨ç¤ºæ¯ä¸ªå­©å­çš„è¯„åˆ†ã€‚
ä½ éœ€è¦æŒ‰ç…§ä»¥ä¸‹è¦æ±‚ï¼Œç»™è¿™äº›å­©å­åˆ†å‘ç³–æœï¼š

- æ¯ä¸ªå­©å­è‡³å°‘åˆ†é…åˆ° `1` ä¸ªç³–æœã€‚
- ç›¸é‚»ä¸¤ä¸ªå­©å­è¯„åˆ†æ›´é«˜çš„å­©å­ä¼šè·å¾—æ›´å¤šçš„ç³–æœã€‚è¯·ä½ ç»™æ¯ä¸ªå­©å­åˆ†å‘ç³–æœï¼Œè®¡ç®—å¹¶è¿”å›éœ€è¦å‡†å¤‡çš„ **æœ€å°‘ç³–æœæ•°ç›®** ã€‚
**ç¤ºä¾‹ 1ï¼š**

```go
è¾“å…¥ï¼šratings = [1,0,2]
è¾“å‡ºï¼š5
è§£é‡Šï¼šä½ å¯ä»¥åˆ†åˆ«ç»™ç¬¬ä¸€ä¸ªã€ç¬¬äºŒä¸ªã€ç¬¬ä¸‰ä¸ªå­©å­åˆ†å‘ 2ã€1ã€2 é¢—ç³–æœã€‚
```
æ€è·¯ï¼š

- æ„é€ `candyVec`æ•°ç»„ï¼Œåˆå§‹å€¼éƒ½æ˜¯`1`![é™„ä»¶ä¸‹è½½å¤±è´¥](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/)


- ä»å·¦åˆ°å³éå† `ratings`æ•°ç»„ï¼Œ`if ratings[i] > ratings[i-1]` è¯´æ˜ å³è¾¹ `i`> å·¦è¾¹ `i-1``candyVec[i] = candyVec[i-1] + 1` å³ï¼Œå³è¾¹`i`å¾—åˆ°çš„ç³–æœè‚¯å®šæ˜¯è¦æ¯”å·¦`i-1`å¤šä¸€ä¸ª![é™„ä»¶ä¸‹è½½å¤±è´¥](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/)


- ä»å³å‘å·¦éå† `if ratings[i] > ratings[i+1]` è¯´æ˜å·¦è¾¹`i` >å³è¾¹`i+1` ï¼Œæ‰€ä»¥ `candyVec[i] = candyVec[i+1] + 1`æœ€å`candyVec[i]`ä½ç½®å¤„çš„å€¼ï¼Œå–ã€ä¸¤ä¸ªç»“æœä¸­çš„æœ€å¤§å€¼`max`ã€‘
![é™„ä»¶ä¸‹è½½å¤±è´¥](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/)


```go
func candy(ratings []int) int {
    
  	// candyVec ç”¨æ¥è®°å½•æ¯ä¸ªå­©å­å¾—åˆ°çš„ç³–æœæ•°é‡
    candyVec := make([]int,len(ratings))
    for k,_ := range candyVec { // åˆå§‹åŒ–ä¸º1
        candyVec[k] = 1
    }

    for i := 1;i < len(ratings);i++ { // ä»å·¦å‘å³éå†
        if ratings[i] > ratings[i-1] { // å¦‚æœiå¤§äºå·¦è¾¹i-1çš„æ•°å€¼ï¼Œè¯´æ˜içš„è¯„çº§é«˜ï¼Œé‚£ä¹ˆå¾—åˆ°çš„ç³–æœä¸€å®šè¦å¤§äºi-1
            candyVec[i] = candyVec[i-1]+1
        }
    }       

    for i := len(ratings)-2;i >= 0;i-- { // ä»å³å‘å·¦éå†
        if ratings[i] > ratings[i+1]{ // å¦‚æœiå¤§äºå³è¾¹çš„ï¼Œè¯´æ˜içš„è¯„çº§é«˜ï¼Œé‚£ä¹ˆå¾—åˆ°çš„ç³–æœä¸€å®šè¦å¤§äºi+1
            candyVec[i] = max(candyVec[i],candyVec[i+1]+1) //å–æœ€å¤§å€¼çš„åŸå› ï¼šè¿™æ ·æ‰èƒ½æ»¡è¶³ï¼Œiå¾—åˆ°çš„ç³–æœæ•°é‡ï¼Œæ—¢æ»¡è¶³å¤§äºå·¦è¾¹ï¼Œåˆæ»¡è¶³å¤§äºå³è¾¹ï¼›
        }
    }

    result := 0
		// ç»Ÿè®¡ candyVec ä¸­æ‰€æœ‰çš„ç³–æœæ•°é‡
    for _,v := range candyVec {
        result += v
    }
    return result
}

func max(a,b int) int {
    if a > b {
        return a
    }
    return b
}
```
## LCR 126. æ–æ³¢é‚£å¥‘æ•°åˆ—
**æ–æ³¢é‚£å¥‘æ•°** ï¼ˆé€šå¸¸ç”¨ `F(n)` è¡¨ç¤ºï¼‰å½¢æˆçš„åºåˆ—ç§°ä¸º **æ–æ³¢é‚£å¥‘æ•°åˆ—** ã€‚è¯¥æ•°åˆ—ç”± **0** å’Œ **1** å¼€å§‹ï¼Œåé¢çš„æ¯ä¸€é¡¹æ•°å­—éƒ½æ˜¯å‰é¢ä¸¤é¡¹æ•°å­—çš„å’Œã€‚ä¹Ÿå°±æ˜¯ï¼š

```go
F(0) = 0ï¼ŒF(1) = 1
F(n) = F(n - 1) + F(n - 2)ï¼Œå…¶ä¸­ n > 1
```
ç»™å®š `n` ï¼Œè¯·è®¡ç®— `F(n)` ã€‚
ç­”æ¡ˆéœ€è¦å–æ¨¡ 1e9+7(1000000007) ï¼Œå¦‚è®¡ç®—åˆå§‹ç»“æœä¸ºï¼š1000000008ï¼Œè¯·è¿”å› 1ã€‚
æ€è·¯ï¼š
è¿™é¢˜å±äºåŸºç¡€é¢˜å‹ï¼Œæ˜¯åŠ¨æ€è§„åˆ’é¢˜å‹å…¥é—¨çš„åŸºç¡€ã€‚

- å®šä¹‰ä¸€ä¸ª`dp`æ•°ç»„ï¼š`dp[i]`è¡¨ç¤ºå‰é¢ä¸¤é¡¹æ•°å­—ä¹‹å’Œï¼ˆ`dp`æ•°ç»„çš„å®šä¹‰éœ€è¦å¤§å®¶åœ¨å†™æ•´ä¸ªä»£ç çš„è¿‡ç¨‹ä¸­ï¼Œè¦æ—¶åˆ»è®°ä½ & ç†è§£ï¼‰
- æ¨å¯¼ä¸€èˆ¬çš„é€’æ¨å…³ç³»ï¼ˆå½“ç„¶è¿™é¢˜å·²ç»ç›´æ¥ç»™å‡ºäº†é€’æ¨å…³ç³»ï¼‰`dp[i] = dp[i-1] + dp[i-2]`

```go
func fib(n int) int {
    
    dp := make([]int,n+1)
    for i := 0; i <= n;i++ {
        if i == 0 { // base case 
            dp[i] = 0
        } else if i == 1 {
            dp[i] = 1 // base case
        } else{
          	 // é€’æ¨å…³ç³»
             dp[i] = (dp[i-1] + dp[i-2]) % 1000000007 // è¿™ä¸ªæ˜¯é¢˜ç›®è¦æ±‚ã€å–æ¨¡ã€‘
        }
    }
  	
    return dp[n]    
}
```
## åœ†ç¯å›åŸç‚¹é—®é¢˜
åœ†ç¯ä¸Šæœ‰10ä¸ªç‚¹ï¼Œç¼–å·ä¸º0~9ã€‚ä»0ç‚¹å‡ºå‘ï¼Œæ¯æ¬¡å¯ä»¥é€†æ—¶é’ˆå’Œé¡ºæ—¶é’ˆèµ°ä¸€æ­¥ï¼Œé—®èµ°næ­¥å›åˆ°0ç‚¹å…±æœ‰å¤šå°‘ç§èµ°æ³•ã€‚

```go
è¾“å…¥: 2
è¾“å‡º: 2
è§£é‡Šï¼šæœ‰2ç§æ–¹æ¡ˆã€‚åˆ†åˆ«æ˜¯0->1->0å’Œ0->9->0
```
æ€è·¯ï¼š
æœ¬é¢˜åœ¨`leetcode`ä¸Šæ²¡æœ‰å¯¹åº”é¢˜ï¼Œè¿™é‡Œä½œä¸ºè¡¥å……é¢˜ã€‚
è¿™é¢˜çš„ç†è§£å¯ä»¥å…ˆå»åšä¸‹**ç¬¬**`**70**`**é¢˜çˆ¬æ¥¼æ¢¯**é—®é¢˜ï¼ˆæœ‰åŠ©äºç†è§£æœ¬é¢˜ï¼‰ã€‚
é¢˜ç›®è¦æ±‚èµ°`n`æ­¥åˆ°`0`ç‚¹çš„æ–¹æ¡ˆæ•°ï¼Œé‚£æˆ‘ä»¬å¯ä»¥è€ƒè™‘ã€èµ° `n-1`åˆ°`1`çš„æ–¹æ¡ˆæ•°ã€‘ å’Œ ã€èµ°`n-1`æ­¥åˆ°`9`çš„æ–¹æ¡ˆæ•°ã€‘ï¼Œå› ä¸ºåˆ†åˆ«åªéœ€è¦å•ç‹¬å†èµ°ä¸€æ­¥ï¼Œå°±å¯ä»¥åˆ°`0`ç‚¹äº†ï¼ˆå› ä¸ºæ˜¯ä¸ªåœ†ç¯ï¼‰ã€‚
å› æ­¤ï¼Œè‹¥è®¾`dp[i][j]`ä¸ºï¼Œç»è¿‡`i`æ­¥ï¼Œä»`0`åˆ°è¾¾ä½ç½®`j` çš„æ–¹æ¡ˆæ•°ï¼ˆå…¶ä¸­ï¼Œ`i`è¡¨ç¤ºæ­¥æ•°ï¼Œ`j`è¡¨ç¤ºä½ç½®ï¼‰
ä¸€èˆ¬é€’æ¨å…³ç³»ä¸ºï¼š
`dp[i][j] = dp[i-1][(j-1 + length)%length] + dp[i-1][(j+1) % length]`
å› ä¸ºæ˜¯ä¸€ä¸ªåœ†ç¯ï¼š
`(j-1 + length)%length`ï¼šè¡¨ç¤ºä½ç½®`j`çš„å·¦è¾¹ä¸€ä½
`(j+1) % length`ï¼šè¡¨ç¤ºä½ç½® `j`çš„å³è¾¹ä¸€ä½
æœ€ç»ˆè¦æ±‚çš„ç»“æœä¸º`dp[n][0]`çš„å€¼

```go
package main

import "fmt"

func main() {
	// dp[i][j] å®šä¹‰ï¼šç»è¿‡iæ­¥ï¼Œä»0åˆ°è¾¾ä½ç½®j çš„æ–¹æ¡ˆæ•°
	//ä¸€èˆ¬é€’æ¨å‡½æ•° dp[i][j] = dp[i-1][(j+1)% length] + dp[i-1][(j-1+length)% length]

	length := 10 // åœ†ç¯ç‚¹æ•°é‡
	n := 2       // nè¡¨ç¤ºæ­¥æ•°

	dp := make([][]int, n+1)
	for k := range dp {
		dp[k] = make([]int, length)
	}

	dp[0][0] = 1 // base case ä¸€ç§æ–¹æ¡ˆï¼ˆä¿æŒä¸åŠ¨,å³å¯ï¼‰

	for i := 1; i < n+1; i++ {
		for j := 0; j < length; j++ {

			dp[i][j] = dp[i-1][(j+1)%length] + dp[i-1][(j-1+length)%length]
		}
	}

	fmt.Println(dp[n][0])
}
```
## 347. å‰ `K`ä¸ªé«˜é¢‘å…ƒç´ 
ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums` å’Œä¸€ä¸ªæ•´æ•° `k` ï¼Œè¯·ä½ è¿”å›å…¶ä¸­å‡ºç°é¢‘ç‡å‰ `k` é«˜çš„å…ƒç´ ã€‚ä½ å¯ä»¥æŒ‰ **ä»»æ„é¡ºåº** è¿”å›ç­”æ¡ˆã€‚
**ç¤ºä¾‹ 1:**

```go
è¾“å…¥: nums = [1,1,1,2,2,3], k = 2
è¾“å‡º: [1,2]
```
æ€è·¯ï¼š

- å…ˆç”¨`map`è®°å½•æ•°å€¼å’Œå‡ºç°çš„é¢‘ç‡
- å®šä¹‰ä¸ªé¢‘ç‡æ•°ç»„ï¼Œç´¢å¼•å°±æ˜¯é¢‘ç‡ï¼ˆè¿™é‡Œçš„é¢‘ç‡æ•°ç»„å¯ä»¥çœ‹ä½œä¸€ä¸ªæ¡¶ï¼Œç”¨æ¥è£…æ•°å€¼ï¼‰
- å€’åºä»é¢‘ç‡æ•°ç»„ä¸­è·å–`k`ä¸ªå…ƒç´ å³å¯ï¼ˆå€’åºçš„åŸå› ï¼Œå› ä¸ºæ•°ç»„å°¾éƒ¨çš„é¢‘ç‡æ›´å¤§ï¼Œé¢˜ç›®è¦æ‰¾çš„ä¹Ÿæ˜¯å‡ºç°æ¬¡æ•°å¤šçš„æ•°ï¼‰
```go
func topKFrequent(nums []int, k int) []int {
    
    // mapè®°å½•æ•°å€¼->é¢‘ç‡çš„å…³ç³»
    m := make(map[int]int)
    for _ , num := range nums {
        m[num]++
    }

    // ç„¶åå®šä¹‰ä¸€ä¸ªé¢‘ç‡æ•°ç»„ï¼Œç´¢å¼•ä¸ºå‡ºç°çš„é¢‘ç‡ï¼ˆæœ€å¤§çš„é¢‘ç‡æ— å¤–ä¹æ‰€æœ‰çš„å…ƒç´ éƒ½æ˜¯åŒä¸€ä¸ªå…ƒç´ ï¼‰æ‰€ä»¥æœ€å¤§çš„é¢‘ç‡ç´¢å¼•æ˜¯len(nums)
    freqArray := make( [][]int,len(nums)+1 ) // äºŒç»´æ•°ç»„ï¼šé¢‘ç‡-> åŒé¢‘ç‡çš„ä¸€å †æ•°å€¼

    for val, freq := range m {
        freqArray[freq] = append(freqArray[freq],val)
    }

    // ç„¶åå€’åºä»freqArrayä¸­æ‰¾åˆ°kä¸ªå…ƒç´ å³å¯ 
    result := []int{}
    for i := len(freqArray)-1;i >= 0;i-- { // ä»åå¾€å‰ ç¬¬iä¸ªé¢‘ç‡

        for j := 0;j < len(freqArray[i]);j++ { // é¢‘ç‡ä¸‹çš„æ•°å€¼
            
            result = append(result,freqArray[i][j])
            if len(result) == k { // ç»“æœä¸ºkè¯´æ˜æ‰¾åˆ°äº†kä¸ªé«˜é¢‘å•è¯
                return result
            }
        }
    }

    return result
}
```
## 10. æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…
ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² `s` å’Œä¸€ä¸ªå­—ç¬¦è§„å¾‹ `p`ï¼Œè¯·ä½ æ¥å®ç°ä¸€ä¸ªæ”¯æŒ `'.'` å’Œ `'*'` çš„æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…ã€‚

- `'.'` åŒ¹é…ä»»æ„å•ä¸ªå­—ç¬¦
- `'*'` åŒ¹é…é›¶ä¸ªæˆ–å¤šä¸ªå‰é¢çš„é‚£ä¸€ä¸ªå…ƒç´ æ‰€è°“åŒ¹é…ï¼Œæ˜¯è¦æ¶µç›– **æ•´ä¸ª** å­—ç¬¦ä¸² `s` çš„ï¼Œè€Œä¸æ˜¯éƒ¨åˆ†å­—ç¬¦ä¸²ã€‚
**ç¤ºä¾‹ 1ï¼š**

```go
è¾“å…¥ï¼šs = "aa", p = "a"
è¾“å‡ºï¼šfalse
è§£é‡Šï¼š"a" æ— æ³•åŒ¹é… "aa" æ•´ä¸ªå­—ç¬¦ä¸²ã€‚
```
æ€è·¯ï¼š
æ­£åˆ™è¡¨è¾¾ç®—æ³•é—®é¢˜åªéœ€è¦æŠŠä½ä¸€ä¸ªåŸºæœ¬ç‚¹ï¼šçœ‹ `s[i]` å’Œ `p[j]` ä¸¤ä¸ªå­—ç¬¦æ˜¯å¦åŒ¹é…ï¼Œä¸€åˆ‡é€»è¾‘å›´ç»•åŒ¹é…/ä¸åŒ¹é…ä¸¤ç§æƒ…å†µå±•å¼€å³å¯ã€‚

- å®šä¹‰`dp[i][j]`ä¸ºï¼šé•¿åº¦ä¸º`i`çš„å­—ç¬¦ä¸² å’Œ é•¿åº¦ä¸º`j`çš„å­—ç¬¦ä¸² æ˜¯å¦åŒ¹é…å­—ç¬¦ä¸²çš„åŒ¹é…åˆ†æˆä»¥ä¸‹å‡ ç§æƒ…å†µï¼š(æ³¨æ„ï¼š**è¿™é‡Œçš„**`**i**`**å’Œ**`**j**`**éƒ½æ˜¯é•¿åº¦ï¼Œè½¬åŒ–æˆç´¢å¼•éœ€è¦**`**i-1 j-1**`)

- å½“ `s[i-1] == p[j-1] || p[j-1] == '.'`æ­¤æ—¶é•¿åº¦ä¸º`i`çš„å­—ç¬¦ä¸² å’Œ é•¿åº¦ä¸º`j`çš„å­—ç¬¦ä¸² æ˜¯å¦åŒ¹é…ï¼Œåªéœ€è¦çœ‹é•¿åº¦ä¸º`i-1`çš„å­—ç¬¦ä¸² å’Œ é•¿åº¦ä¸º`j-1`çš„å­—ç¬¦ä¸² æ˜¯å¦åŒ¹é… ï¼Œå³`dp[i][j] = dp[i-1][j-1]`
![é™„ä»¶ä¸‹è½½å¤±è´¥](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/)


- å½“ `p[j-1] == '*'`éœ€è¦æ³¨æ„ç†è§£é¢˜ç›®ä¸­`*`çš„å«ä¹‰ï¼šè¡¨ç¤ºå‰é¢çš„å­—ç¬¦é‡å¤çš„æ¬¡æ•° `0`æ¬¡ or `1`æ¬¡ or å¤šæ¬¡ï¼Œæ¯”å¦‚`a*` è¡¨ç¤ºçš„å«ä¹‰ä¸º æ²¡æœ‰`a` æˆ–è€…åªæœ‰ä¸€ä¸ª`a` æˆ–è€… æ— æ•°ä¸ª`a`ã€‚æ‰€ä»¥ï¼Œçœ‹åˆ°`*`å‡ºç°çš„æ—¶å€™ï¼Œéœ€è¦çœ‹`*`å·å‰é¢çš„å­—ç¬¦æ˜¯ä»€ä¹ˆï¼Œä¹Ÿå°±æ˜¯`*`æœ¬èº«ä¸ä»£è¡¨ä»»ä½•â€œå­—ç¬¦å«ä¹‰â€ï¼Œåªæ˜¯è¡¨ç¤ºå‰é¢å­—ç¬¦é‡å¤çš„æ¬¡æ•°
![é™„ä»¶ä¸‹è½½å¤±è´¥](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/)

å½“`p[j-1] == '*'` å‰æä¸‹
å¦‚æœ `s[i-1] == p[j-2] æˆ–è€… p[j-2] == '.'`
å¦‚ä¸Šï¼šè¯´æ˜å­—ç¬¦ä¸²`p`ä¸­çš„ `c*` å¯ä»¥å’Œ å­—ç¬¦ä¸²`s`ä¸­çš„ `c` åšåŒ¹é…

```go
æ–¹æ¡ˆä¸€ï¼šc* å’Œ c åªå®Œæˆä¸€æ¬¡åŒ¹é… ï¼Œ
å­—ç¬¦ä¸²så‰©ä½™ ab
å­—ç¬¦ä¸²på‰©ä½™ab
é‚£ä¹ˆ dp[i][j] = dp[i-1][j-2]

æ–¹æ¡ˆäºŒï¼š c*å’Œ c å®ŒæˆåŒ¹é…åï¼Œç»§ç»­ç”¨c*ï¼ˆ*è¡¨ç¤ºå­—ç¬¦cå¯ä»¥æ— é™æ¬¡ä½¿ç”¨ï¼‰å’Œå‰©ä½™çš„å­—ç¬¦ä¸²såŒ¹é…
å­—ç¬¦ä¸²så‰©ä½™ab
å­—ç¬¦ä¸²på‰©ä½™ abc*  
é‚£ä¹ˆ dp[i][j] = dp[i-1][j]

æ–¹æ¡ˆä¸‰ï¼š c*ä¸å’Œ cåŒ¹é…ï¼Œä¹Ÿå°±æ˜¯å¿½ç•¥ c*çš„å­˜åœ¨ï¼ˆ*å¯ä»¥è¡¨ç¤ºå­—ç¬¦c å‡ºç°é›¶æ¬¡ï¼‰
å­—ç¬¦ä¸²så‰©ä½™ abc
å­—ç¬¦ä¸²på‰©ä½™ ab
é‚£ä¹ˆ dp[i][j] = dp[i][j-2]
```

```go
func isMatch(s string, p string) bool {
	/*
		    dp[i][j] : é•¿åº¦ä¸ºiçš„å­—ç¬¦ä¸² å’Œ é•¿åº¦ä¸ºjçš„å­—ç¬¦ä¸² æ˜¯å¦åŒ¹é…

	     è¿™ä¸ªé¢˜ç›®ä¸­*çš„å«ä¹‰ï¼šè¡¨ç¤ºå‰é¢çš„å­—ç¬¦é‡å¤çš„æ¬¡æ•° 0æ¬¡ or 1æ¬¡ orå¤šæ¬¡ï¼Œæ¯”å¦‚a* è¡¨ç¤ºçš„å«ä¹‰ä¸º æ²¡æœ‰a æˆ–è€… æ— æ•°ä¸ªa

		   if s[i-1] == p[j-1] || p[j-1] == '.' {
		       dp[i][j] = dp[i-1][j-1]
		   } else if p[j-1] == '*' {
	            // è¿™é‡Œè¦çœ‹ä¸‹*å‰é¢çš„å­—ç¬¦p[j-2]æ˜¯å¦å’Œ s[i-1] æœ‰åŒ¹é…å…³ç³»

	            if s[i-1] == p[j-2] || p[j-2] == '.' { // è¯´æ˜æœ‰åŒ¹é…å…³ç³»
	                // dp[i-1][j-2] :è¡¨ç¤ºåªç”¨æ¥åŒ¹é…ä¸€æ¬¡
	                // dp[i-1][j] è¡¨ç¤ºç»§ç»­ç”¨æ¥åŒ¹é…
	                // dp[i][j-2] è™½ç„¶åŒ¹é…ï¼Œå½“æ—¶æˆ‘é€‰æ‹© å½“å‰çš„è¿™ä¸ª*ä¸èµ·ä½œç”¨
	                dp[i][j] = dp[i-1][j-2] || dp[i-1][j] || dp[i][j-2]

	            } else { // ä¹‹é—´ä¸åŒ¹é…ï¼Œè¯´æ˜*é‡å¤å‰é¢çš„å­—ç¬¦æ²¡æœ‰æ„ä¹‰ï¼Œç›¸å½“äºé‡å¤0æ¬¡ï¼Œä¹Ÿå°±æ˜¯ä¸ç”¨æ¥åŒ¹é…ï¼ˆä¸èµ·ä½œç”¨ï¼‰
	                dp[i][j] = dp[i][j-2]
	            }
		   }
	*/

	m, n := len(s), len(p)
	dp := make([][]bool, m+1)
	for k := range dp {
		dp[k] = make([]bool, n+1)
	}
	
  // base case ä¸¤ä¸ªé•¿åº¦éƒ½æ˜¯0
	dp[0][0] = true
   
  // içš„é•¿åº¦ä¸º0, jçš„é•¿åº¦>=2çš„æ—¶å€™
	for j := 2; j <= n; j++ {
		if p[j-1] == '*' { // sä¸ºç©ºä¸² ï¼Œpä¸ä¸ºç©ºï¼Œåœ¨å‡ºç°*çš„æ—¶å€™ï¼Œé»˜è®¤å…¨éƒ¨éƒ½ä¸èµ·ä½œç”¨
			dp[0][j] = dp[0][j-2]
		}
	}

	for i := 1; i <= m; i++ {
		for j := 1; j <= n; j++ {
			if s[i-1] == p[j-1] || p[j-1] == '.' {
				dp[i][j] = dp[i-1][j-1]
			} else if p[j-1] == '*' { // å› ä¸º*çš„å«ä¹‰ï¼šå°±æ˜¯å‰é¢å­—ç¬¦é‡å¤çš„æ¬¡æ•°ï¼ˆ0æ¬¡oræ— æ•°æ¬¡ï¼‰
				// è¿™é‡Œè¦çœ‹ä¸‹*å‰é¢çš„å­—ç¬¦p[j-2]æ˜¯å¦å’Œ s[i-1] æœ‰åŒ¹é…å…³ç³»

				if s[i-1] == p[j-2] || p[j-2] == '.' { // è¯´æ˜æœ‰åŒ¹é…å…³ç³»
					// dp[i-1][j-2] :è¡¨ç¤ºåªç”¨æ¥åŒ¹é…ä¸€æ¬¡
					// dp[i-1][j] è¡¨ç¤ºç»§ç»­ç”¨æ¥åŒ¹é…
					// dp[i][j-2] è™½ç„¶åŒ¹é…ï¼Œä½†æ˜¯æˆ‘é€‰æ‹© å½“å‰çš„è¿™ä¸ª*ä¸èµ·ä½œç”¨
					dp[i][j] = dp[i-1][j-2] || dp[i-1][j] || dp[i][j-2]

				} else { // ä¹‹é—´ä¸åŒ¹é…ï¼Œè¯´æ˜*é‡å¤å‰é¢çš„å­—ç¬¦æ²¡æœ‰æ„ä¹‰ï¼Œç›¸å½“äºé‡å¤0æ¬¡ï¼Œä¹Ÿå°±æ˜¯ä¸ç”¨æ¥åŒ¹é…ï¼ˆä¸èµ·ä½œç”¨ï¼‰
					dp[i][j] = dp[i][j-2]
				}
			}
		}
	}
	return dp[m][n]
}
```
## 208. å®ç° Trieï¼ˆå‰ç¼€æ ‘ï¼‰
[**Trie**](https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E6%A0%91/9825209?fr=aladdin)ï¼ˆå‘éŸ³ç±»ä¼¼ "try"ï¼‰æˆ–è€…è¯´ **å‰ç¼€æ ‘** æ˜¯ä¸€ç§æ ‘å½¢æ•°æ®ç»“æ„ï¼Œç”¨äºé«˜æ•ˆåœ°å­˜å‚¨å’Œæ£€ç´¢å­—ç¬¦ä¸²æ•°æ®é›†ä¸­çš„é”®ã€‚è¿™ä¸€æ•°æ®ç»“æ„æœ‰ç›¸å½“å¤šçš„åº”ç”¨æƒ…æ™¯ï¼Œä¾‹å¦‚è‡ªåŠ¨è¡¥å…¨å’Œæ‹¼å†™æ£€æŸ¥ã€‚
è¯·ä½ å®ç° Trie ç±»ï¼š

- `Trie()` åˆå§‹åŒ–å‰ç¼€æ ‘å¯¹è±¡ã€‚
- `void insert(String word)` å‘å‰ç¼€æ ‘ä¸­æ’å…¥å­—ç¬¦ä¸² `word` ã€‚
- `boolean search(String word)` å¦‚æœå­—ç¬¦ä¸² `word` åœ¨å‰ç¼€æ ‘ä¸­ï¼Œè¿”å› `true`ï¼ˆå³ï¼Œåœ¨æ£€ç´¢ä¹‹å‰å·²ç»æ’å…¥ï¼‰ï¼›å¦åˆ™ï¼Œè¿”å› `false` ã€‚
- `boolean startsWith(String prefix)` å¦‚æœä¹‹å‰å·²ç»æ’å…¥çš„å­—ç¬¦ä¸² `word` çš„å‰ç¼€ä¹‹ä¸€ä¸º `prefix` ï¼Œè¿”å› `true` ï¼›å¦åˆ™ï¼Œè¿”å› `false`æ€è·¯ï¼š
è¿™é¢˜æ˜¯éå¸¸ç»å…¸çš„é¢˜ç›®ã€‚å¦‚æœçœ‹è¿‡æˆ‘ä¹‹å‰çš„`gin`æºç è§£æï¼Œæœ‰æåˆ°è¿‡æœ¬ç®—æ³•ã€‚æœ¬ç®—æ³•çš„ç›®çš„å°±æ˜¯ä¸ºäº†åšå­—ç¬¦ä¸²çš„åŒ¹é…ã€‚é€šè¿‡æ„å»ºå¤šå‰æ ‘ï¼Œå°†å­—ç¬¦ä¸²ä¿å­˜åˆ°æ ‘ä¸­ï¼ˆæ¯ä¸ªèŠ‚ç‚¹å°±æ˜¯ä¸€ä¸ªå­—ç¬¦ï¼‰ï¼Œå½“éœ€è¦æŸ¥æ‰¾æŸä¸ªå­—ç¬¦ä¸²æ—¶ï¼Œåªéœ€è¦ä»æ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œè¿›è¡ŒåŒ¹é…å­—ç¬¦å³å¯ã€‚

```go
type Trie struct {
    next [26]*Trie // 26ä¸ªå­—æ¯ï¼ˆ26å‰æ ‘ï¼‰
    s string // è®°å½•å­—ç¬¦ä¸²
}

func Constructor() Trie {
   return Trie{}
}

// ä¿å­˜å­—ç¬¦ä¸²
func (this *Trie) Insert(word string)  {

    for _, w := range word { // éå†å­—ç¬¦ä¸²
        // åœ¨æ ‘ä¸­åˆ¤æ–­å­—æ¯
        node := this.next[ w -'a']
        if node == nil {
            node = new(Trie)
            this.next[w-'a'] = node
        }
        this = node // è®©thisæŒ‡å‘æ–°èŠ‚ç‚¹
    }

    this.s = word // è¡¨ç¤ºå½“å‰thisæœ€åæŒ‡å‘çš„ä½ç½®ï¼Œå°±æ˜¯å­—ç¬¦ä¸²çš„æœ€åä¸€ä¸ªå­—æ¯
}

// æœç´¢å­—ç¬¦ä¸²
func (this *Trie) Search(word string) bool {

    for _,w := range word {
        node := this.next[w-'a']
        if node == nil { // è¯´æ˜æ²¡æœ‰æ‰¾åˆ°å­—æ¯
            return false
        }

        // æ‰¾åˆ°äº†ï¼Œç»§ç»­ä¸‹ä¸€ä¸ªå­—æ¯
        this = node
    }
    // ä¾‹å¦‚ :å…ˆæ’å…¥ apple ï¼Œç„¶åæœç´¢appï¼Œç¡®å®å¯ä»¥æœåˆ°ï¼Œä½†æ˜¯appä¸æ˜¯æœ‰æ•ˆçš„å­—ç¬¦ä¸²ï¼ˆå› ä¸ºæ²¡æœ‰æ’å…¥app)ï¼Œåªæ˜¯æ°å¥½å’Œappleçš„å‰åŠéƒ¨åˆ†ç›¸åŒè€Œå·²ï¼ˆå°±æ˜¯è¦æ±‚å®Œå…¨åŒ¹é…ï¼‰
    return this.s == word
}

// æœç´¢å‰ç¼€
func (this *Trie) StartsWith(prefix string) bool {
    for _,w := range prefix {
        node := this.next[w-'a']
        if node == nil { // è¯´æ˜æ²¡æœ‰æ‰¾åˆ°å­—æ¯
            return false
        }
        // æ‰¾åˆ°äº†ï¼Œç»§ç»­ä¸‹ä¸€ä¸ªå­—æ¯
        this = node
    }
    // å› ä¸ºåªæ˜¯æ‰¾å‰ç¼€ï¼Œå¹¶ä¸æ˜¯è¦æ±‚å®Œå…¨åŒ¹é…
    return true
}
```
## 230. äºŒå‰æœç´¢æ ‘ä¸­ç¬¬Kå°çš„å…ƒç´ 
ç»™å®šä¸€ä¸ªäºŒå‰æœç´¢æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œå’Œä¸€ä¸ªæ•´æ•° `k` ï¼Œè¯·ä½ è®¾è®¡ä¸€ä¸ªç®—æ³•æŸ¥æ‰¾å…¶ä¸­ç¬¬ `k` å°çš„å…ƒç´ ï¼ˆä» 1 å¼€å§‹è®¡æ•°ï¼‰ã€‚
æ€è·¯ï¼š
æœ¬é¢˜å’Œ**LCR 174. å¯»æ‰¾äºŒå‰æœç´¢æ ‘ä¸­çš„ç›®æ ‡èŠ‚ç‚¹**ä¸€æ ·çš„é¢˜ç›®ï¼ˆè¿™ä¸ªæ˜¯æ±‚ç¬¬Kå¤§å…ƒç´ ï¼‰ï¼Œåªæ˜¯æœ¬é¢˜æ˜¯æ±‚ç¬¬Kå°å…ƒç´ ã€‚
åˆ©ç”¨ä¸­åºéå†ï¼šå·¦æ ¹å³ï¼Œ**æ³¨æ„å’Œ LCR174çš„åŒºåˆ«ï¼ˆå³æ ¹å·¦ï¼‰**

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */


func kthSmallest(root *TreeNode, k int) int {
	stack := []*TreeNode{}
	for root != nil || len(stack) > 0 {

		for root != nil { // ä¸æ–­çš„å¾€æ ˆä¸­è¿½åŠ å…ƒç´ 
			stack = append(stack, root)
			root = root.Left
		}
		// ä»æ ˆä¸­å¼¹å‡ºå…ƒç´ 
		root := stack[len(stack)-1]
		stack = stack[:len(stack)-1]

		k--
		if k == 0 { // æ‰¾åˆ°ç¬¬kå°çš„å…ƒç´ 
			return root.Val
		}
		root = root.Right
	}
	return 0
}
```
## 295. æ•°æ®æµçš„ä¸­ä½æ•°
**ä¸­ä½æ•°**æ˜¯æœ‰åºæ•´æ•°åˆ—è¡¨ä¸­çš„ä¸­é—´å€¼ã€‚å¦‚æœåˆ—è¡¨çš„å¤§å°æ˜¯å¶æ•°ï¼Œåˆ™æ²¡æœ‰ä¸­é—´å€¼ï¼Œä¸­ä½æ•°æ˜¯ä¸¤ä¸ªä¸­é—´å€¼çš„å¹³å‡å€¼ã€‚

- ä¾‹å¦‚ `arr = [2,3,4]` çš„ä¸­ä½æ•°æ˜¯ `3` ã€‚
- ä¾‹å¦‚ `arr = [2,3]` çš„ä¸­ä½æ•°æ˜¯ `(2 + 3) / 2 = 2.5` ã€‚å®ç° MedianFinder ç±»:

- `MedianFinder() `åˆå§‹åŒ– `MedianFinder` å¯¹è±¡ã€‚
- `void addNum(int num)` å°†æ•°æ®æµä¸­çš„æ•´æ•° `num` æ·»åŠ åˆ°æ•°æ®ç»“æ„ä¸­ã€‚
- `double findMedian()` è¿”å›åˆ°ç›®å‰ä¸ºæ­¢æ‰€æœ‰å…ƒç´ çš„ä¸­ä½æ•°ã€‚ä¸å®é™…ç­”æ¡ˆç›¸å·® `10-5` ä»¥å†…çš„ç­”æ¡ˆå°†è¢«æ¥å—ã€‚æ€è·¯ï¼š
æœ¬é¢˜çš„æ ¸å¿ƒæ€è·¯æ˜¯ä½¿ç”¨ä¸¤ä¸ª ä¼˜å…ˆçº§é˜Ÿåˆ—ã€‚æ³¨æ„ï¼šå¤§æ ¹å †å’Œå°æ ¹å †åªæ˜¯ä¿è¯ã€å †é¡¶å…ƒç´ ä¸ºæœ€å¤§oræœ€å°å€¼ã€‘ï¼Œå †ä¸­çš„å…¶ä»–çš„å…ƒç´ ä¸æ˜¯æœ‰åºçš„ã€‚
![é™„ä»¶ä¸‹è½½å¤±è´¥](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/)

è¿™é‡Œç”¨ä¸¤ä¸ªå †çš„ç›®çš„åœ¨äºå°†æ•°ç»„ä»ä¸­é—´ä¸€åˆ‡ä¸¤åŠï¼š
å‰ä¸€åŠï¼ˆå°çš„éƒ¨åˆ†ï¼‰ç”¨å¤§æ ¹å †ï¼Œä¿è¯æœ€å¤§çš„å…ƒç´ åœ¨é¡¶éƒ¨
åä¸€åŠï¼ˆå¤§çš„éƒ¨åˆ†ï¼‰ç”¨å°æ ¹å †ï¼Œä¿è¯æœ€å°çš„å…ƒç´ åœ¨é¡¶éƒ¨
è¿™å¤§æ ¹å †å’Œå°æ ¹å † å †é¡¶çš„ä¸¤ä¸ªå…ƒç´ ï¼Œæ°å¥½å°±æ˜¯æ•°ç»„çš„ä¸­é—´çš„ä¸¤ä¸ªå…ƒç´ ï¼ˆå¾ˆå·§å¦™ï¼‰

```go
è¿™é‡Œå†ä¸¾ä¾‹è¯´æ˜ä¸‹ç®—æ³•çš„è¿è¡ŒåŸç†ï¼š

é¢˜ç›®æ„æ€ï¼šä¸­ä½æ•°ï¼šå³ã€æœ‰åºæ•°ç»„ã€‘çš„ä¸­é—´å€¼ï¼Œä½†æ˜¯addNumæ•°å€¼çš„æ—¶å€™æ˜¯æ— åºå¢åŠ ï¼›æ‰€ä»¥è®©æˆ‘ä»¬è¦æƒ³åŠæ³•ï¼Œæ¥èƒ½æ‰¾åˆ°è¿™ä¸ªä¸­ä½æ•°

ä¾‹å¦‚ï¼š
å…ƒç´ ä¸º 3 5 8 1 2 4
æœ‰åºæ•°ç»„ä¸º 1 2 3 4 5 8 ï¼ˆå³ï¼Œæ’åºåçš„æœ‰åºæ•°ç»„ï¼‰

å‰é¢çš„éƒ¨åˆ†ã€å°ã€‘ï¼Œç”¨å¤§æ ¹å †å­˜å‚¨ 123 ï¼Œ
ã€3ã€‘
ã€2ã€‘
ã€1ã€‘
å †é¡¶å…ƒç´ æ˜¯3

åé¢çš„éƒ¨åˆ†ã€å¤§ã€‘ï¼Œç”¨å°æ ¹å †å­˜å‚¨ 
ã€4ã€‘
ã€5ã€‘
ã€8ã€‘
å †é¡¶å…ƒç´ æ˜¯4

ä¸­ä½æ•°å³ä¸ºï¼šå¤§æ ¹å † 3 + å°æ ¹å † 4 = 3.5
```
æ¯æ¬¡æœ‰æ–°å…ƒç´  `addNum` çš„æ—¶å€™ï¼Œéœ€è¦å…ˆç»è¿‡ã€å¤§æ ¹å †ã€‘è¿‡æ»¤ï¼ˆç›®çš„åœ¨äºæ²‰æ·€ä¸‹æ¥è¾ƒå°çš„å…ƒç´ ï¼‰ï¼Œå¼¹å‡ºè¾ƒå¤§çš„å…ƒç´ ï¼›
ç„¶åå°†è¾ƒå¤§çš„å…ƒç´ ï¼Œå†æ”¾å…¥åˆ°ã€å°æ ¹å †ã€‘è¿‡æ»¤ï¼ˆç›®çš„åœ¨äºæ²‰æ·€ä¸‹æ¥è¾ƒå¤§çš„å…ƒç´ ï¼‰, å¼¹å‡ºè¾ƒå°çš„å…ƒç´ ï¼›
ä¿è¯å¤§æ ¹å †å…ƒç´ æ•°é‡ >= å°æ ¹å †å…ƒç´ æ•°é‡ï¼ˆå½“æ•°é‡ç›¸åŒï¼Œè¡¨ç¤ºå…ƒç´ æ˜¯å¶æ•°ä¸ªï¼Œå½“å¤§æ ¹å †å…ƒç´ å¤§äºå°æ ¹å †ï¼Œè¯´æ˜æ˜¯å¥‡æ•°ä¸ªï¼‰

```go
// å¤§æ ¹å †
type MaxHeap struct {
    nums []int
}

func (m *MaxHeap)Swap(i,j int) {
    m.nums[i],m.nums[j] = m.nums[j],m.nums[i]
}

func(m *MaxHeap)Less(i,j int) bool {
    return m.nums[i] > m.nums[j]
}

func(m *MaxHeap)Len() int{
    return len(m.nums)
}

func (m *MaxHeap) Push(x any) {
    m.nums = append(m.nums,x.(int))
}

func (m *MaxHeap)Pop() any {
    x := m.nums[len(m.nums)-1]
    m.nums = m.nums[:len(m.nums)-1]
    return x
}

func(m *MaxHeap)Top() int {
    return m.nums[0]
}

// å°æ ¹å †

type MinHeap struct {
    nums []int
}

func (m *MinHeap)Swap(i,j int) {
    m.nums[i],m.nums[j] = m.nums[j],m.nums[i]
}

func(m *MinHeap)Less(i,j int) bool {
    return m.nums[i] < m.nums[j]
}

func(m *MinHeap)Len() int{
    return len(m.nums)
}

func (m *MinHeap) Push(x any) {
    m.nums = append(m.nums,x.(int))
}

func (m *MinHeap)Pop() any {
    x := m.nums[len(m.nums)-1]
    m.nums = m.nums[:len(m.nums)-1]
    return x
}

func(m *MinHeap)Top() int {
    return m.nums[0]
}

type MedianFinder struct {
    maxHeap *MaxHeap
    minHeap *MinHeap
}


func Constructor() MedianFinder {

    finder :=  MedianFinder {
        maxHeap: &MaxHeap{},
        minHeap: &MinHeap{},
    }

    // åˆå§‹åŒ–å¤§å°å † å¯¹è±¡
   // heap.Init(finder.maxHeap)
   // heap.Init(finder.minHeap)
    return finder
}


func (this *MedianFinder) AddNum(num int)  {
    // å…ˆæ”¾å…¥å¤§æ ¹å †
    heap.Push(this.maxHeap,num)
    // å¼¹å‡ºå¤§æ ¹å †å †é¡¶å…ƒç´ ï¼Œå†æ”¾å…¥å°æ ¹å †
    heap.Push(this.minHeap,heap.Pop(this.maxHeap))

    // ä¿è¯å¤§æ ¹å † >= å°æ ¹å †
    for this.maxHeap.Len() < this.minHeap.Len() {
        heap.Push(this.maxHeap, heap.Pop(this.minHeap)) // å¼¹å‡ºå°æ ¹å †ï¼Œæ”¾å…¥å¤§æ ¹å †
    }
}

func (this *MedianFinder) FindMedian() float64 {
    if this.maxHeap.Len() > this.minHeap.Len() { // è¯´æ˜å…ƒç´ ä¸ªæ•°ï¼Œå¥‡æ•°
        return float64(this.maxHeap.Top())
    }

    return float64(this.maxHeap.Top() + this.minHeap.Top()) / 2  // è¯´æ˜å…ƒç´ ä¸ªæ•°ï¼Œå¶æ•°
}
```
## LCR 187. ç ´å†°æ¸¸æˆ
ç¤¾å›¢å…±æœ‰ `num` ä½æˆå‘˜å‚ä¸ç ´å†°æ¸¸æˆï¼Œç¼–å·ä¸º `0 ~ num-1`ã€‚æˆå‘˜ä»¬æŒ‰ç…§ç¼–å·é¡ºåºå›´ç»•åœ†æ¡Œè€Œåã€‚ç¤¾é•¿æŠ½å–ä¸€ä¸ªæ•°å­— `target`ï¼Œä» 0 å·æˆå‘˜èµ·å¼€å§‹è®¡æ•°ï¼Œæ’åœ¨ç¬¬ `target` ä½çš„æˆå‘˜ç¦»å¼€åœ†æ¡Œï¼Œä¸”æˆå‘˜ç¦»å¼€åä»ä¸‹ä¸€ä¸ªæˆå‘˜å¼€å§‹è®¡æ•°ã€‚è¯·è¿”å›æ¸¸æˆç»“æŸæ—¶æœ€åä¸€ä½æˆå‘˜çš„ç¼–å·ã€‚
**ç¤ºä¾‹ 1ï¼š**

```go
è¾“å…¥ï¼šnum = 7, target = 4
è¾“å‡ºï¼š1
```
**ç¤ºä¾‹ 2ï¼š**

```go
è¾“å…¥ï¼šnum = 12, target = 5
è¾“å‡ºï¼š0
```
æ€è·¯ï¼š
æœ¬é¢˜å±äºçº¦ç‘Ÿå¤«ç¯é—®é¢˜ï¼Œåªéœ€è¦è®°ä½ç»“è®ºç»“è®ºå³å¯ã€‚
è¿™é‡Œé€šè¿‡ä¸¾ä¾‹å­çš„æ–¹å¼æ¥æ¨å¯¼æœ¬é¢˜çš„è§£æ³•ï¼ˆå¦‚æœæ•°å­¦å¥½çš„ï¼Œä¹Ÿå¯ä»¥ç”¨æ•°å­¦å…¬å¼æ¥æ±‚è§£ï¼‰
è¿™é‡Œä»¥`num = 5 target = 3`ä¸ºä¾‹ï¼Œå³æ€»å…±æœ‰`5`ä¸ªæ•°å­—ï¼Œæ¯æ¬¡åˆ é™¤ç¬¬`3`ä¸ªæ•°å­—

```go
ä¸€å¼€å§‹çš„æ•°å­—ä¸º 0 1 2 3 4
ä»ç´¢å¼•0å¼€å§‹ï¼Œåˆ é™¤ç¬¬3ä¸ªæ•°å­—ï¼ˆä¹Ÿå°±æ˜¯æ•°å­—2ï¼‰ï¼Œç»“æœä¸ºï¼š 0 1  3 4ï¼Œè¿™é‡Œæˆ‘ä»¬æ•´ç†ä¸‹ï¼Œå°†ä¸‹ä¸€ä¸ªè¦å¼€å§‹çš„ç´¢å¼•ï¼Œæ”¾åˆ°ç¬¬ä¸€ä½ï¼Œä¹Ÿå°±æ˜¯ 3 4 0 1
æˆ‘ä»¬ç»§ç»­ä»ç´¢å¼•0å¼€å§‹ï¼Œåˆ é™¤ç¬¬3ä¸ªæ•°å­—ï¼ˆä¹Ÿå°±æ˜¯æ•°å­—0ï¼‰ï¼Œç»“æœä¸ºï¼š 3 4 1ï¼Œç»§ç»­æ•´ç†ä¸‹ï¼Œå°†ä¸€ä¸‹è¦å¼€å§‹çš„ç´¢å¼•ï¼Œæ”¾åˆ°ç¬¬ä¸€ä½ï¼Œä¹Ÿå°±æ˜¯ 1 3 4
åŒä¸Šï¼Œä»ç´¢å¼•0å¼€å§‹ï¼Œåˆ é™¤ç¬¬3ä¸ªæ•°å­—ï¼ˆä¹Ÿå°±æ˜¯æ•°å­—4ï¼‰ï¼Œç»“æœä¸º 1 3ï¼Œç»§ç»­æ•´ç†ä¸‹ï¼Œå°†ä¸€ä¸‹è¦å¼€å§‹çš„ç´¢å¼•ï¼Œæ”¾åˆ°ç¬¬ä¸€ä½ï¼Œä¹Ÿå°±æ˜¯ 1 3
åŒä¸Šï¼Œä»ç´¢å¼•0å¼€å§‹ï¼Œåˆ é™¤ç¬¬3ä¸ªæ•°å­—ï¼ˆä¹Ÿå°±æ˜¯æ•°å­—1ï¼‰ï¼Œç»“æœä¸º 3ï¼Œä¹Ÿå°±æ˜¯æœ¬é¢˜çš„æœ€ç»ˆç»“æœ

æ•´ç†ä¸‹æ•´ä¸ªçš„æ•°å­—å¦‚ä¸‹ï¼š
0 1 2 3 4
3 4 0 1 
1 3 4
1 3
3
ä»è¿™é‡Œå…¶å®ä¹Ÿçœ‹ä¸å‡ºä»€ä¹ˆè§„å¾‹æ¥ã€‚
æˆ‘ä»¬å¯ä»¥ä»æœ€åä¸€è¡Œ 3 ç€æ‰‹ï¼Œæ­¤æ—¶ç´¢å¼•ä¸º0ï¼Œæˆ‘ä»¬çŸ¥é“æœ€åä¸€è¡Œæ˜¯ç”±å€’æ•°ç¬¬äºŒè¡Œ 1 3å¾—æ¥çš„

æ¨å¹¿æˆä¸€èˆ¬ç»“è®ºå³ï¼š
å¦‚æœæˆ‘ä»¬åœ¨æ•°å­—3å‰é¢å†åŠ å› target = 3 ä¸ªæ•°å­—å‘¢ï¼Ÿé‚£å°±æ˜¯ 1,3,1,3 
åŸæœ¬ç´¢å¼•ä¸‹æ ‡æ˜¯0çš„3ç”±äºå‰é¢åŠ äº† targetä¸ªæ•°å­—ï¼Œå› æ­¤ç°åœ¨ç´¢å¼•ä¸‹æ ‡æˆäº†0+targetï¼Œè€Œä¸”æˆ‘ä»¬è¡¥æˆäº†1,3çš„å¾ªç¯ï¼Œæ‰€ä»¥é€šè¿‡å–æ¨¡æ–¹å¼å¯ä»¥çŸ¥é“å‰é¢ä¸€ä¸ªæ•°å­—3çš„ä¸‹æ ‡ç´¢å¼•idx=(0+target)%2

å…¬å¼ä¸­0å…¶å®æ˜¯æœ€åä¸€è¡Œæ•°å­—3çš„ä¸‹æ ‡ï¼Œ
è€Œå…¬å¼ä¸­2æ˜¯å€’æ•°ç¬¬äºŒè¡Œçš„å…ƒç´ ä¸ªæ•°ï¼Œ
æœ€åæ±‚å¾—å€’æ•°ç¬¬äºŒè¡Œæ•°å­—3çš„ä¸‹æ ‡ã€‚
æ‰€ä»¥å¾ˆå®¹æ˜“å¾—å‡ºäº† idx=(idx+target)%num è¿™ä¸ªå…¬å¼

é€šè¿‡è¿™ä¸ªå…¬å¼å¯çŸ¥ï¼Œæˆ‘ä»¬ä¸éœ€è¦çŸ¥é“æœ€åä¸€ä¸ªæ•°å€¼æ˜¯ä»€ä¹ˆï¼Œåªéœ€è¦çŸ¥é“ target num è¿™ä¸¤ä¸ªæ•°å€¼ï¼Œä»¥åŠèµ·å§‹idx=0å³å¯
```
![é™„ä»¶ä¸‹è½½å¤±è´¥](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/)


```go
func iceBreakingGame(num int, target int) int {
    
    // numä¸ªæ•°å­—ï¼Œæ¯æ¬¡åˆ é™¤ç¬¬targetæ•°å­—ï¼Œæœ€åç•™ä¸‹æ¥çš„æ•°å­—æ˜¯ ??

    idx := 0 // å…¶å®ç´¢å¼•
    for i := 2;i <=num;i++ {
				//  targetè¡¨ç¤ºåˆ é™¤ç¬¬å‡ ä¸ªæ•°
        idx = (idx + target) % i // iè¡¨ç¤ºæ¯è¡Œå…ƒç´ ä¸ªæ•° 
    }

    return idx
}
```
## 189. è½®è½¬æ•°ç»„
ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums`ï¼Œå°†æ•°ç»„ä¸­çš„å…ƒç´ å‘å³è½®è½¬ `k` ä¸ªä½ç½®ï¼Œå…¶ä¸­ `k` æ˜¯éè´Ÿæ•°ã€‚
**ç¤ºä¾‹ 1:**

```go
è¾“å…¥: nums = [1,2,3,4,5,6,7], k = 3
è¾“å‡º: [5,6,7,1,2,3,4]
è§£é‡Š:
å‘å³è½®è½¬ 1 æ­¥: [7,1,2,3,4,5,6]
å‘å³è½®è½¬ 2 æ­¥: [6,7,1,2,3,4,5]
å‘å³è½®è½¬ 3 æ­¥: [5,6,7,1,2,3,4]
```
æ€è·¯ï¼š

```go
è¿™é¢˜ä¸»è¦æ˜¯çœ‹å‡ºæ€è·¯,å°±å¾ˆç®€å•(å…¶å®å°±æ˜¯æ•°ç»„è¢«åˆ‡å‰²æˆäº†ä¸¤ä¸ªéƒ¨åˆ†)
[1,2,3,4,5,6,7]
æ•´ä½“ç¿»è½¬
[7,6,5,   4,3,2,1]
å›´ç»•kåˆ†æˆå·¦å³å­æ•°ç»„ï¼Œåˆ†åˆ«ç¿»è½¬
[5,6,7    1,2,3,4]
```

```go
func rotate(nums []int, k int) {

	k = k % len(nums) //  k == 0 è¯´æ˜è½¬äº†ä¸€åœˆï¼Œåˆè½¬å›æ¥çš„ï¼Œä¸ç”¨å»åšè½®è½¬äº†

	if k > 0 { // è¯´æ˜éœ€è¦è¿›è¡Œè½®è½¬

		// 1. å…ˆå¯¹æ•´ä¸ªæ•°ç»„è¿›è¡Œç¿»è½¬
		left, right := 0, len(nums)-1
		reverse(nums, left, right)

		// 2. ç„¶åä»¥ k ä½œä¸ºåˆ†å‰²ï¼Œå°†å·¦å³å­æ•°ç»„åˆ†åˆ«è¿›è¡Œç¿»è½¬
		left, right = 0, k-1 // å·¦å­æ•°ç»„
		reverse(nums, left, right)

		left, right = k, len(nums)-1 // å³å­æ•°ç»„
		reverse(nums, left, right)
	}
}

func reverse(nums []int, left, right int) {

	for left < right {
		nums[left], nums[right] = nums[right], nums[left]
		left++
		right--
	}
}
```
## 225. ç”¨é˜Ÿåˆ—å®ç°æ ˆ
è¯·ä½ ä»…ä½¿ç”¨ä¸¤ä¸ªé˜Ÿåˆ—å®ç°ä¸€ä¸ªåå…¥å…ˆå‡ºï¼ˆLIFOï¼‰çš„æ ˆï¼Œå¹¶æ”¯æŒæ™®é€šæ ˆçš„å…¨éƒ¨å››ç§æ“ä½œï¼ˆ`push`ã€`top`ã€`pop` å’Œ `empty`ï¼‰ã€‚
å®ç° `MyStack` ç±»ï¼š

- `void push(int x)` å°†å…ƒç´  x å‹å…¥æ ˆé¡¶ã€‚
- `int pop()` ç§»é™¤å¹¶è¿”å›æ ˆé¡¶å…ƒç´ ã€‚
- `int top()` è¿”å›æ ˆé¡¶å…ƒç´ ã€‚
- `boolean empty()` å¦‚æœæ ˆæ˜¯ç©ºçš„ï¼Œè¿”å› `true` ï¼›å¦åˆ™ï¼Œè¿”å› `false` ã€‚æ€è·¯ï¼š
è¿™ç§é¢˜ç›®åªæ˜¯æ¥é”»ç‚¼æ€ç»´é€»è¾‘ï¼Œä¸ç”¨åœ¨æ„é¢˜ç›®æœ‰æ²¡æœ‰ä»€ä¹ˆæ„ä¹‰ã€‚
å…¶å®åªéœ€è¦ç”¨ä¸€ä¸ªé˜Ÿåˆ—å³å¯æ¨¡æ‹Ÿæ ˆçš„æ•ˆæœ
![é™„ä»¶ä¸‹è½½å¤±è´¥](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/)


```go
type MyStack struct {
    queue []int
}


func Constructor() MyStack {
    return MyStack{
        queue:make([]int,0),
    }
}


func (this *MyStack) Push(x int)  {
    l := len(this.queue) // å…ˆè®°å½•ä¸‹é˜Ÿåˆ—å·²æœ‰çš„å…ƒç´ æ•°é‡

    this.queue = append(this.queue,x) // å…¥é˜Ÿä¸€ä¸ªæ–°å…ƒç´ 

    for l > 0 { // å°†æ–°å…ƒç´ å‰é¢çš„ï¼Œæ—§å…ƒç´ ï¼Œå‡ºé˜Ÿå¹¶ä¸”å†å…¥é˜Ÿï¼ˆç›¸å½“äºä¿å­˜åˆ°äº†æ–°å…ƒç´ çš„åé¢ï¼Œè¾¾åˆ°æ ˆçš„æ•ˆæœï¼‰
        
        this.queue = append(this.queue,this.queue[0]) // å°†é˜Ÿåˆ—é¦–éƒ¨å…ƒç´ ï¼Œåˆé‡æ–°æ”¾å…¥å°¾éƒ¨
        this.queue = this.queue[1:] // å»æ‰é¦–éƒ¨å…ƒç´ 
        l--
    }
}


func (this *MyStack) Pop() int {
    x := this.queue[0]

    this.queue = this.queue[1:]

    return x
}


func (this *MyStack) Top() int {
    x := this.queue[0]

    return x
}


func (this *MyStack) Empty() bool {
    return len(this.queue) == 0
}
```
## 287. å¯»æ‰¾é‡å¤æ•°
ç»™å®šä¸€ä¸ªåŒ…å« `n + 1` ä¸ªæ•´æ•°çš„æ•°ç»„ `nums` ï¼Œå…¶æ•°å­—éƒ½åœ¨ `[1, n]` èŒƒå›´å†…ï¼ˆåŒ…æ‹¬ `1` å’Œ `n`ï¼‰ï¼Œå¯çŸ¥è‡³å°‘å­˜åœ¨ä¸€ä¸ªé‡å¤çš„æ•´æ•°ã€‚
å‡è®¾ `nums` åªæœ‰ **ä¸€ä¸ªé‡å¤çš„æ•´æ•°** ï¼Œè¿”å› **è¿™ä¸ªé‡å¤çš„æ•°** ã€‚
ä½ è®¾è®¡çš„è§£å†³æ–¹æ¡ˆå¿…é¡» **ä¸ä¿®æ”¹** æ•°ç»„ `nums` ä¸”åªç”¨å¸¸é‡çº§ `O(1)` çš„é¢å¤–ç©ºé—´ã€‚
**ç¤ºä¾‹ 1ï¼š**

```go
è¾“å…¥ï¼šnums = [1,3,4,2,2]
è¾“å‡ºï¼š2
```
æ€è·¯ï¼š
æä¾›äº†ä¸¤ç§è§£æ³•ï¼š
ç¬¬ä¸€ç§è§£æ³•ï¼šç±»ä¼¼äº**141.ç¯å½¢é“¾è¡¨**å¯»æ‰¾ç¯ç‚¹ï¼ˆå¯ä»¥å…ˆçœ‹ä¸‹ï¼Œåœ¨æ¥çœ‹ä¸‹æœ¬é¢˜ï¼‰
ç¬¬äºŒç§è§£æ³•ï¼šå¦‚æœé¢˜ç›®æ²¡æœ‰ä¸èƒ½ä¿®æ”¹æ•°ç»„çš„é™åˆ¶ï¼Œç±»ä¼¼äº**442. æ•°ç»„ä¸­é‡å¤çš„æ•°æ®**è§£æ³•

```go
// è§£æ³•ä¸€ï¼š
func findDuplicate(nums []int) int {
    // è¿™é¢˜çš„æ€è·¯å¾ˆå¥‡ç‰¹ï¼Œç”¨æ•°ç»„çš„å€¼ï¼ˆä½œä¸ºç´¢å¼•ä½ç½®ï¼‰ï¼Œåˆ¤æ–­æ•°ç»„çš„ç¯
    //1.åˆå§‹åŒ–å¿«æ…¢æŒ‡é’ˆ

    slow,fast := 0,0 // å°†slow,fastéƒ½ç†è§£ä¸ºæ•°å€¼
    // ä¾‹å¦‚ï¼š 0  [1  2  2] 
    // slowï¼Œfastä¸€å¼€å§‹éƒ½æŒ‡å‘æ•°å€¼0,è¿™ä¸ª0å…¶å®æ˜¯ä¸ªè™šæ‹Ÿçš„èµ·å§‹èŠ‚ç‚¹
    for {
        slow = nums[slow] // slowè·³è·ƒä¸€ä¸‹ï¼Œç”±æ•°å€¼0->æ•°å€¼1
        fast = nums[nums[fast]] // ç›¸å½“äºfastè·³è·ƒäº†ä¸¤æ¬¡ï¼Œä»0 ->1 -> 2

        // æ­¤æ—¶ 1 ï¼= 2 ï¼Œç»§ç»­è·³è·ƒ

        // slow ä» 1->2
        // fast ä» 2->2->2 ,æ­¤æ—¶slow==fast
        if slow == fast {
            break
        }
    }
    // ä¸Šé¢åªæ˜¯è¡¨ç¤ºæœ‰ç¯ï¼Œè¦æ±‚çš„æ˜¯ç¯çš„èµ·å§‹ç›¸äº¤ç‚¹
    slow = 0 
    for {
        slow = nums[slow]
        fast = nums[fast]
        if slow == fast {
            break
        }
    }
    return slow
}


// è§£æ³•äºŒï¼Œä¿®æ”¹äº†æ•°ç»„ä¸­çš„å…ƒç´ ï¼ˆè™½ç„¶ä¹Ÿæ˜¯å¯ä»¥æ‰¾åˆ°ç­”æ¡ˆï¼‰
func findDuplicate1(nums []int) int {


    for i := 0;i < len(nums);i++ {

        idx :=  abs(nums[i]) - 1

        if nums[idx] > 0 {
            nums[idx] = -nums[idx]
        }else {
            return abs(nums[i])
        }
    }
    return 0
}

func abs(a int) int {
    if a < 0 {
        return -a
    }

    return a
}
```
## LCR 139. è®­ç»ƒè®¡åˆ’ I
æ•™ç»ƒä½¿ç”¨æ•´æ•°æ•°ç»„ `actions` è®°å½•ä¸€ç³»åˆ—æ ¸å¿ƒè‚Œç¾¤è®­ç»ƒé¡¹ç›®ç¼–å·ã€‚ä¸ºå¢å¼ºè®­ç»ƒè¶£å‘³æ€§ï¼Œéœ€è¦å°†æ‰€æœ‰å¥‡æ•°ç¼–å·è®­ç»ƒé¡¹ç›®è°ƒæ•´è‡³å¶æ•°ç¼–å·è®­ç»ƒé¡¹ç›®ä¹‹å‰ã€‚è¯·å°†è°ƒæ•´åçš„è®­ç»ƒé¡¹ç›®ç¼–å·ä»¥ **æ•°ç»„** å½¢å¼è¿”å›ã€‚
**ç¤ºä¾‹ 1ï¼š**

```go
è¾“å…¥ï¼šactions = [1,2,3,4,5]
è¾“å‡ºï¼š[1,3,5,2,4] 
è§£é‡Šï¼šä¸ºæ­£ç¡®ç­”æ¡ˆä¹‹ä¸€
```
æ€è·¯ï¼š
æœ¬é¢˜é‡‡ç”¨å¿«æ…¢æŒ‡é’ˆæŠ€å·§ï¼Œ`fast`è´Ÿè´£éå†æ‰€æœ‰å…ƒç´ ï¼Œ`slow`è´Ÿè´£å­˜å‚¨å¥‡æ•°

```go
func trainingPlan(actions []int) []int {

    slow, fast := 0,0
    for fast < len(actions) {

        if actions[fast] % 2 == 1 { // å¥‡æ•°
            actions[slow],actions[fast] = actions[fast],actions[slow]
            slow++
        }
        fast++
    }   

    return actions
}
```
## 106. ä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘
ç»™å®šä¸¤ä¸ªæ•´æ•°æ•°ç»„ `inorder` å’Œ `postorder` ï¼Œå…¶ä¸­ `inorder` æ˜¯äºŒå‰æ ‘çš„ä¸­åºéå†ï¼Œ `postorder` æ˜¯åŒä¸€æ£µæ ‘çš„ååºéå†ï¼Œè¯·ä½ æ„é€ å¹¶è¿”å›è¿™é¢— *äºŒå‰æ ‘* ã€‚ç»™å®šä¸¤ä¸ªæ•´æ•°æ•°ç»„ `inorder` å’Œ `postorder` ï¼Œå…¶ä¸­ `inorder` æ˜¯äºŒå‰æ ‘çš„ä¸­åºéå†ï¼Œ `postorder` æ˜¯åŒä¸€æ£µæ ‘çš„ååºéå†ï¼Œè¯·ä½ æ„é€ å¹¶è¿”å›è¿™é¢— *äºŒå‰æ ‘* ã€‚
æ€è·¯ï¼š
æœ¬é¢˜å’Œ**105. ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘**é¢˜ç›®ç±»ä¼¼ã€‚å‰åºéå†å’Œååºéå†æ˜¯ç ´é¢˜çš„å…³é”®

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func buildTree(inorder []int, postorder []int) *TreeNode {
    //1.ä»ååºéå†ï¼Œå…ˆæ‰¾åˆ°æ ¹èŠ‚ç‚¹
    if len(postorder) == 0 {
        return nil
    }
    postVal := postorder[len(postorder)-1] // å°¾éƒ¨çš„å…ƒç´ ï¼ˆå³ä¸ºï¼Œæ ¹èŠ‚ç‚¹å€¼ï¼‰
    root := &TreeNode{Val:postVal,Left:nil,Right:nil}
    //2.æˆªå– inorder å’Œ postorder
    leftLen := 0
    for k,v := range inorder {
        if v == postVal {
            leftLen = k
            break
        }
    }
    
    root.Left = buildTree(inorder[0:leftLen],postorder[0:leftLen])
    root.Right = buildTree(inorder[leftLen+1:],postorder[leftLen:len(postorder)-1])

    return root
}
```
## 9. å›æ–‡æ•°
ç»™ä½ ä¸€ä¸ªæ•´æ•° `x` ï¼Œå¦‚æœ `x` æ˜¯ä¸€ä¸ªå›æ–‡æ•´æ•°ï¼Œè¿”å› `true` ï¼›å¦åˆ™ï¼Œè¿”å› `false` ã€‚
å›æ–‡æ•°æ˜¯æŒ‡æ­£åºï¼ˆä»å·¦å‘å³ï¼‰å’Œå€’åºï¼ˆä»å³å‘å·¦ï¼‰è¯»éƒ½æ˜¯ä¸€æ ·çš„æ•´æ•°ã€‚

- ä¾‹å¦‚ï¼Œ`121` æ˜¯å›æ–‡ï¼Œè€Œ `123` ä¸æ˜¯ã€‚**ç¤ºä¾‹ 1ï¼š**
**ç¤ºä¾‹ 2ï¼š**

```go
è¾“å…¥ï¼šx = -121
è¾“å‡ºï¼šfalse
è§£é‡Šï¼šä»å·¦å‘å³è¯», ä¸º -121 ã€‚ ä»å³å‘å·¦è¯», ä¸º 121- ã€‚å› æ­¤å®ƒä¸æ˜¯ä¸€ä¸ªå›æ–‡æ•°ã€‚
```
æ€è·¯ï¼š

- æ ¹æ®ä¸Šé¢ç¤ºä¾‹å¯çŸ¥ï¼Œå¦‚æœæ˜¯è´Ÿæ•°ï¼Œç›´æ¥è¿”å› `false`å³å¯
- å¦‚æœæ˜¯æ­£æ•°ï¼Œè¿™é‡Œåˆ©ç”¨æ±‚ä½™æ•°çš„æ–¹å¼ï¼Œæ„å»ºä¸€ä¸ªæ–°çš„æ­£æ•°`y`ï¼Œåªéœ€è¦åˆ¤æ–­`x==y`å³å¯çŸ¥é“æ˜¯å¦ä¸ºå›æ–‡æ•°
```go
func isPalindrome(x int) bool {
    // å…¶å®æ˜¯åˆ©ç”¨æ•°å­—æ±‚ä½™æ•°%ï¼Œå¾—åˆ°ä¸€ä¸ªæ•´æ•°dï¼Œç„¶åå¯¹æ•´æ•°å†æ‹¼æ¥æˆy = y * 10 +dï¼ˆä¸€å¼€å§‹y=0),æœ€åå¾—åˆ°çš„æ•°å€¼æ˜¯å¦å’Œxä¸€æ ·ï¼›
    if x < 0 { // å› ä¸ºä¸‹é¢çš„è®¡ç®—è§„åˆ™ï¼Œè´Ÿæ•°ä¹Ÿæ˜¯æ»¡è¶³çš„ï¼›æ‰€ä»¥å¯¹è´Ÿæ•°é¢å¤–å¤„ç†ï¼Œ
        return false
    }
    temp := x //è¡¨ç¤ºå¯¹xæ±‚ä½™ä»¥åï¼Œå‰©ä¸‹çš„æ•´æ•°
    y := 0

    for temp != 0 { // å¦‚æœxæ˜¯0çš„è¯ï¼Œç›´æ¥ä¸ç”¨æ‰§è¡Œè¿™é‡Œ
        y = y*10 + temp%10 // æ„å»ºæ–°çš„æ•´æ•°y
        temp = temp/10
    }
    // æœ€ååˆ¤æ–­ç”Ÿæˆçš„yçš„æ•°å€¼ï¼Œæ˜¯ä¸æ˜¯å’Œxä¸€æ ·ï¼Œå› ä¸ºå›æ–‡æ•°å­—ï¼Œæ­£åè¯»æ˜¯ä¸€æ ·çš„ï¼›
    return x == y
}
```
## 384. æ‰“ä¹±æ•°ç»„
ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums` ï¼Œè®¾è®¡ç®—æ³•æ¥æ‰“ä¹±ä¸€ä¸ªæ²¡æœ‰é‡å¤å…ƒç´ çš„æ•°ç»„ã€‚æ‰“ä¹±åï¼Œæ•°ç»„çš„æ‰€æœ‰æ’åˆ—åº”è¯¥æ˜¯ **ç­‰å¯èƒ½** çš„ã€‚
å®ç° `Solution` class:

- `Solution(int[] nums)` ä½¿ç”¨æ•´æ•°æ•°ç»„ `nums` åˆå§‹åŒ–å¯¹è±¡
- `int[] reset()` é‡è®¾æ•°ç»„åˆ°å®ƒçš„åˆå§‹çŠ¶æ€å¹¶è¿”å›
- `int[] shuffle()` è¿”å›æ•°ç»„éšæœºæ‰“ä¹±åçš„ç»“æœæ€è·¯ï¼š
æœ¬é¢˜åˆ©ç”¨æ´—ç‰Œç®—æ³•æ¥æ‰“ä¹±æ•°ç»„ã€‚
ä¸ºäº†è®©æ•°ç»„è¶³å¤Ÿçš„ä¹±ï¼Œæˆ‘ä»¬çŸ¥é“ä¸€ä¸ªé•¿åº¦ä¸º`n`çš„æ•°ç»„å¦‚æœé‡æ–°æ’åˆ—ï¼Œæœ‰`n!`ç§æ’åˆ—æ–¹æ³•ï¼Œæ‰€ä»¥ï¼Œè®¾è®¡çš„ç®—æ³•ï¼Œéœ€è¦è®©æ’åˆ—çš„ç»“æœèƒ½å¤Ÿæ»¡è¶³`n!`ã€‚
æ¯”å¦‚:
ç¬¬ä¸€ä¸ªæ•°å€¼ï¼Œæˆ‘ä»¬å¯ä»¥ä» `n`ä¸ªä½ç½®ç§é€‰æ‹©ä¸€ä¸ªå­˜æ”¾ï¼›
ç¬¬äºŒä¸ªæ•°å€¼ï¼Œæˆ‘ä»¬å¯ä»¥ä» `n-1`ä¸ªä½ç½®ç§é€‰æ‹©ä¸€ä¸ªå­˜æ”¾ï¼›
ç¬¬ä¸‰ä¸ªæ•°å€¼ï¼Œæˆ‘ä»¬å¯ä»¥ä» `n-2`ä¸ªä½ç½®ç§é€‰æ‹©ä¸€ä¸ªå­˜æ”¾ï¼›
ä»¥æ­¤ç±»æ¨ï¼Œé‚£å°±æ˜¯ `n * n-1 * n-2 ..... * 1 = n!`
ä»£ç å®ç°å¦‚ä¸‹ï¼š

```go
// æ´—ç‰Œç®—æ³•ï¼šæ‰“ä¹±çš„æœ¬è´¨ï¼›ä¹Ÿå°±æœ‰å¤šå°‘ç§æ’åˆ—çš„å¯èƒ½ï¼Œn!ï¼ˆnè¡¨ç¤ºæ•°ç»„çš„é•¿åº¦ï¼‰

type Solution struct {
    nums []int
}


func Constructor(nums []int) Solution {
    return Solution{nums}
}


func (this *Solution) Reset() []int { // è¿™ä¸ªè¿”å›åŸå§‹çš„æ•°ç»„
    return this.nums
}   


func (this *Solution) Shuffle() []int {
		// å¤åˆ¶ä¸€ä¸ª temp
    temp := make([]int,len(this.nums))
    copy(temp,this.nums)


    for i := 0;i < len(temp);i++ { // å­—ç¬¦é€‰ä¸­iï¼Œéšæœºçš„ç´¢å¼•èŒƒå›´ä»[i,n-1]ä¹‹é—´é€‰æ‹©ï¼šä¾‹å¦‚i= 0,éšæœºç´¢å¼•[0,n-1]ä¹Ÿå°±æ˜¯nç§é€‰æ‹©ï¼Œå½“i=1çš„æ—¶å€™ï¼Œéšæœºç´¢å¼•[1,n-1]ä¹Ÿå°±æ˜¯n-1ç§é€‰æ‹©ï¼Œä»¥æ­¤ç±»æ¨
        randIdx := rand.Intn(len(temp)-i)+i// å‡½æ•°rand.Intn è¿”å›[0,len(temp)-i)ä¹‹é—´çš„éšæœºæ•°ï¼Œéšç€içš„å¢å¤§ï¼Œéšæœºçš„èŒƒå›´åœ¨ç¼©å°ï¼›+içš„ç›®çš„æ˜¯è®©éšæœºçš„ç´¢å¼•èŒƒå›´>=iï¼ˆä¸»è¦æ˜¯è¿™ä¸ªå‡½æ•°çš„ç‰¹æ€§å†³å®šè¿™æ ·çš„ä»£ç å†™æ³•)
        temp[i],temp[randIdx] = temp[randIdx],temp[i] // äº¤æ¢å…ƒç´ 
    }
    return temp
}
```
## 96. ä¸åŒçš„äºŒå‰æœç´¢æ ‘
ç»™ä½ ä¸€ä¸ªæ•´æ•° `n` ï¼Œæ±‚æ°ç”± `n` ä¸ªèŠ‚ç‚¹ç»„æˆä¸”èŠ‚ç‚¹å€¼ä» `1` åˆ° `n` äº’ä¸ç›¸åŒçš„ **äºŒå‰æœç´¢æ ‘** æœ‰å¤šå°‘ç§ï¼Ÿè¿”å›æ»¡è¶³é¢˜æ„çš„äºŒå‰æœç´¢æ ‘çš„ç§æ•°ã€‚
æ€è·¯ï¼š
å‡è®¾ç»™ç®—æ³•è¾“å…¥ `n = 5`ï¼Œä¹Ÿå°±æ˜¯è¯´ç”¨ `{1,2,3,4,5}` è¿™äº›æ•°å­—å»æ„é€  `BST`
å¦‚æœå›ºå®š `3` ä½œä¸ºæ ¹èŠ‚ç‚¹ï¼Œå·¦å­æ ‘èŠ‚ç‚¹å°±æ˜¯ `{1,2}` çš„ç»„åˆï¼Œå³å­æ ‘å°±æ˜¯ `{4,5}` çš„ç»„åˆï¼š
![é™„ä»¶ä¸‹è½½å¤±è´¥](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/)

é‚£ä¹ˆ `{1,2}` å’Œ `{4,5}` çš„ç»„åˆæœ‰å¤šå°‘ç§å‘¢ï¼Ÿ
æ‰€ä»¥ï¼Œåªéœ€è¦å®šä¹‰`dp[i][j]`è¡¨ç¤º `[i,j]` èŒƒå›´çš„æ•°å€¼ç»„æˆäºŒå‰æœç´¢æ ‘çš„ç§æ•°ã€‚
é‚£ä¹ˆ`{1,2}`è¡¨ç¤ºä¸º`dp[1][2]`(ç”±ä¸Šå›¾å¯çŸ¥ï¼Œæœ‰`2`ç§)
é‚£ä¹ˆ`{4,5}`è¡¨ç¤ºä¸º`dp[4][5]`(ç”±ä¸Šå›¾å¯çŸ¥ï¼Œæœ‰`2`ç§)
æ‰€ä»¥ï¼Œå›ºå®š `3` ä½œä¸ºæ ¹èŠ‚ç‚¹ï¼Œæ‹¿å¾—åˆ°çš„ç»„åˆä¸º`dp[1][2] * dp[4][5] = 2* 2 = 4`ç§
ä¸€èˆ¬çš„é€’æ¨é€»è¾‘ä¸ºï¼š
`dp[i][j] +=` å¯¹èŒƒå›´`[i,j`]çš„æ¯ä¸ªå…ƒç´ éƒ½å›ºå®šä¸€æ¬¡ä½œä¸ºæ ¹èŠ‚ç‚¹`mid` ï¼ˆé‚£ä¹ˆï¼Œå¯¹åº”çš„ç»„åˆæ•°ä¸º `dp[i][mid-1] * dp[mid+1][j]`)
ç‰¹æ®Šæƒ…å†µï¼šå½“ ` i >= j`å¯ä»¥çœ‹ä½œåªèƒ½ç»„æˆä¸€æ£µ`nil`æ ‘æˆ–è€…åªåŒ…å«ä¸€ä¸ªèŠ‚ç‚¹çš„æ ‘ï¼Œå³`dp[i][j] = 1`
ä»£ç å¦‚ä¸‹ï¼š

```go
func numTrees(n int) int {
    // dp[i][j] è¡¨ç¤º [i,j] èŒƒå›´çš„æ•°å€¼ï¼Œç»„æˆäºŒå‰æœç´¢æ ‘çš„ç§æ•°ï¼›
  
    // if i >= j dp[i][j] = 1
  
    // è½¬ç§»æ–¹ç¨‹ï¼š dp[i][j] += ã€  å¯¹äºèŒƒå›´[i,j]æ¯æ¬¡å›ºå®šä¸€ä¸ªæ•°å­—mid    dp[i][mid-1] * dp[mid+1][j]  ã€‘
    // return dp[1][n] 


  	// å®šä¹‰äºŒç»´dpæ•°ç»„
    dp := make([][]int,n+1)
    for i := 0;i < n+1;i++ {
        dp[i] = make([]int,n+1)
    }

    for i := 0;i < n+1;i++ {
        for j := i;j >= 0;j-- { // i>=jçš„ èŒƒå›´é»˜è®¤éƒ½æ˜¯ 1ï¼ˆä¹Ÿå°±æ˜¯åªèƒ½ç»„æˆä¸€ä¸ª nilæ ‘ or åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹çš„æ ‘ï¼‰
            dp[i][j] = 1
        }
    }

    // è¿™é‡Œæ˜¯ i < j çš„å…³ç³»
    for i := n;i >= 0;i-- {  // è¿™é‡Œä¸ºä»€ä¹ˆiè¦å…ˆä»nå¼€å§‹ï¼Œè€Œä¸æ˜¯iå…ˆä»0å¼€å§‹ï¼Ÿï¼Ÿè¿™éœ€è¦ä½ çœ‹ä¸‹é€’æ¨å‡½æ•°ï¼Œè¦æƒ³æ±‚dp[i][j],éœ€è¦å…ˆçŸ¥é“ dp[i][mid-1] å’Œ dp[mid+1][j]çš„å€¼æ˜¯å§ï¼Œå…¶ä¸­ç´¢å¼• mid+1 çš„å€¼æ˜¯å¤§äºiçš„å€¼ï¼Œä¹Ÿå°±æ˜¯æˆ‘ä»¬éœ€è¦å…ˆçŸ¥é“æ¯”iå¤§çš„ï¼Œæ‰èƒ½çŸ¥é“ içš„å€¼ï¼Œæ‰€ä»¥éœ€è¦iä»nå¼€å§‹ï¼ˆä¹Ÿå°±æ˜¯ä»å¤§æ•°å¼€å§‹ï¼‰ï¼›åŒç†ï¼Œjä»å°æ•°å¼€å§‹ï¼Œå› ä¸ºéœ€è¦å…ˆçŸ¥é“ mid-1çš„å€¼ï¼Œæ‰èƒ½æ±‚j ï¼Œã€è¿™ä¸ªç»†èŠ‚ä¸€èˆ¬ä¸å®¹æ˜“æ³¨æ„åˆ°ï¼Œå› ä¸ºä¹‹å‰çš„å¾ˆå¤š dpæ•°ç»„éƒ½æ˜¯ç”±å°çš„ç´¢å¼•ï¼Œæ¥æ¨å¯¼å¤§çš„ç´¢å¼•ã€‚æ‰€ä»¥ï¼Œéƒ½æ˜¯ä» 0å¼€å§‹ã€‘
        for j := i+1;j < n+1;j++ {
            
            // ç›¸å½“äºä» ã€i,jã€‘ èŒƒå›´ä¸­æ¯æ¬¡æ‰¾ä¸€ä¸ªç‚¹midä½œä¸ºæ ¹èŠ‚ç‚¹
            for mid := i; mid <=j;mid++ {

                left,right := 1,1
                if mid-1 >= 0 {
                    left = dp[i][mid-1]
                }
                if mid+1 <=n {
                    right = dp[mid+1][j]
                }
                dp[i][j] += left * right // é€‰ä¸­æŸä¸ªmidä½œä¸ºæ ¹ï¼Œå¾—åˆ°çš„bstçš„ç»„åˆæ•°
            }
        }
    }
  	// æœ€ç»ˆè¦æ±‚çš„ [1,n]çš„ç»„åˆæ•°
    return dp[1][n]
}
```
## 120. ä¸‰è§’å½¢æœ€å°è·¯å¾„å’Œ
ç»™å®šä¸€ä¸ªä¸‰è§’å½¢ `triangle` ï¼Œæ‰¾å‡ºè‡ªé¡¶å‘ä¸‹çš„æœ€å°è·¯å¾„å’Œã€‚
æ¯ä¸€æ­¥åªèƒ½ç§»åŠ¨åˆ°ä¸‹ä¸€è¡Œä¸­ç›¸é‚»çš„ç»“ç‚¹ä¸Šã€‚**ç›¸é‚»çš„ç»“ç‚¹** åœ¨è¿™é‡ŒæŒ‡çš„æ˜¯ **ä¸‹æ ‡** ä¸ **ä¸Šä¸€å±‚ç»“ç‚¹ä¸‹æ ‡** ç›¸åŒæˆ–è€…ç­‰äº **ä¸Šä¸€å±‚ç»“ç‚¹ä¸‹æ ‡ + 1** çš„ä¸¤ä¸ªç»“ç‚¹ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœæ­£ä½äºå½“å‰è¡Œçš„ä¸‹æ ‡ `i` ï¼Œé‚£ä¹ˆä¸‹ä¸€æ­¥å¯ä»¥ç§»åŠ¨åˆ°ä¸‹ä¸€è¡Œçš„ä¸‹æ ‡ `i` æˆ– `i + 1` ã€‚
**ç¤ºä¾‹ 1ï¼š**

```go
è¾“å…¥ï¼štriangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
è¾“å‡ºï¼š11
è§£é‡Šï¼šå¦‚ä¸‹é¢ç®€å›¾æ‰€ç¤ºï¼š
   2
  3 4
 6 5 7
4 1 8 3
è‡ªé¡¶å‘ä¸‹çš„æœ€å°è·¯å¾„å’Œä¸º 11ï¼ˆå³ï¼Œ2 + 3 + 5 + 1 = 11ï¼‰ã€‚
```
ä»£ç å¦‚ä¸‹ï¼š

```go
// è§£æ³•ä¸€ï¼š
func minimumTotal1(triangle [][]int) int {
    // åŠ¨æ€è§„åˆ’ï¼š dp[i][j] å®šä¹‰ï¼Œåˆ°è¾¾ä½ç½®iå’Œjçš„æœ€å°è·¯å¾„å’Œä¸º dp[i][j]

    // å¦‚ä½•åˆ°è¾¾ï¼šæ¥æºäºä¸Šä¸€è¡Œi-1 ã€åŒä¸€åˆ—j æˆ– å‰ä¸€åˆ—j-1ã€‘ å³ï¼Œdp[i][j] = min(dp[i-1][j],dp[i-1][j-1]) + triangle[i][j]

    // æœ€ç»ˆçš„ç»“æœæ˜¯æœ€åä¸€è¡Œçš„æŸä¸€åˆ— dp[n-1][...]

    // base case : dp[0][0] = triangle[0][0]

    // è¿™é‡Œåˆå§‹åŒ–è¦å¯¹æ•´ä¸ªäºŒä½æ•°ç»„åˆå§‹åŒ–ä¸º math.MaxIntï¼ˆå› ä¸ºæ±‚æœ€å°å€¼ï¼Œåˆå§‹å€¼è®¾å®šä¸ºæœ€å¤§å€¼ï¼‰
    n := len(triangle)
    dp := make([][]int,n) // n è¡Œ
    for i := 0;i < n;i++ {
        dp[i] = make([]int,n) // nåˆ—ï¼Œé¢˜ç›®æç¤ºè¯´äº†ï¼Œæ¯ä¸€è¡Œé•¿åº¦æ˜¯ä¸Šä¸€è¡Œé•¿åº¦+1ï¼Œæ‰€ä»¥æœ€å¤§åˆ—æ•°å’Œè¡Œæ•°å…¶å®æ˜¯ä¸€æ ·çš„
        for j := 0;j < n;j++ {
            dp[i][j] = math.MaxInt // åˆå§‹åŒ–ä¸ºæœ€å¤§å€¼
        }
    }   
    // base case ç¬¬ä¸€è¡Œåªæœ‰ä¸€ä¸ªå…ƒç´ 
    dp[0][0] = triangle[0][0]

    for i := 1;i < n;i++ { // ä»ç¬¬äºŒè¡Œå¼€å§‹
      	column := triangle[i] // æ³¨æ„å¾ˆé‡è¦(è¯¥è¡Œæœ‰columnåˆ—)
        for j := 0; j < len(column);j++ { // 
            if j == 0 {
                 // j == 0 è¯´æ˜æ˜¯è¾¹ä¸Šï¼Œåªèƒ½æ­£ä¸Šæ–¹å¯ä»¥åˆ°è¾¾å½“å‰ä½ç½®
                dp[i][j] = dp[i-1][j] + triangle[i][j]
            } else {
                dp[i][j] = min(dp[i-1][j-1],dp[i-1][j]) + triangle[i][j]
            }
        }
    }

    result := math.MaxInt
  	// æœ€å:åœ¨æœ€åä¸€è¡Œæ‰¾åˆ°-æœ€å°å€¼
    for j := 0; j < n;j++ {
        result = min(dp[n-1][j],result)
    }

    return result
}

func min ( a,b int) int {
    if a < b {
        return a
    }

    return b
}


// è¿›é˜¶è§£æ³•äºŒï¼ˆå…ˆçœ‹è§£æ³•ä¸€ï¼Œå†çœ‹è§£æ³•äºŒå®¹æ˜“ç†è§£ç‚¹ï¼‰
func minimumTotal(triangle [][]int) int {

    n := len(triangle)
  
		// è¿™é‡Œåªå®šä¹‰ä¸€ç»´æ•°ç»„
    arr := make([]int,n)
    for i := range arr {
        arr[i] = math.MaxInt
    }

  	// ç¬¬ä¸€ä¸ªå…ƒç´ å€¼ä¸º triangle[0][0]
    arr[0] = triangle[0][0]

    for i := 1; i < n;i++ { // ä»ç¬¬äºŒè¡Œå¼€å§‹
        column := triangle[i]

     	 for j := len(column)-1;j >= 0;j-- { // å€’åº(æ³¨æ„è¿™é‡Œçš„åŒºåˆ«ï¼Œå› ä¸ºæ˜¯ä¸€ç»´æ•°æ®ï¼Œéœ€è¦å…ˆæ±‚åé¢çš„ï¼Œé¿å…å‰é¢çš„è¢«æå‰è¦†ç›–)

            if j == 0 {
                arr[j] = triangle[i][j] + arr[j]
            } else {
                arr[j] = triangle[i][j] + min(arr[j],arr[j-1]) 
            }
        }
    }
		
  	// åœ¨ä¸€ç»´æ•°ç»„ä¸­ï¼Œæ‰¾åˆ°æœ€å°å€¼
    res := math.MaxInt
    for _,v := range arr {
        res = min(res,v)
    }
    return res
}
```
## 210. è¯¾ç¨‹è¡¨ II
ç°åœ¨ä½ æ€»å…±æœ‰ `numCourses` é—¨è¯¾éœ€è¦é€‰ï¼Œè®°ä¸º `0` åˆ° `numCourses - 1`ã€‚ç»™ä½ ä¸€ä¸ªæ•°ç»„ `prerequisites` ï¼Œå…¶ä¸­ `prerequisites[i] = [ai, bi]` ï¼Œè¡¨ç¤ºåœ¨é€‰ä¿®è¯¾ç¨‹ `ai` å‰ **å¿…é¡»** å…ˆé€‰ä¿® `bi` ã€‚

- ä¾‹å¦‚ï¼Œæƒ³è¦å­¦ä¹ è¯¾ç¨‹ `0` ï¼Œä½ éœ€è¦å…ˆå®Œæˆè¯¾ç¨‹ `1` ï¼Œæˆ‘ä»¬ç”¨ä¸€ä¸ªåŒ¹é…æ¥è¡¨ç¤ºï¼š`[0,1]` ã€‚è¿”å›ä½ ä¸ºäº†å­¦å®Œæ‰€æœ‰è¯¾ç¨‹æ‰€å®‰æ’çš„å­¦ä¹ é¡ºåºã€‚å¯èƒ½ä¼šæœ‰å¤šä¸ªæ­£ç¡®çš„é¡ºåºï¼Œä½ åªè¦è¿”å› **ä»»æ„ä¸€ç§** å°±å¯ä»¥äº†ã€‚å¦‚æœä¸å¯èƒ½å®Œæˆæ‰€æœ‰è¯¾ç¨‹ï¼Œè¿”å› **ä¸€ä¸ªç©ºæ•°ç»„** ã€‚
æ€è·¯ï¼š
**207. è¯¾ç¨‹è¡¨**é¢˜è§£ï¼Œè¿™ä¸¤é¢˜åŸºæœ¬å°±æ˜¯ä¸€æ ·çš„é¢˜ç›®ï¼Œåªæ˜¯å¤šäº†ä¸€ä¸ªè¿”å›è¯¾ç¨‹çš„è¿‡ç¨‹ã€‚
ç›´è§‚åœ°è¯´ï¼Œæ‹“æ‰‘æ’åºå°±æ˜¯è®©ä½ æŠŠä¸€å¹…æ— ç¯å›¾ã€Œæ‹‰å¹³ã€ï¼Œè€Œä¸”è¿™ä¸ªã€Œæ‹‰å¹³ã€çš„å›¾é‡Œé¢ï¼Œæ‰€æœ‰ç®­å¤´æ–¹å‘éƒ½æ˜¯ä¸€è‡´çš„ï¼š
![é™„ä»¶ä¸‹è½½å¤±è´¥](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/)

åœ¨è¿›è¡Œæ‹“æ‰‘æ’åºä¹‹å‰ï¼Œé¦–å…ˆè¦ç¡®ä¿å›¾ä¸­æ— ç¯ï¼Œè¿™å°±ä¾èµ–ä¸­è®²çš„**207. è¯¾ç¨‹è¡¨**ç¯æ£€æµ‹ç®—æ³•ã€‚
è¿™é‡Œå¯¹æ¯”è¾ƒéš¾ç†è§£çš„`onPath`å›¾ç¤ºè¯´æ˜ï¼š
æ¯”å¦‚ è¯¾ç¨‹1ä¾èµ–è¯¾ç¨‹2 è¯¾ç¨‹3ï¼Œè¯¾ç¨‹3åˆä¾èµ–è¯¾ç¨‹1ï¼Œè¿™æ ·å°±å½¢æˆäº†å¾ªç¯ä¾èµ–çš„å…³ç³»ã€‚è¯¾ç¨‹æ˜¯æ— æ³•å®Œæˆå­¦ä¹ çš„ã€‚
é€šè¿‡ä¸‹å›¾å¯ä»¥ç†è§£ `onPath`å˜é‡çš„æ„ä¹‰ï¼Œä»¥åŠæ•´ä¸ªæ£€æµ‹çš„å¯è§†åŒ–è¿‡ç¨‹ã€‚å»ºè®®è¾¹çœ‹ä»£ç è¾¹çœ‹å›¾ç†è§£
![é™„ä»¶ä¸‹è½½å¤±è´¥](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/)

![é™„ä»¶ä¸‹è½½å¤±è´¥](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/)

![é™„ä»¶ä¸‹è½½å¤±è´¥](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/)

![é™„ä»¶ä¸‹è½½å¤±è´¥](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/)


```go
var postOrder []int // è¯¾ç¨‹çš„å­¦ä¹ é¡ºåºåˆ—è¡¨
var isCircle bool // æ˜¯å¦æœ‰ç¯æ ‡å¿—
var visited []bool // è¡¨ç¤ºèŠ‚ç‚¹æ˜¯å¦å·²ç»è®¿é—®è¿‡,è¿™ä¸ªæ˜¯ä¸ºäº†å‰ªæ
var onPath []bool  // èŠ‚ç‚¹æ­£åœ¨è¢«å ç”¨ä¸­ï¼ˆè®¿é—®ä¸­ï¼‰ï¼Œè¿™ä¸ªæ˜¯ä¸ºäº†ï¼Œè®°å½•ä¸‹è®¿é—®è·¯å¾„æœ‰æ²¡æœ‰é‡å 
func findOrder(numCourses int, prerequisites [][]int) []int {
		
    visited = make([]bool,numCourses)
    onPath = make([]bool,numCourses)
    postOrder = []int{}
    isCircle = false
  
    //1.å…ˆæ„å»ºæœ‰å‘å›¾ï¼ˆç”¨ä¸´æ¥è¡¨çš„æ–¹å¼ï¼Œå…¶å®å°±æ˜¯äºŒç»´æ•°ç»„ï¼‰
    graph := make([][]int,numCourses) // æ€»å…±æœ‰numCoursesä¸ªè¯¾ç¨‹ï¼Œgraphçš„ç›®çš„æ˜¯è®°å½•æ¯ä¸ªè¯¾ç¨‹ï¼ˆä¾èµ–çš„å­è¯¾ç¨‹ï¼‰


    // è¡¨ç¤º prerequisites[i][0] ä¾èµ–äº -> prerequisites[i][1]
    for i := 0;i < len(prerequisites);i++ {
        graph[prerequisites[i][0]] = append(graph[prerequisites[i][0]],prerequisites[i][1])
    }

    // 2.éå†æœ‰å‘å›¾ï¼›ä¹Ÿå°±æ˜¯ä»¥æ¯ä¸ªè¯¾ç¨‹å‡ºå‘ï¼Œç„¶åéå†å’Œå®ƒå…³è”çš„æ‰€æœ‰çš„å­è¯¾ç¨‹ï¼ˆç›®çš„ï¼šçœ‹è¯¾ç¨‹æ˜¯å¦å­˜åœ¨å¼ºåˆ¶å¾ªç¯ä¾èµ–å…³ç³»ï¼‰
    for i := 0; i < numCourses;i++ { 
        dfs(graph,i) // i è¡¨ç¤ºè¯¾ç¨‹
    }
    if isCircle {
        return []int{}
    }
    
    return postOrder
}

func dfs(graph [][]int,i int) {

    // åˆ¤æ–­è¯¾ç¨‹i æ­£åœ¨è¢«å ç”¨
    if onPath[i] {
        isCircle = true
    }

    if visited[i] || isCircle { // èŠ‚ç‚¹å·²ç»è®¿é—®è¿‡ï¼Œæˆ–è€…å·²ç»å­˜åœ¨ç¯ï¼Œæ²¡å¿…è¦ç»§ç»­ä¸‹å»äº†ï¼Œå°½å¿«ç»“æŸ
        return
    }

    visited[i] = true
    onPath[i] = true // æ ‡è®°ï¼šæ­£åœ¨è®¿é—®
    
    // å…ˆå›ºå®šiè¯¾ç¨‹ï¼Œç„¶åçœ‹iä¸‹é¢ä¾èµ–çš„æ‰€æœ‰å­è¯¾ç¨‹ï¼ˆå¦‚æœå­è¯¾ç¨‹åœ¨dfséå†çš„æ—¶å€™ï¼Œå‘ç°ä¼šè®¿é—®åˆ°å·²ç»è¢«å ç”¨çš„è¯¾ç¨‹ï¼Œè¯´æ˜æœ‰ç¯ï¼‰
    for j := 0;j < len(graph[i]);j++ { // iä¸‹é¢çš„æ‰€æœ‰å­è¯¾ç¨‹
        dfs(graph,graph[i][j]) // graph[i][j] è¡¨ç¤ºå­è¯¾ç¨‹
    }   
    
    // å› ä¸º i ä¾èµ–äº graph[i]ä¸­çš„å­è¯¾ç¨‹å…ˆå­¦ä¹ ï¼Œ æ‰€ä»¥æ”¾ç½®åˆ°åç»­éå†ä½ç½®è®°å½•æœ€ç»ˆç»“æœ
    postOrder = append(postOrder,i) 

    onPath[i] = false // æ ‡è®°ï¼šå–æ¶ˆè®¿é—®
}
```
## 213. æ‰“å®¶åŠ«èˆ II
ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„å°å·ï¼Œè®¡åˆ’å·çªƒæ²¿è¡—çš„æˆ¿å±‹ï¼Œæ¯é—´æˆ¿å†…éƒ½è—æœ‰ä¸€å®šçš„ç°é‡‘ã€‚è¿™ä¸ªåœ°æ–¹æ‰€æœ‰çš„æˆ¿å±‹éƒ½ **å›´æˆä¸€åœˆ** ï¼Œè¿™æ„å‘³ç€ç¬¬ä¸€ä¸ªæˆ¿å±‹å’Œæœ€åä¸€ä¸ªæˆ¿å±‹æ˜¯ç´§æŒ¨ç€çš„ã€‚åŒæ—¶ï¼Œç›¸é‚»çš„æˆ¿å±‹è£…æœ‰ç›¸äº’è¿é€šçš„é˜²ç›—ç³»ç»Ÿï¼Œ**å¦‚æœä¸¤é—´ç›¸é‚»çš„æˆ¿å±‹åœ¨åŒä¸€æ™šä¸Šè¢«å°å·é—¯å…¥ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨æŠ¥è­¦** ã€‚
ç»™å®šä¸€ä¸ªä»£è¡¨æ¯ä¸ªæˆ¿å±‹å­˜æ”¾é‡‘é¢çš„éè´Ÿæ•´æ•°æ•°ç»„ï¼Œè®¡ç®—ä½  **åœ¨ä¸è§¦åŠ¨è­¦æŠ¥è£…ç½®çš„æƒ…å†µä¸‹** ï¼Œä»Šæ™šèƒ½å¤Ÿå·çªƒåˆ°çš„æœ€é«˜é‡‘é¢ã€‚
æ€è·¯ï¼š
æœ¬é¢˜æ˜¯**198. æ‰“å®¶åŠ«èˆ**çš„è¿›é˜¶ç‰ˆã€‚
æ–¹æ¡ˆ1.å¦‚æœã€å·ã€‘ç¬¬ä¸€ä¸ª`0`æˆ¿é—´ï¼Œé‚£ä¹ˆ`nums[1]`å’Œ`nums[n-1]`éƒ½ä¸èƒ½å·ï¼Œé‚£å°±åªèƒ½å· `[2,n-2]`èŒƒå›´çš„é—­åˆåŒºé—´,å¯ä»¥å·çªƒï¼›
æ–¹æ¡ˆ2.å¦‚æœã€ä¸å·ã€‘ç¬¬ä¸€ä¸ªæˆ¿é—´ï¼Œé‚£ä¹ˆå¯ä»¥å·å–çš„èŒƒå›´`[1,n-1]`
ä¸Šé¢ä¸¤ç§æ–¹æ¡ˆæœ‰ä¸ªå…±åŒç‚¹ï¼Œéƒ½éœ€è¦æˆ‘ä»¬å®ç°ä¸€ä¸ªå·å–`[i,j]`èŒƒå›´å†…æˆ¿å­çš„å‡½æ•°ã€‚è¿™ä¸ªæ­£å¥½å°±æ˜¯**198. æ‰“å®¶åŠ«èˆ**å®ç°çš„å‡½æ•°ã€‚

```go
func rob(nums []int) int {
    
    n := len(nums)
    if n == 1 { // åªæœ‰ä¸€ä¸ªæˆ¿å±‹ï¼Œç›´æ¥å·
        return nums[0]
    }

    if n == 2 { 
        return max(nums[0],nums[1])/ / åªæœ‰ä¸¤ä¸ªæˆ¿å±‹,é€‰æœ€å¤§çš„å·
    }
		// nums[0]+ rob1(nums[2:n-1])  å¯¹åº”æ–¹æ¡ˆ1
  	// rob1(nums[1:n]) å¯¹åº”æ–¹æ¡ˆ2
    return max(nums[0]+ rob1(nums[2:n-1]),rob1(nums[1:n])) // æ³¨æ„Goåˆ‡ç‰‡æœ€åä¸€ä¸ªä½ç½®è¦+1ï¼ˆè¯­è¨€ç‰¹æ€§å†³å®šçš„ï¼‰
}

// ä» nums ä¸­èƒ½å·çªƒçš„æœ€å¤§å€¼
func rob1(nums []int) int {

    if len(nums) == 0 {
        return 0
    }
    // å®šä¹‰ï¼šdp[x] è¡¨ç¤ºä»0åˆ°xèƒ½å·çªƒçš„æœ€é«˜é‡‘é¢
    // é€’æ¨å‡½æ•°ï¼šdp[x] = max(dp[x-1],nums[x]+ dp[x-2])  
  	// å½“å‰xä¸å·çªƒï¼Œé‚£å°±æ˜¯dp[x-1]çš„æœ€é«˜é‡‘é¢ç­‰äºdp[x]
    // å½“å‰xå·çªƒï¼Œé‚£ nums[x] + dp[x-2]çš„æœ€é«˜é‡‘é¢
		
  	// æ„å»ºdpæ•°ç»„
    dp := make([]int ,len(nums))
  	// base case
    dp[0] = nums[0]
    if len(nums) > 1 {
        dp[1] = max(nums[0],nums[1]) 
    }

    for i := 2; i < len(nums);i++ {
        dp[i] = max(dp[i-1],nums[i]+ dp[i-2])
    }
  	// è¡¨ç¤ºä» 0 åˆ° len(nums)-1èƒ½å·çªƒçš„æœ€å¤§å€¼
    return dp[len(nums)-1]
}

func max(a,b int) int{
    if a > b {
        return a
    }
    return b
}
```
## 516. æœ€é•¿å›æ–‡å­åºåˆ—
ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² `s` ï¼Œæ‰¾å‡ºå…¶ä¸­æœ€é•¿çš„å›æ–‡å­åºåˆ—ï¼Œå¹¶è¿”å›è¯¥åºåˆ—çš„é•¿åº¦ã€‚
å­åºåˆ—å®šä¹‰ä¸ºï¼šä¸æ”¹å˜å‰©ä½™å­—ç¬¦é¡ºåºçš„æƒ…å†µä¸‹ï¼Œåˆ é™¤æŸäº›å­—ç¬¦æˆ–è€…ä¸åˆ é™¤ä»»ä½•å­—ç¬¦å½¢æˆçš„ä¸€ä¸ªåºåˆ—ã€‚
**ç¤ºä¾‹ 1ï¼š**

```go
è¾“å…¥ï¼šs = "bbbab"
è¾“å‡ºï¼š4
è§£é‡Šï¼šä¸€ä¸ªå¯èƒ½çš„æœ€é•¿å›æ–‡å­åºåˆ—ä¸º "bbbb" ã€‚
```
æ€è·¯ï¼š
é¦–å…ˆå›æ–‡çš„å®šä¹‰å°±æ˜¯ï¼Œæ­£å‘è¯»å’Œåå‘è¯»ï¼Œéƒ½ä¸€æ ·çš„
åŠ¨æ€è§„åˆ’ï¼š
`dp[i][j] `å®šä¹‰ï¼šå­—ç¬¦ä¸² `s[i...j] `çš„æœ€é•¿å›æ–‡å­åºåˆ—é•¿åº¦ `dp[i][j]`
ä¸€èˆ¬é€’æ¨å…³ç³»ï¼š
`s[i] == s[j] dp[i][j] = dp[i+1][j-1] + 2`
`s[i] != s[j] dp[i][j] = max(dp[i+1][j],dp[i][j-1])`
![é™„ä»¶ä¸‹è½½å¤±è´¥](./è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.assert/)

è¿™é¢˜çš„æ³¨æ„ç‚¹åœ¨äºç´¢å¼•`i`çš„éå†æ–¹å‘ï¼ˆä¹Ÿå°±æ˜¯å€’åºæ–¹å¼ï¼‰
ä»¥å‰çš„é¢˜è§£éƒ½æ˜¯æ±‚`i`éœ€è¦å…ˆæ±‚`i-1`ï¼Œæ‰€ä»¥`i`ä»`0`å¼€å§‹éå†ï¼Œå°†å°çš„ä½œä¸ºç»“æœï¼Œæ¥æ¨å¯¼å‡ºå¤§çš„ï¼›
ä½†æ˜¯è¿™é‡Œï¼Œç”±é€’æ¨å…³ç³»å¯çŸ¥` dp[i][..]` çš„å€¼æ˜¯ç”±`dp[i+1][..]`å¾—æ¥çš„ï¼Œæ‰€ä»¥ï¼Œéœ€è¦å…ˆæ¥ç®—å‡º`dp[i+1]`çš„å€¼ï¼Œå†æ¥æ±‚`dp[i]`å› æ­¤`i`è¦å…ˆä»å¤§ç´¢å¼•å€¼å¼€å§‹ï¼Œç„¶ååˆ°å°çš„ï¼›
è€Œ`j`æ°å¥½ç¬¦åˆä¹‹å‰çš„æ­£åºæ–¹å¼ï¼š`dp[..][j]` ç”± `dp[..][j-1]`å¾—æ¥ï¼Œæ‰€ä»¥`j` æ˜¯ç¬¦åˆä»å°å¤§çš„è§„åˆ™ï¼Œæ­£åºå³å¯ã€‚

```go
func longestPalindromeSubseq(s string) int {

    // é¦–å…ˆå›æ–‡çš„å®šä¹‰å°±æ˜¯ï¼Œæ­£å‘è¯»å’Œåå‘è¯»ï¼Œéƒ½ä¸€æ ·çš„ï¼›ä¹Ÿå°±æ˜¯å­—ç¬¦ä¸²çš„é¦–å°¾çš„å­—ç¬¦ç›¸åŒ
    // åŠ¨æ€è§„åˆ’ï¼š dp[i][j] = x :å®šä¹‰ å­—ç¬¦ä¸² s[i...j] çš„æœ€é•¿å›æ–‡å­åºåˆ—é•¿åº¦ dp[i][j]
  
    // s[i] == s[j] dp[i][j] = dp[i+1][j-1] + 2
    // s[i] != s[j] dp[i][j] = max(dp[i+1][j],dp[i][j-1])
    n := len(s)
    dp := make([][]int,n)

    for i := 0;i < n;i++ {
        dp[i] = make([]int,n)
        dp[i][i] = 1 // base case å•ç‹¬çš„å…ƒç´ å°±æ˜¯1ä¸ªå›æ–‡ä¸²
    }

    for i := n-1;i>=0;i-- { 
        for j := i+1;j < n;j++ { // è¿™é‡Œj = i+1,å› ä¸ºå‰é¢j==içš„æƒ…å†µåœ¨base caseä¸­å·²ç»å¤„ç†äº†ï¼ˆè¿™ä¸ªé€’æ¨å…³ç³»åªèƒ½åœ¨i!=jçš„å‰æä¸‹æˆç«‹ï¼‰
            if s[i] == s[j] {
                dp[i][j] = dp[i+1][j-1] + 2 
            } else {
                dp[i][j] = max(dp[i+1][j],dp[i][j-1])
            }
        }
    }


    return dp[0][n-1]
}

func max( a,b int) int{
    if a > b{
        return a
    }
    return b
}
```
## 678. æœ‰æ•ˆçš„æ‹¬å·å­—ç¬¦ä¸²
ç»™ä½ ä¸€ä¸ªåªåŒ…å«ä¸‰ç§å­—ç¬¦çš„å­—ç¬¦ä¸²ï¼Œæ”¯æŒçš„å­—ç¬¦ç±»å‹åˆ†åˆ«æ˜¯ `'('`ã€`')'` å’Œ `'*'`ã€‚è¯·ä½ æ£€éªŒè¿™ä¸ªå­—ç¬¦ä¸²æ˜¯å¦ä¸ºæœ‰æ•ˆå­—ç¬¦ä¸²ï¼Œå¦‚æœæ˜¯ **æœ‰æ•ˆ** å­—ç¬¦ä¸²è¿”å› `true` ã€‚
**æœ‰æ•ˆ** å­—ç¬¦ä¸²ç¬¦åˆå¦‚ä¸‹è§„åˆ™ï¼š

- ä»»ä½•å·¦æ‹¬å· `'('` å¿…é¡»æœ‰ç›¸åº”çš„å³æ‹¬å· `')'`ã€‚
- ä»»ä½•å³æ‹¬å· `')'` å¿…é¡»æœ‰ç›¸åº”çš„å·¦æ‹¬å· `'('` ã€‚
- å·¦æ‹¬å· `'('` å¿…é¡»åœ¨å¯¹åº”çš„å³æ‹¬å·ä¹‹å‰ `')'`ã€‚
- `'*'` å¯ä»¥è¢«è§†ä¸ºå•ä¸ªå³æ‹¬å· `')'` ï¼Œæˆ–å•ä¸ªå·¦æ‹¬å· `'('` ï¼Œæˆ–ä¸€ä¸ªç©ºå­—ç¬¦ä¸² `""`ã€‚æ€è·¯ï¼š
é‡åˆ°æ‹¬å·çš„é—®é¢˜ï¼Œä¸€èˆ¬éƒ½æ˜¯é‡‡ç”¨æ ˆçš„æ–¹å¼è§£å†³

- æœ¬é¢˜ç”¨æ ˆè®°å½•çš„æ˜¯ã€ç´¢å¼•å€¼ã€‘ï¼š`leftStack`è®°å½•å·¦æ‹¬å·ç´¢å¼• `starStack`è®°å½•æ˜Ÿå·ç´¢å¼•
- å½“é‡åˆ° `)`å³æ‹¬å·ï¼ŒæŸ¥æ‰¾ `leftStack starStack`æ ˆï¼ŒåŒ¹é…
- å½“åŒ¹é…ç»“æŸä»¥åï¼Œ`leftStack`å¯èƒ½è¿˜å‰©ä½™å·¦æ‹¬å·ï¼Œéœ€è¦ç”¨å‰©ä½™çš„æ˜Ÿå·å®ŒæˆåŒ¹é…ã€‚ï¼ˆå‰æï¼Œæ˜Ÿå·çš„ç´¢å¼• å¤§äº å·¦æ‹¬å·çš„ç´¢å¼•ï¼‰
```go
func checkValidString(s string) bool {
    ///ï¼ï¼ï¼åˆ©ç”¨æ ˆå®ç°
    leftStack := []int{} // è®°å½•(å·¦æ‹¬å· ç´¢å¼•
    starStack := []int{} // è®°å½•*å· ç´¢å¼•

    for k,v := range s {
        if v == '(' { // é‡åˆ°å·¦æ‹¬å·ï¼Œè®°å½•ç´¢å¼•
            leftStack = append(leftStack,k) 
        } else if v == '*' { // é‡åˆ°*å·ï¼Œè®°å½•ç´¢å¼•
            starStack = append(starStack,k)
        } else { // é‡åˆ° ï¼‰å³æ‹¬å·
          	// å…ˆåŒ¹é… leftStackï¼Œæ¯”å¦‚ï¼š *() æ ¼å¼ï¼Œé‡åˆ° ï¼‰åŒ¹é… ( è€Œä¸æ˜¯åŒ¹é… *
            if len(leftStack) != 0 {
                leftStack = leftStack[:len(leftStack)-1] // å¼¹å‡ºï¼ˆ
            } else if len(starStack) != 0 {
                starStack = starStack[:len(starStack)-1] // å¼¹å‡º *
            } else {
                return false // (å’Œ*éƒ½ä¸å­˜åœ¨ï¼Œè¯´æ˜å³æ‹¬å·æ— æ³•åŒ¹é…
            }
        }
    }
  	
  	//å½“ä¸Šé¢çš„æ‰€æœ‰ã€å³æ‹¬å·ã€‘åŒ¹é…å®Œæˆåï¼Œå¯èƒ½è¿˜ä¼šå‰©ä½™ã€å·¦æ‹¬å·ã€‘ï¼Œæ‰€ä»¥éœ€è¦å¯¹å‰©ä¸‹çš„å·¦æ‹¬å·åšåŒ¹é…ï¼Œæ¯”å¦‚ï¼š(*() æ ¼å¼ï¼Œè¿˜ä¼šå‰©ä¸‹ (*
  
    // ä¸€ä¸ªå·¦æ‹¬å·ï¼Œä¸€å®šè¦æœ‰ä¸ªå¤„äºå…¶ã€å³è¾¹çš„æ˜Ÿå·ã€‘æ¥åŒ¹é…ï¼Œå³ï¼š * çš„ç´¢å¼• > å·¦æ‹¬å·ï¼ˆ çš„ç´¢å¼•
    for len(leftStack) != 0 {

        if len(starStack) == 0 {
            return false
        }

        if starStack[len(starStack)-1] < leftStack[len(leftStack)-1] { // (*  å³ï¼š *çš„ç´¢å¼•ï¼Œéœ€è¦å¤§äºï¼ˆçš„ç´¢å¼• 
            return false
        }
      
        leftStack = leftStack[:len(leftStack)-1]
        starStack = starStack[:len(starStack)-1]
    }

    return true
}
```
## 44. é€šé…ç¬¦åŒ¹é…
ç»™ä½ ä¸€ä¸ªè¾“å…¥å­—ç¬¦ä¸² (`s`) å’Œä¸€ä¸ªå­—ç¬¦æ¨¡å¼ (`p`) ï¼Œè¯·ä½ å®ç°ä¸€ä¸ªæ”¯æŒ `'?'` å’Œ `'*'` åŒ¹é…è§„åˆ™çš„é€šé…ç¬¦åŒ¹é…ï¼š

- `'?'` å¯ä»¥åŒ¹é…ä»»ä½•å•ä¸ªå­—ç¬¦ã€‚
- `'*'` å¯ä»¥åŒ¹é…ä»»æ„å­—ç¬¦åºåˆ—ï¼ˆåŒ…æ‹¬ç©ºå­—ç¬¦åºåˆ—ï¼‰ã€‚åˆ¤å®šåŒ¹é…æˆåŠŸçš„å……è¦æ¡ä»¶æ˜¯ï¼šå­—ç¬¦æ¨¡å¼å¿…é¡»èƒ½å¤Ÿ **å®Œå…¨åŒ¹é…** è¾“å…¥å­—ç¬¦ä¸²ï¼ˆè€Œä¸æ˜¯éƒ¨åˆ†åŒ¹é…ï¼‰ã€‚
æ€è·¯ï¼š
æœ¬é¢˜å’Œ **10. æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…**æœ‰ç±»ä¼¼ä¹‹å¤„ï¼Œä½†æ˜¯æ›´ç®€å•ã€‚
å®šä¹‰ï¼š`dp[i][j]`è¡¨ç¤º é•¿åº¦` i` çš„å­—ç¬¦ä¸² `s` æ˜¯å¦å’Œ é•¿åº¦ `j` çš„å­—ç¬¦ä¸² `p` ç›¸åŒ¹é…

```go
if s[i-1] == p[j-1] || p[j-1] == '?' { // å½“å°¾éƒ¨çš„ä¸¤ä¸ªå­—ç¬¦ç›¸åŒ æˆ–è€… på°¾éƒ¨ä¸º ï¼Ÿ
	       dp[i][j] = dp[i-1][j-1] 
	   } else if p[j-1] == '*' { // å½“ p å°¾éƒ¨å­—ç¬¦ä¸º *
   				// dp[i-1][j] è¡¨ç¤º ç”¨så°¾éƒ¨çš„å­—ç¬¦å’Œpå°¾éƒ¨å­—ç¬¦*è¿›è¡Œä¸€æ¬¡åŒ¹é…ï¼ŒåŒ¹é…åsé•¿åº¦å˜çŸ­ï¼Œpä¿æŒä¸å˜ï¼ˆä¹Ÿå°±æ˜¯*è¿˜å¯ä»¥ç»§ç»­ç”¨æ¥åŒ¹é…ï¼‰
   				// dp[i][j-1] è¡¨ç¤º på°¾éƒ¨å­—ç¬¦ * ä¸ç”¨æ¥åŒ¹é…ï¼ˆå¿½ç•¥*çš„å­˜åœ¨ï¼‰
	       dp[i][j] = dp[i-1][j] || dp[i][j-1]  
	   }
```
ä»£ç å¦‚ä¸‹ï¼š

```go
func isMatch(s string, p string) bool {
	

	m, n := len(s), len(p)
  // å®šä¹‰äºŒç»´dpæ•°ç»„
	dp := make([][]bool, m+1)
	for i := 0; i <= m; i++ {
		dp[i] = make([]bool, n+1)
	}
	// base case ä¸¤ä¸ªé•¿åº¦éƒ½æ˜¯0
	dp[0][0] = true
	
  // å½“sçš„é•¿åº¦ä¸º0ï¼Œpå­—ç¬¦ä¸²ä¸ºï¼š*****
	for j := 1; j <= n; j++ {
		if p[j-1] == '*' { // på°¾éƒ¨å­—ç¬¦ä¸º*æ—¶ï¼ˆå¿½ç•¥*çš„å­˜åœ¨ï¼‰
			dp[0][j] = dp[0][j-1]
		}
	}

	for i := 1; i <= m; i++ {
		for j := 1; j <= n; j++ {
			if s[i-1] == p[j-1] || p[j-1] == '?' {
				dp[i][j] = dp[i-1][j-1]
			} else if p[j-1] == '*' {
				dp[i][j] = dp[i-1][j] || dp[i][j-1] // dp[i-1][j] è¡¨ç¤º*åŒ¹é…ä¸€ä¸ªå­—ç¬¦ dp[i][j-1] è¡¨ç¤º*ä¸åŒ¹é…å­—ç¬¦ï¼ˆå¿½ç•¥*ï¼‰
			}
		}
	}
    return dp[m][n]
}
```

> æ¥è‡ª: [algorithm-go/è®©æˆ‘ä»¬ä¸€èµ·åˆ·ç®—æ³•.md at main Â· gofish2020/algorithm-go](https://github.com/gofish2020/algorithm-go/blob/main/%E8%AE%A9%E6%88%91%E4%BB%AC%E4%B8%80%E8%B5%B7%E5%88%B7%E7%AE%97%E6%B3%95.md)

â€‹
â€‹
