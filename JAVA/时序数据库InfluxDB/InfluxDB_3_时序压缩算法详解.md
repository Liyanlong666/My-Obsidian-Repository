# InfluxDB 时序压缩算法详解

## 1. 整数压缩技术

### VInt (变长整数)
通过避免存储前导 0 来节约空间。每个字节的低 7 位存储数据，最高位（MSB）为标记位：1 表示后续还有字节，0 表示结束。

**Java 实现参考 (Lucene):**
```java
public final void writeVInt(int i) throws IOException {
    while ((i & ~0x7F) != 0) {
        writeByte((byte) ((i & 0x7F) | 0x80)); // 取低7位并标记最高位为1
        i >>>= 7; // 无符号右移7位
    }
    writeByte((byte) i); // 最后一个字节标记位为0
}
```

### ZigZag 编码
VInt 无法压缩负数（负数补码前导 1 很多）。ZigZag 将负数映射为正数：
*   **公式**: `(i >> 31) ^ (i << 1)`
*   **推导**: `-1` 变为 `1`，`1` 变为 `2`，`-2` 变为 `3`。通过位操作统一处理，性能极佳。

### Simple8b
将多个小整数打包到 64 位中。前 4 位为 **Selector**，决定后续 60 位如何切分。
| Selector | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | ... | 15 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| **Bits/Int** | 0 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | ... | 60 |
| **Int Count** | 240 | 120 | 60 | 30 | 20 | 15 | 12 | 10 | ... | 1 |

---

## 2. 时间戳压缩：Delta-of-Delta

InfluxDB 默认 Block 窗口为 4 小时。
1.  存储起始时间戳（Header, 64bit）。
2.  存储第一个差值（14bit）。
3.  对后续时间戳计算 **Delta-of-Delta (D)**：
    *   `D = 0`: 存储 '0' (1 bit)。
    *   `-63 < D < 64`: 标记 `10` + 7位数据。
    *   `-255 < D < 256`: 标记 `110` + 9位数据。
    *   `-2047 < D < 2048`: 标记 `1110` + 12位数据。
    *   否则: 标记 `1111` + 32位数据。
*   **效果**: 实验表明 90% 以上的数据差值为 0。

---

## 3. 浮点数压缩：Gorilla XOR

相邻浮点数的 IEEE 754 编码位通常很接近，异或（XOR）后会有大量前导和后导 0。
1.  第一个值原样存储。
2.  后续值与前值 XOR：
    *   **结果为 0**: 存储 '0' (1 bit)。
    *   **结果不为 0**:
        *   **情况 A**: 若 XOR 结果的“前导0”和“有效位长度”与前一 XOR 结果相同：存储标记位 `10` + 有效位。
        *   **情况 B**: 否则：存储标记位 `11` + 5位前导0数量 + 6位有效位长度 + 有效位。

---

## 4. 字符串与布尔值

*   **字符串 (Strings)**: 使用 Snappy 压缩。将多个字符串合并为一个大块进行处理。
*   **布尔值 (Booleans)**: 位打包 (Bit Packing)。每个值占用 1 bit，开头用可变字节记录数量。

---
*整理自：时序数据常用压缩算法 - 知乎、内存索引和时间结构合并树 (TSM) 相关文档。*

