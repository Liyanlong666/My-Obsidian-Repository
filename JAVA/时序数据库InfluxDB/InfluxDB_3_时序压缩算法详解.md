# InfluxDB 时序压缩算法详解

时序数据的特点是数值变化规律、时间戳连续。针对这些特性，InfluxDB 使用了多种高效的压缩算法，将磁盘空间占用降至最低。

## 1. 基础编码技术

### VInt (变长整数)
*   **原理**: 使用每个字节的最高位作为标记位（0表示结束，1表示后续还有）。低7位存储真实数据。
*   **适用性**: 极适合存储小整数。对于大数和负数，可能比固定长度更占空间。

### ZigZag 编码
*   **目的**: 解决负数在 VInt 下无法有效压缩的问题。
*   **原理**: 将有符号数映射为无符号数（例如：0->0, -1->1, 1->2, -2->3）。
*   **公式**: `(i >> 31) ^ (i << 1)`。将符号位移动到最低位，消除负数前导的 1。

### Simple8b
*   **原理**: 将多个小整数打包进一个 64-bit 字中。
*   **结构**: 前 4 bits 是选择器（Selector），指定后续数据的打包方式（如：240个1-bit数，或 1个60-bit数）。
*   **适用性**: 极其适合编码小整数序列。

---

## 2. 时间戳压缩：Delta-of-Delta

时间戳通常是高度规律的（如每秒采集一次）。
1.  **Delta**: 计算相邻时间戳的差值。
2.  **Delta-of-Delta**: 计算差值的差值。
    *   如果数据是等间隔采集的，Delta-of-Delta 的结果大部分为 **0**。
3.  **编码规则**:
    *   结果为 0: 仅需 1 bit 存储。
    *   值域在 [-63, 64]: 存储标记位 + 7位数值。
    *   值域在 [-255, 256]: 存储标记位 + 9位数值。
    *   ...以此类推。

---

## 3. 数值压缩

### 浮点数 (Floats)：Gorilla XOR 压缩
基于 Facebook 的 Gorilla 论文。
*   **原理**: 相邻数据点变化通常很小，其 IEEE 754 编码的二进制位有大量重复。
*   **过程**: 计算相邻值的异或 (XOR)。
    *   若 XOR 为 0：存储 '0' (1 bit)。
    *   若 XOR 不为 0：存储标记位、前导零个数、有效位数及有效位值。
*   **效果**: 在很多场景下可实现 50% 以上的压缩率。

### 整数 (Integers)
*   首先使用 **ZigZag** 处理负数。
*   根据数据范围选择 **Simple8b** 或 **RLE** (游程编码)。
*   若所有值均相同，使用 RLE；若值较小且多变，使用 Simple8b。

### 字符串 (Strings)
*   使用 **Snappy** 压缩。将多个字符串打包在一起作为一个大块进行压缩。

---

## 4. 总结

| 数据类型 | 压缩算法 |
| --- | --- |
| **时间戳 (Timestamp)** | Delta-of-Delta |
| **浮点数 (Float)** | Gorilla XOR 编码 |
| **整数 (Integer)** | ZigZag + Simple8b / RLE |
| **布尔值 (Boolean)** | 位打包 (Bit Packing, 1 bit/value) |
| **字符串 (String)** | Snappy |

---
*整理自：时序数据常用压缩算法 - 知乎、内存索引和时间结构合并树 (TSM) 相关文档。*
