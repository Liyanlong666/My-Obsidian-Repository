# InfluxDB 选型对比与架构演进

## 1. 深度选型对比

### 1.1 InfluxDB vs. 传统 RDBMS (如 MySQL)
*   **写入模型**: MySQL 的 B+ 树在大量随机插入时会导致频繁的页面分裂和 IOPS 飙升；InfluxDB 使用 LSM 变体（TSM），将随机写转为顺序写。
*   **存储效率**: InfluxDB 专用的列式压缩比 MySQL 节省空间 10 倍以上。
*   **自动清理**: InfluxDB 内置 RP (Retention Policy)，无需手动 DELETE 或维护分区表。

### 1.2 与其他主流 TSDB 对比
| 数据库 | 核心特点 | 优势 | 劣势 |
| --- | --- | --- | --- |
| **Prometheus** | 监控告警专用 | 生态极其强大，PromQL 灵活。 | 长期存储较弱（需扩展），不支持高基数复杂数据。 |
| **TimescaleDB** | 基于 PostgreSQL | 支持完整 SQL，复杂 JOIN 强，可靠性高。 | 运维复杂度高，纯时序场景性能略逊。 |
| **OpenTSDB** | 基于 HBase | 支持海量集群，线性扩展强。 | 依赖 HBase，运维极其沉重，查询延迟波动大。 |
| **Druid** | OLAP 分析引擎 | 大规模聚合查询性能极强。 | 极其重量级，架构复杂，对原始数据点查询优化一般。 |
| **InfluxDB** | 独立、高性能 | **开箱即用，写读平衡，生态完善 (TICK)。** | 单机版高基数下内存压力大。 |

---

## 2. 存储引擎进化史

*   **0.8.x**: 尝试 LevelDB/RocksDB，深陷“文件句柄过多”和“不支持热备”的困扰。
*   **0.9.x (前中期)**: 转向 **BoltDB** (B+树)。解决了备份问题，但在 GB 级数据量后，随机写 IOPS 导致性能雪崩。
*   **0.9.5+**: **TSM** 诞生。结合了 LSM 的顺序写、B+ 树的单文件管理及专门的列式压缩。

---

## 3. 架构范式转移：InfluxDB 3.0

3.0 版本放弃了 TSM 引擎，全面转向 **Rust + Apache Arrow + Parquet** 的云原生架构。

### 核心分布式组件
1.  **Router (路由器)**: 负责数据解析、模式检查、数据路由与复制，确保高可用。
2.  **Ingester (摄取器)**: 将数据按 **Parquet** 格式持久化到对象存储，并维护短期 WAL 供即时查询。
3.  **Querier (查询器)**: 执行 SQL/InfluxQL，从 Ingester 读取热数据，从对象存储读取历史 Parquet 数据。
4.  **Compactor (压缩器)**: 在后台持续优化对象存储中的 Parquet 文件，进行重组和深度压缩。
5.  **Object Store (对象存储)**: 如 S3, OSS。存储最终的列式数据，空间成本降低 90%。

### 3.0 的核心价值
*   **无限标签基数**: 彻底解决了 1.x 中 TSI 索引过大导致的内存限制。
*   **零拷贝互操作**: 直接生成 Parquet 文件，无需 ETL 即可被 Spark, Presto 等大数据工具直接读取。

---
*整理自：时序数据库选型对比、TSM 存储引擎与 LSM 树、InfluxDB 3.0 架构深度解析相关文档。*

