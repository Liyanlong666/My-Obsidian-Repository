## 多线程循环有序打印

```java
// package com.lyl.coding;

/**
 * 使用锁和条件变量来控制三个线程按顺序执行打印任务
 * 该类实现了线程的有序打印，每个线程负责打印特定的数字序列
 */
public class multiThread {
    // 线程数量
    private static final int N = 3;
    // 最大打印数量
    private static final int MAX = 100;
    // 锁对象
    private static final Object LOCK = new Object();
    // 当前需要打印的数字
    private static int count = 0;


    static class MyThread extends Thread {

        private final int threadId;

        public MyThread(int threadId) {
            this.threadId = threadId;
        }

        @Override
        public void run() {
            while (true) {
                synchronized (LOCK) {
                    if (count >= MAX) {
                        break;
                    }
                    // 当前线程应该打印的数字
                    if (count % 3 == threadId) {
                        count++;
                        System.out.println("Thread-" + threadId + ": " + count);
                        LOCK.notifyAll();
                    } 
                    else {
                        try {
                            LOCK.wait();
                        } 
                        catch (Exception e) {
                            Thread.currentThread().interrupt();
                        }
                    }
                }
            }
        }
    }


    public static void main(String[] args) {
        for (int i = 0; i < N; i++) {
            MyThread th = new MyThread(i);
            th.start();
        }
    }
}

```
## 生产者消费者问题


```java
package com.lyl.coding;

import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.Semaphore;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class ProducerConsumer {
    private static final String[] buffer = new String[10];
    private static int in = 0, out = 0;
    private static final Semaphore empty = new Semaphore(10);
    private static final Semaphore full = new Semaphore(0);
    private static final Semaphore mutex = new Semaphore(1);


    public static class Producer implements Runnable {
        @Override
        public void run(){
            try {
                while (true) {
                    empty.acquire();
                    mutex.acquire();
                    //write
                    buffer[in] = "data" + in;
                    in = (in + 1) % 10;
                    mutex.release();
                    full.release();
                }
            }
            catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
    public static class Consumer implements Runnable {
        private int consumerId;
        public Consumer(int consumerId) {
            this.consumerId = consumerId;
        }
        //3个消费者 用线程池方式消费
        @Override
        public void run(){
            try {
                while (true) {
                    full.acquire();
                    mutex.acquire();
                    //read
                    System.out.println("consumer:" + consumerId +"  " + buffer[out]);
                    out = (out + 1) % 10;
                    mutex.release();
                    empty.release();
                }
            }
            catch (Exception e) {
                e.printStackTrace();
            }
        }

    }

    public static void main(String[] args) {
        Producer p = new Producer();
        p.run();
        ThreadPoolExecutor executor = new ThreadPoolExecutor(3, 10, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>());

        for (int i = 0; i < 3; i++) {
            Consumer c = new Consumer(i);
            executor.execute(c);
        }
        new Thread(p).start();


    }
}


```
## 自己实现一个 HashMap

```java
package com.lyl.coding;

public class MyHashMap<K,V> {
    static class Node<K,V>{
        K key;
        V value;
        Node<K,V> next;
        public Node(){

        }
        public Node(K key, V value){
            this.key = key;
            this.value = value;
        }
    }
    private Node[] table;
    private int size;
    private static final int DEFAULT_CAPACITY = 16;
    public MyHashMap(){
        table = new Node[DEFAULT_CAPACITY];
        size = 0;
    }
    public V get(K key){
        int code = key.hashCode() ^ (key.hashCode() >> 16);
        int index = code % table.length ;
        if(table[index] == null) {
            return null;
        }
        for(Node<K,V> node = table[index]; node != null; node = node.next){
            if(key.equals(node.key)) {
                return node.value;
            }
        }
        return null;
    }
    public boolean  remove(K key) {
        int code = key.hashCode() ^ (key.hashCode() >> 16);
        int index = code % table.length ;
        if(table[index] == null) {
            return false;
        }
        Node<K,V> pre = new Node();
        for(Node<K,V> node = table[index]; node != null; node = node.next){
            if(key.equals(node.key)) {
                break;
            }
            pre = node;
        }
        return true;
    }
    public void put(K key,V value){
        int code = key.hashCode() ^ (key.hashCode() >> 16);
        int index = code % table.length ;
        if(table[index] == null) {
            table[index] = new Node(key, value);
            size++;
            return;
        }
        for(Node<K,V> node = table[index]; node != null; node = node.next){
            if(key.equals(node.key)) {
                node.value = value;
                return;
            }
        }
        //头插

        Node node = table[index];
        table[index] = new Node(key, value);
        table[index].next = node;
        size++;

    }
}

```
## 自己实现一个线程池
### 核心线程池类：
CustomThreadPoolExecutor
```java
class CustomThreadPoolExecutor {

    private final int corePoolSize;
    private final int maximumPoolSize;
    private final long keepAliveTime;
    private final TimeUnit unit;
    private final BlockingQueue<Runnable> workQueue;
    private final RejectedExecutionHandler handler;

    private volatile boolean isShutdown = false;
    private int currentPoolSize = 0;

    // 构造方法
    public CustomThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit,
                                    BlockingQueue<Runnable> workQueue, RejectedExecutionHandler handler) {
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.keepAliveTime = keepAliveTime;
        this.unit = unit;
        this.workQueue = workQueue;
        this.handler = handler;
    }

    // 提交任务
    public void execute(Runnable task) {
        if (isShutdown) {
            throw new IllegalStateException("ThreadPool is shutdown");
        }

        synchronized (this) {
            // 如果当前线程数小于核心线程数，直接创建新线程
            if (currentPoolSize < corePoolSize) {
                new Worker(task).start();
                currentPoolSize++;
                return;
            }

            // 尝试将任务添加到队列中
            if (!workQueue.offer(task)) {
                if (currentPoolSize < maximumPoolSize) {
                    new Worker(task).start();
                    currentPoolSize++;
                } else {
                    // 调用拒绝策略
                    handler.rejectedExecution(task, null);
                }
            }
        }
    }

    // 关闭线程池
    public void shutdown() {
        isShutdown = true;
    }

    // 工作线程
    private class Worker extends Thread {
        private Runnable task;

        Worker(Runnable task) {
            this.task = task;
        }

        @Override
        public void run() {
            while (task != null || (task = getTask()) != null) {
                try {
                    task.run();
                } finally {
                    task = null;
                }
            }
        }

        // 从队列中获取任务
        private Runnable getTask() {
            try {
                return workQueue.poll(keepAliveTime, unit);
            } catch (InterruptedException e) {
                return null;
            }
        }
    }
}
```
### 拒绝策略

```java
/**
 * 拒绝策略
 */
class CustomRejectedExecutionHandler {

    // AbortPolicy 抛出异常
    public static class AbortPolicy implements RejectedExecutionHandler {
        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
            throw new RuntimeException("Task " + r.toString() + " rejected from " + e.toString());
        }
    }

    // DiscardPolicy 什么都不做
    public static class DiscardPolicy implements RejectedExecutionHandler {
        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
            // Do nothing
        }
    }

    // DiscardOldestPolicy 丢弃队列中最旧的任务
    public static class CallerRunsPolicy implements RejectedExecutionHandler {
        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
            if (!e.isShutdown()) {
                r.run();
            }
        }
    }
}
```
### 使用示例：

```java
class ThreadPoolTest {
    public static void main(String[] args) {
        // 创建线程池
        CustomThreadPoolExecutor executor = new CustomThreadPoolExecutor(
                2, 4, 10, TimeUnit.SECONDS,
                new LinkedBlockingQueue<>(2),
                new CustomRejectedExecutionHandler.AbortPolicy());

        // 提交任务
        for (int i = 0; i < 10; i++) {
            final int index = i;
            executor.execute(() -> {
                System.out.println("Task " + index + " is running");
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            });
        }

        // 关闭线程池
        executor.shutdown();
    }
}
```
