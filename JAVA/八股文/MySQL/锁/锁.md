## 锁
### MySQL锁机制：锁住的对象详解
MySQL中的锁可以锁定不同粒度的对象，从粗粒度到细粒度主要包括以下几种：
#### 1. 全局锁（Global Lock）

- **锁住对象**：整个数据库实例
- **实现方式**：`FLUSH TABLES WITH READ LOCK` (FTWRL)
- **影响范围**：所有表的写操作和DDL操作被阻塞
- **使用场景**：全库逻辑备份#### 2. 表级锁（Table-Level Lock）
##### 表锁

- **锁住对象**：整张表
- **类型**：
- 表共享读锁（S锁）
- 表独占写锁（X锁）
- **实现方式**：`LOCK TABLES ... READ/WRITE`##### 元数据锁（MDL, Metadata Lock）

- **锁住对象**：表结构（schema）
- **特点**：
- 自动加锁，无需显式操作
- 任何表操作都会先获取MDL读锁
- 表结构变更需要MDL写锁#### 3. 行级锁（Row-Level Lock）
##### 记录锁（Record Lock）

- **锁住对象**：索引记录
- **特点**：
- 锁定索引项（即使表没有索引，InnoDB也会创建隐藏聚簇索引）
- `SELECT ... FOR UPDATE`会在扫描到的索引记录上加记录锁##### 间隙锁（Gap Lock）

- **锁住对象**：索引记录之间的间隙
- **特点**：
- 防止其他事务在间隙中插入新记录
- 只在REPEATABLE READ及以上隔离级别生效
- `SELECT ... FOR UPDATE`可能加间隙锁##### 临键锁（Next-Key Lock）

- **锁住对象**：索引记录+前面的间隙（左开右闭区间）
- **特点**：
- 记录锁+间隙锁的组合
- InnoDB默认的行锁算法
- 解决幻读问题的关键##### 插入意向锁（Insert Intention Lock）

- **锁住对象**：准备插入的间隙位置
- **特点**：
- 表示有事务想在某个间隙插入记录
- 多个事务可以在同一间隙的不同位置插入#### 4. 意向锁（Intention Lock）

- **锁住对象**：表级标记，指示事务将在表的某些行上获取锁
- **类型**：
- 意向共享锁（IS）：事务打算在某些行上加S锁
- 意向排他锁（IX）：事务打算在某些行上加X锁
- **作用**：快速判断表是否可以被加表锁> #### 锁住对象的本质
MySQL锁机制最终锁住的是**索引结构**：

1. 对于有主键的表，锁住的是主键索引
2. 对于有唯一索引的表，锁会加到唯一索引上
3. 对于无索引的表，InnoDB会使用隐藏的聚簇索引来加锁
4. 锁的粒度取决于查询使用的索引和隔离级别设置
理解锁住的对象对于优化SQL语句、设计索引和解决锁冲突问题非常重要。
### 53.MySQL 中有哪几种锁，列举一下？
![image.png](1747623540902-02b0ec66-3805-4a83-bfbd-df8fb6e7e35c.png)

按锁粒度划分的话，MySQL 的锁有：

- 表锁：开销小，加锁快；锁定力度大，发生锁冲突概率高，并发度最低；不会出现死锁。
- 行锁：开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高。
- 页锁：开销和加锁速度介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般。按兼容性划分的话，MySQL 的锁有：

- 共享锁（S Lock），也叫读锁（read lock），相互不阻塞。
- 排他锁（X Lock），也叫写锁（write lock），排它锁是阻塞的，在一定时间内，只有一个请求能执行写入，并阻止其它锁读取正在写入的数据。按加锁机制划分的话，MySQL 的锁有：
①、乐观锁
乐观锁基于这样的假设：冲突在系统中出现的频率较低，因此在数据库事务执行过程中，不会频繁地去锁定资源。相反，它在提交更新的时候才检查是否有其他事务已经修改了数据。
可以通过在数据表中使用版本号（Version）或时间戳（Timestamp）来实现，每次读取记录时，同时获取版本号或时间戳，更新时检查版本号或时间戳是否发生变化。
如果没有变化，则执行更新并增加版本号或更新时间戳；如果检测到冲突（即版本号或时间戳与之前读取的不同），则拒绝更新。
②、悲观锁
悲观锁假设冲突是常见的，因此在数据处理过程中，它会主动锁定数据，防止其他事务进行修改。
可以直接使用数据库的锁机制，如行锁或表锁，来锁定被访问的数据。常见的实现是 `SELECT FOR UPDATE` 语句，它在读取数据时就加上了锁，直到当前事务提交或回滚后才释放。
#### 如何解决库存超卖问题？
按照乐观锁的方式：

```sql
UPDATE inventory SET count = count - 1, version = version + 1 WHERE product_id = 1 AND version = current_version;
```
按照悲观锁的方式：
在事务开始时直接锁定库存记录，直到事务结束。

```sql
START TRANSACTION;
SELECT * FROM inventory WHERE product_id = 1 FOR UPDATE;
UPDATE inventory SET count = count - 1 WHERE product_id = 1;
COMMIT;
```
> 
1. [Java 面试指南（付费）](https://javabetter.cn/zhishixingqiu/mianshi.html)收录的小公司面经合集同学 1 Java 后端面试原题：乐观锁和悲观锁，库存的超卖问题的原因和解决方案？
2. [Java 面试指南（付费）](https://javabetter.cn/zhishixingqiu/mianshi.html)收录的京东同学 4 云实习面试原题：mysql一共有哪些锁
3. [Java 面试指南（付费）](https://javabetter.cn/zhishixingqiu/mianshi.html)收录的美团面经同学 15 点评后端技术面试原题：问了一下mysql的锁和MVCC
4. [Java 面试指南（付费）](https://javabetter.cn/zhishixingqiu/mianshi.html)收录的阿里系面经同学 19 饿了么面试原题：MySQL锁
### 54.全局锁和表级锁了解吗？（补充）
> 2024 年 07 月 15 日增补。

全局锁就是对整个数据库实例进行加锁，在 MySQL 中，可以使用 `FLUSH TABLES WITH READ LOCK` 命令来获取全局读锁。
全局锁的作用是保证在备份数据库时，数据不会发生变化【数据更新语句（增删改）、数据定义语句（建表、修改表结构等）和更新事务的提交语句】。当我们需要备份数据库时，可以先获取全局读锁，然后再执行备份操作。
#### 表锁了解吗？
表锁就是锁住整个表。在 MySQL 中，可以使用 `LOCK TABLES` 命令来锁定表。
表锁可以分为读锁（共享锁）和写锁（排他锁）。

```sql
LOCK TABLES your_table READ;
-- 执行读操作
UNLOCK TABLES;
```
读锁允许多个事务同时读取被锁定的表，但不允许任何事务进行写操作。

```sql
LOCK TABLES your_table WRITE;
-- 执行写操作
UNLOCK TABLES;
```
写锁允许一个事务对表进行读写操作，其他事务不能对该表进行任何操作（读或写）。
在进行大规模的数据导入、导出或删除操作时，为了防止其他事务对数据进行并发操作，可以使用表锁。
或者在进行表结构变更（如添加列、修改列类型）时，为了确保变更期间没有其他事务访问或修改该表，可以使用表锁。
> 
1. [Java 面试指南（付费）](https://javabetter.cn/zhishixingqiu/mianshi.html)收录的美团面经同学 3 Java 后端技术一面面试原题：数据库中的全局锁 表锁 行级锁  每种锁的应用场景有哪些
2. [Java 面试指南（付费）](https://javabetter.cn/zhishixingqiu/mianshi.html)收录的同学 30 腾讯音乐面试原题：mysql的表级锁有几种
### 55.说说 MySQL 的行锁？
行级锁（Row Lock）是数据库锁机制中最细粒度的锁，主要用于对单行数据进行加锁，以确保数据的一致性和完整性。
在 MySQL 中，InnoDB 存储引擎支持行级锁。通过 `SELECT ... FOR UPDATE` 可以加排他锁，通过 `LOCK IN SHARE MODE` 可以加共享锁。
比如说：

```sql
START TRANSACTION;

-- 加排他锁，锁定某一行
SELECT * FROM your_table WHERE id = 1 FOR UPDATE;
-- 对该行进行操作
UPDATE your_table SET column1 = 'new_value' WHERE id = 1;

COMMIT;
```

```sql
START TRANSACTION;

-- 加共享锁，锁定某一行
SELECT * FROM your_table WHERE id = 1 LOCK IN SHARE MODE;
-- 只能读取该行，不能修改

COMMIT;
```
在高并发环境中，行级锁能够提高系统的并发性能，因为锁定的粒度较小，只会锁住特定的行，不会影响其他行的操作。
#### select for update 加锁有什么需要注意的？
如果查询条件使用了索引（特别是主键索引或唯一索引），SELECT FOR UPDATE 会锁定特定的行，即行级锁，这样锁的粒度较小，不会影响未涉及的行或其他并发操作。
但如果查询条件未使用索引，SELECT FOR UPDATE 可能锁定整个表或大量的行，因为查询需要执行全表扫描。
假设有一张名为 orders 的表，包含以下数据：

```sql
CREATE TABLE orders (
    id INT PRIMARY KEY,
    order_no VARCHAR(255),
    amount DECIMAL(10,2),
    status VARCHAR(50),
    INDEX (order_no)  -- order_no 上有索引
);
```
表中的数据是这样的：
 | id | order_no | amount | status | 
|---|---|---|---|
 | 1 | 10001 | 50.00 | pending | 
 | 2 | 10002 | 75.00 | pending | 
 | 3 | 10003 | 100.00 | pending | 
 | 4 | 10004 | 150.00 | completed | 
 | 5 | 10005 | 200.00 | pending | 
如果我们通过主键索引执行 SELECT FOR UPDATE，只会锁定特定的行：

```sql
START TRANSACTION;
SELECT * FROM orders WHERE id = 1 FOR UPDATE;
-- 对 id=1 的行进行操作
COMMIT;
```
由于 id 是主键，所以只会锁定 `id=1` 这行，不会影响其他行的操作。其他事务依然可以对 id = 2, 3, 4, 5 等行执行更新操作，因为它们没有被锁定。
如果使用 order_no 索引执行 SELECT FOR UPDATE，也只会锁定特定的行：

```sql
START TRANSACTION;
SELECT * FROM orders WHERE order_no = '10001' FOR UPDATE;
-- 对 order_no=10001 的行进行操作
COMMIT;
```
因为 order_no 上有索引，所以只会锁定 `order_no=10001` 这行，不会影响其他行的操作。
但如果查询 `status='pending'`，而 status 上没有索引：

```sql
START TRANSACTION;
SELECT * FROM orders WHERE status = 'pending' FOR UPDATE;
-- 对 status=pending 的行进行操作
COMMIT;
```
查询需要执行全表扫描。在这种情况下，SELECT FOR UPDATE 可能会锁定表中所有符合条件的记录，甚至是整个表，因为 MySQL 需要检查每一行的 status。
这会影响表中的大部分记录，其他事务将无法修改这些记录，直到当前事务结束。
#### 说说 InnoDB 的行锁实现？
我们拿这么一个用户表来表示行级锁，其中插入了 4 行数据，主键值分别是 1,6,8,12，现在简化它的聚簇索引结构，只保留数据记录。
![image.png](1747623540681-aeb77a6a-c185-4841-82d3-2b64301a2913.png)

InnoDB 的行锁的主要实现如下：
①、**Record Lock 记录锁**
记录锁就是直接锁定某行记录。当我们使用唯一性的索引(包括唯一索引和聚簇索引)进行等值查询且精准匹配到一条记录时，此时就会直接将这条记录锁定。例如`select * from t where id =6 for update;`就会将`id=6`的记录锁定。
![image.png](1747623540783-7e09a2e9-2420-468d-8e55-66e35921ba2a.png)


③、**Next-key Lock 临键锁**
临键指的是间隙加上它右边的记录组成的**左开右闭区间**。比如上述的`(1,6]、(6,8]`等。
![image.png](1747623540979-ba2d7f6a-76e8-44d4-8ba5-0d92e3c1f45b.png)

临键锁就是记录锁(Record Locks)和间隙锁(Gap Locks)的结合，即除了锁住记录本身，还要再锁住索引之间的间隙。当我们使用范围查询，并且命中了部分`record`记录，此时锁住的就是临键区间。
注意，临键锁锁住的区间会包含最后一个 record 的右边的临键区间。
例如 `select * from t where id > 5 and id <= 7 for update;` 会锁住`(4,7]、(7,+∞)`。
MySQL 默认行锁类型就是`临键锁(Next-Key Locks)`。当使用唯一性索引，等值查询匹配到一条记录的时候，临键锁(Next-Key Locks)会退化成记录锁；没有匹配到任何记录的时候，退化成间隙锁。
`间隙锁(Gap Locks)`和`临键锁(Next-Key Locks)`都是用来解决幻读问题的，在`已提交读（READ COMMITTED）`隔离级别下，`间隙锁(Gap Locks)`和`临键锁(Next-Key Locks)`都会失效！
上面是行锁的三种实现算法，除此之外，在行上还存在插入意向锁。
④、**Insert Intention Lock 插入意向锁**
一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了意向锁 ，如果有的话，插入操作需要等待，直到拥有 gap 锁 的那个事务提交。但是事务在等待的时候也需要在内存中生成一个 锁结构 ，表明有事务想在某个 间隙 中插入新记录，但是现在在等待。这种类型的锁命名为 Insert Intention Locks ，也就是插入意向锁 。
假如我们有个 T1 事务，给(1,6)区间加上了意向锁，现在有个 T2 事务，要插入一个数据，id 为 4，它会获取一个（1,6）区间的插入意向锁，又有有个 T3 事务，想要插入一个数据，id 为 3，它也会获取一个（1,6）区间的插入意向锁，但是，这两个插入意向锁锁不会互斥。
![image.png](1747623540757-6440a006-7ad1-40de-9571-274733b9bf59.png)

> 
1. [Java 面试指南（付费）](https://javabetter.cn/zhishixingqiu/mianshi.html)收录的美团面经同学 3 Java 后端技术一面面试原题：数据库中的全局锁 表锁 行级锁  每种锁的应用场景有哪些
2. [Java 面试指南（付费）](https://javabetter.cn/zhishixingqiu/mianshi.html)收录的招银网络科技面经同学 9 Java 后端技术一面面试原题：select for update 加锁有什么需要注意的
### 85. 间隙锁了解吗？（补充）
> 2024 年 12 月 15 日增补。

间隙锁用于在范围查询时锁定记录之间的“间隙”，防止其他事务在该范围内插入新记录。
假设表 test_gaplock 有 id、age、name 三个字段，其中 id 是主键，age 上有索引，并插入了 4 条数据。

```sql
CREATE TABLE `test_gaplock` (
  `id` int(11) NOT NULL,
  `age` int(11) DEFAULT NULL,
  `name` varchar(20) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `age` (`age`)
) ENGINE=InnoDB;

insert into test_gaplock values(1,1,'张三'),(6,6,'吴老二'),(8,8,'赵四'),(12,12,'熊大');
```
间隙锁会锁住以下范围：

- (−∞, 1)：在最小记录之前的间隙。
- (1, 6)、(6, 8)、(8, 12)：记录之间的间隙。
- (12, +∞)：在最大记录之后的间隙。![image.png](1747623540988-4e9f0b0c-f57e-4c9c-bd3e-55ab7ab466d2.png)

假设有两个事务，T1 执行以下语句：

```sql
START TRANSACTION;
SELECT * FROM test_gaplock WHERE age > 5 FOR UPDATE;
```
T2 执行以下语句：

```sql
START TRANSACTION;
INSERT INTO test_gaplock VALUES (7, 7, '王五');
```
T1 会锁住 (6, 8) 的间隙，防止其他事务在这个范围内插入新记录。
T2 在插入 (7, 7, '王五') 时，会被阻塞，可以在另外一个回话中执行 `SHOW ENGINE INNODB STATUS` 查看间隙锁的信息。
![image.png](1747623541507-fbe3f6d2-08ba-46d1-aa91-485f0d634057.png)

推荐阅读：[六个案例搞懂间隙锁](https://www.51cto.com/article/779551.html)、[MySQL中间隙锁的加锁机制](https://blog.csdn.net/javaanddonet/article/details/111187345)
#### 执行什么命令会加上间隙锁？
当范围查询与锁定操作（如 FOR UPDATE）结合时，InnoDB 会对查询范围内的记录间隙加上间隙锁。

```sql
SELECT * FROM table WHERE column > 10 and column < 20 FOR UPDATE;
```
> 
1. [Java 面试指南（付费）](https://javabetter.cn/zhishixingqiu/mianshi.html)收录的阿里云面经同学 22 面经：mysql的什么命令会加上间隙锁
### 56.意向锁是什么知道吗？
意向锁是一个表级锁，不要和插入意向锁搞混。
意向锁的出现是为了支持 InnoDB 的多粒度锁，它解决的是表锁和行锁共存的问题。
当我们需要给一个表加表锁的时候，我们需要根据去判断表中有没有数据行被锁定，以确定是否能加成功。
假如没有意向锁，那么我们就得遍历表中所有数据行来判断有没有行锁；
有了意向锁这个表级锁之后，则我们直接判断一次就知道表中是否有数据行被锁定了。
有了意向锁之后，要执行的事务 A 在申请行锁（写锁）之前，数据库会自动先给事务 A 申请表的意向排他锁。当事务 B 去申请表的互斥锁时就会失败，因为表上有意向排他锁之后事务 B 申请表的互斥锁时会被阻塞。
![image.png](1747623541273-a57b9570-53c6-42bb-bef2-96cf157469af.png)

### 57.MySQL 的乐观锁和悲观锁了解吗？
悲观锁认为它保护的数据是非常敏感的，每时每刻都有可能被改动，一个事务在拿到悲观锁后，其他事务不能对该数据进行修改，直到它提交或回滚后。
MySQL 中的行锁、表锁都是悲观锁。
乐观锁则认为数据的变动不会太频繁。通常通过版本号(version)或者时间戳(timestamp)来实现。
事务拿到数据后，会将数据的版本号也取出来(比如说标记为 v1)，当数据变动完想要更新到表中时，会将最新的版本 v2 和 v1 进行对比，如果 v1=v2，说明在数据变动期间，没有其他事务对数据进行修改。
此时，事务提交就会成功，并且 version 会加 1，以此来表明数据已变动。
如果 v1 不等于 v2，说明数据变动期间，数据被其他事务修改了，此时需要通知用户重新操作。
悲观锁是 MySQL 自带的，而乐观锁通常需要开发者自己去实现。
> 
1. [Java 面试指南（付费）](https://javabetter.cn/zhishixingqiu/mianshi.html)收录的京东面经同学 5 Java 后端技术一面面试原题：乐观锁与悲观锁
### 58.遇到过死锁问题吗，你是如何解决的？
有，一次典型的场景是在[技术派](https://javabetter.cn/zhishixingqiu/paicoding.html)项目中，两个事务分别更新两张表，但是更新顺序不一致，导致了死锁。

```sql
-- 创建表/插入数据
CREATE TABLE account (
    id INT AUTO_INCREMENT PRIMARY KEY,
    balance INT NOT NULL
);

INSERT INTO account (balance) VALUES (100), (200);

-- 事务 1
START TRANSACTION;
-- 锁住 id=1 的行
UPDATE account SET balance = balance - 10 WHERE id = 1;

-- 等待锁住 id=2 的行（事务 2 已锁住）
UPDATE account SET balance = balance + 10 WHERE id = 2;

-- 事务 2
START TRANSACTION;
-- 锁住 id=2 的行
UPDATE account SET balance = balance - 10 WHERE id = 2;

-- 等待锁住 id=1 的行（事务 1 已锁住）
UPDATE account SET balance = balance + 10 WHERE id = 1;
```
两个事务访问相同的资源，但是访问顺序不同，导致了死锁。
![image.png](1747623541637-6dcb9a74-14b8-4b7e-ab67-9c9db3476874.png)

解决方法：
第一步，使用 `SHOW ENGINE INNODB STATUS\G;` 查看死锁信息。
![image.png](1747623541841-c141d6f3-0d94-4235-8212-3c53e16c36ac.png)

第二步，调整事务的资源访问顺序，保持一致。
> 
1. [Java 面试指南（付费）](https://javabetter.cn/zhishixingqiu/mianshi.html)收录的虾皮面经同学 13 一面面试原题：遇到过mysql死锁或者数据不安全吗
GitHub 上标星 10000+ 的开源知识库《[二哥的 Java 进阶之路](https://github.com/itwanger/toBeBetterJavaer)》第一版 PDF 终于来了！包括 Java 基础语法、数组&字符串、OOP、集合框架、Java IO、异常处理、Java 新特性、网络编程、NIO、并发编程、JVM 等等，共计 32 万余字，500+张手绘图，可以说是通俗易懂、风趣幽默……详情戳：[太赞了，GitHub 上标星 10000+ 的 Java 教程](https://javabetter.cn/overview/)
微信搜 **沉默王二** 或扫描下方二维码关注二哥的原创公众号沉默王二，回复 **222** 即可免费领取。
![image.png](1747623541363-eb8ea40c-d80c-423a-8bff-01707b979ef1.png)

